(Không dùng Canvas) Bạn có thể code để thực hiện toàn bộ các chức năng sau được không (Ở business-service, service riêng khác với core-service)

- Chia các proto riêng ra theo từng chức năng
- Sử dụng dto request, response với các api create, update, patch thì trả ra void. Để format giống với core-service và ở gateway, những dto ở trong service thì kết thúc có "Dto", những dto request ở gateway thì có "Body", response ở gateway thì có "View", là class hay record và có các annotation theo đúng format đã có từ trước
- Map bằng mapstruct (có đặt tên mapper giống với format)
- với các phương tức delete, không dùng repository.delete() mà mark delete, với restore thì dùng native query không thì không query được vì entity theo @Where
- controller ở gateway thì thêm cả consumer và producer
- Sửa để có thêm quản trị theo Role (requireAdmin)

- Không sửa các entity, query dùng bảng trung gian
**Biến thể (SKU, giá)**

* Tạo/sửa/xóa biến thể → `ProductVariants` (→ `Products`)
* Tra cứu theo SKU → `ProductVariants`
* Cập nhật giá / giá gốc → `ProductVariants`
* Liệt kê biến thể theo sản phẩm → `ProductVariants`

**Thuộc tính biến thể**

* Tạo thuộc tính (từ điển name–value) → `Attributes`
* Gán thuộc tính cho biến thể → `VariantAttributeValues` (→ `ProductVariants`, `Attributes`)
* Bỏ gán thuộc tính khỏi biến thể → `VariantAttributeValues`
* Liệt kê thuộc tính của 1 biến thể → `VariantAttributeValues`

**Ảnh sản phẩm/biến thể**

* Thêm ảnh (product/variant) → `ProductImages`
* Đặt ảnh thumbnail (`is_thumbnail=true`, unset cái cũ) → `ProductImages`
* Xóa ảnh (soft) → `ProductImages`
* Liệt kê ảnh theo product/variant → `ProductImages`

* Tạo/sửa/xóa mã giảm giá → `Discounts`
* Bật/tắt mã (`is_active`) → `Discounts`
* Tìm/validate mã (theo `code`, kiểm tra `is_active`, `window start/end`, `min_order_value`) → `Discounts`
* Tính tiền giảm cho đơn/giỏ (theo `type` percentage/fixed, clamp ≥0) → (runtime) + tham chiếu `Discounts`
* Liệt kê mã đang hiệu lực (filter theo thời gian) → `Discounts`

gatewayserver
package com.gatewayserver.configuration.grpc;

import io.grpc.CallOptions;
import io.grpc.Channel;
import io.grpc.ClientCall;
import io.grpc.ClientInterceptor;
import io.grpc.ClientInterceptors;
import io.grpc.ForwardingClientCall;
import io.grpc.Metadata;
import io.grpc.MethodDescriptor;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class ClientBearerInterceptor
        implements ClientInterceptor {

    private final String token;
    public static final Metadata.Key<String> AUTH =
            Metadata.Key.of("Authorization", Metadata.ASCII_STRING_MARSHALLER);

    @Override
    public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(
            MethodDescriptor<ReqT, RespT> methodDescriptor,
            CallOptions callOptions,
            Channel channel) {

        return new ForwardingClientCall.SimpleForwardingClientCall<ReqT, RespT>(channel.newCall(methodDescriptor, callOptions)) {
            @Override
            public void start(Listener<RespT> responseListener,
                              Metadata headers) {
                headers.put(AUTH, "Bearer " + token);
                super.start(responseListener, headers);
            }
        };
    }

    public static Channel withToken(
            Channel channel,
            String token) {
        return ClientInterceptors.intercept(channel, new ClientBearerInterceptor(token));
    }
}

package com.gatewayserver.configuration.helper;

import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.security.oauth2.server.resource.authentication.AbstractOAuth2TokenAuthenticationToken;
import org.springframework.security.oauth2.server.resource.authentication.BearerTokenAuthentication;
import reactor.core.publisher.Mono;

public final class ReactiveTokenHelper {
    private ReactiveTokenHelper() {}

    public static Mono<String> currentBearerToken() {
        return ReactiveSecurityContextHolder.getContext()
                .flatMap(ctx -> Mono.justOrEmpty(ctx.getAuthentication()))
                .filter(Authentication::isAuthenticated)
                .ofType(AbstractOAuth2TokenAuthenticationToken.class)
                .map(b -> b.getToken().getTokenValue())
                .filter(t -> t != null && !t.isBlank());
    }

}

package com.gatewayserver.configuration.routes;

import org.springframework.cloud.gateway.route.RouteLocator;
import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class GatewayRoutes {

    @Bean
    public RouteLocator routes(RouteLocatorBuilder builder){
        return builder.routes()
                // /core/** -> lb://core/**
                .route("core",
                        r -> r.path("/core/**")
                                .filters(f -> f.rewritePath("^/core(?<segment>/.*)$", "${segment}"))
                                .uri("lb://core"))
                // /business/** -> lb://business/**
                .route("business",
                        r -> r.path("/business/**")
                                .filters(f -> f.rewritePath("^/business(?<segment>/.*)$", "${segment}"))
                                .uri("lb://business"))
                .build();
    }
}
package com.gatewayserver.configuration.security;

import com.common.grpc.AuthServiceGrpc;
import com.common.grpc.IntrospectRequest;
import com.common.grpc.IntrospectResponse;
import com.nimbusds.jwt.SignedJWT;
import lombok.RequiredArgsConstructor;
import net.devh.boot.grpc.client.inject.GrpcClient;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.security.oauth2.jwt.ReactiveJwtDecoder;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

import java.text.ParseException;
import java.time.Instant;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

@Component
@RequiredArgsConstructor
public class GrpcReactiveJwtDecoder implements ReactiveJwtDecoder {

    @GrpcClient("core")
    private AuthServiceGrpc.AuthServiceBlockingStub authServiceBlockingStub;

    @Override
    public Mono<Jwt> decode(String token) throws JwtException {
        return Mono.fromCallable(() -> {
                    IntrospectResponse introspectResponse = authServiceBlockingStub
                            .introspect(IntrospectRequest.newBuilder()
                                        .setToken(token)
                                        .build());

                    if (!introspectResponse.getValid()) {
                        throw new JwtException("INVALID_TOKEN");
                    }

                    SignedJWT signedJWT;
                    try {
                        signedJWT = SignedJWT.parse(token);
                    } catch (ParseException e) {
                        throw new JwtException("JWT_PARSE_ERROR", e);
                    }

                    Map<String, Object> headers =
                            new HashMap<>(signedJWT.getHeader().toJSONObject());

                    Map<String, Object> claims =
                            new HashMap<>(signedJWT.getJWTClaimsSet().getClaims());

                    Date iat = signedJWT.getJWTClaimsSet().getIssueTime();
                    Date exp = signedJWT.getJWTClaimsSet().getExpirationTime();

                    Instant issuedAt = (iat == null) ? null : iat.toInstant();
                    Instant expiresAt = (exp == null) ? null : exp.toInstant();

                    return new Jwt(token, issuedAt, expiresAt, headers, claims);
                })
                .onErrorMap(e -> (e instanceof JwtException)
                        ? e
                        : new JwtException("AUTH_INTROSPECT_UNAVAILABLE", e));
    }
}
package com.gatewayserver.configuration.security;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.common.exception.ErrorCode;
import org.common.http.Envelope;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.server.ServerAuthenticationEntryPoint;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

@Component
public class ReactiveJwtEntryPoint implements ServerAuthenticationEntryPoint {

  private final ObjectMapper mapper = new ObjectMapper();

  @Override
  public Mono<Void> commence(
      ServerWebExchange exchange,
      AuthenticationException authenticationException) {
    ErrorCode code = ErrorCode.UNAUTHENTICATED;
    Envelope<Void> envelope = Envelope.err(
        code.http(),
        code.name(),
        code.getMessage(),
        null
    );

    ServerHttpResponse response = exchange.getResponse();
    response.setStatusCode(HttpStatus.valueOf(code.http()));
    response.getHeaders().setContentType(MediaType.APPLICATION_JSON);
    return response.writeWith(Mono.fromSupplier(() -> {
      try {
        byte[] bytes = mapper.writeValueAsBytes(envelope);
        return response.bufferFactory().wrap(bytes);
      } catch (Exception e) {
        return response.bufferFactory().wrap(new byte[0]);
      }
    }));
  }
}

package com.gatewayserver.configuration.security;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.security.web.server.SecurityWebFilterChain;

import static org.common.constant.SecurityConstants.PUBLIC_ENDPOINTS;

@Configuration
@RequiredArgsConstructor
public class SecurityConfig {

    private final GrpcReactiveJwtDecoder jwtDecoder;
    private final ReactiveJwtEntryPoint entryPoint;

    @Bean
    public SecurityWebFilterChain springSecurityFilterChain(
            ServerHttpSecurity http) {
        return http.csrf(ServerHttpSecurity.CsrfSpec::disable)
                .authorizeExchange(ex -> ex
                        .pathMatchers(PUBLIC_ENDPOINTS).permitAll()
                        .anyExchange().authenticated())
                .oauth2ResourceServer(oauth -> oauth.jwt(j -> j
                                .jwtDecoder(jwtDecoder))
                        .authenticationEntryPoint(entryPoint))
                .build();
    }
}

package com.gatewayserver.controller;

import com.common.grpc.AddressCreateRequest;
import com.common.grpc.AddressServiceGrpc;
import com.common.grpc.AddressUpdateRequest;
import com.common.grpc.IdRequest;
import com.common.grpc.UserIdRequest;
import com.gatewayserver.dto.request.user.AddressCreateRequestBody;
import com.gatewayserver.dto.request.user.AddressUpdateRequestBody;
import com.gatewayserver.dto.response.user.AddressResponseView;
import com.gatewayserver.helper.GrpcHelper;
import io.grpc.Channel;
import lombok.RequiredArgsConstructor;
import net.devh.boot.grpc.client.inject.GrpcClient;
import org.common.http.Envelope;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("/addresses")
@RequiredArgsConstructor
public class AddressController {

    @GrpcClient("core")
    private Channel coreChannel;

    private static String nz(String s){ return s == null ? "" : s; }
    private static String z(String s){ return (s == null || s.isBlank()) ? null : s; }

    @PostMapping(
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> create(
            @RequestBody AddressCreateRequestBody body){
        return GrpcHelper.callGrpcVoid(
                coreChannel,
                ch -> AddressServiceGrpc.newBlockingStub(ch),
                stub -> stub.create(AddressCreateRequest.newBuilder()
                        .setContactName(body.contactName())
                        .setContactPhone(body.contactPhone())
                        .setAddressLine1(body.addressLine1())
                        .setAddressLine2(nz(body.addressLine2()))
                        .setDistrict(body.district())
                        .setCity(body.city())
                        .setCountry(nz(body.country()))
                        .setPostalCode(nz(body.postalCode()))
                        .build())
        );
    }

    @PatchMapping(value = "/{id}",
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> update(
            @PathVariable String id,
            @RequestBody AddressUpdateRequestBody body){
        return GrpcHelper.callGrpcVoid(
                coreChannel,
                AddressServiceGrpc::newBlockingStub,
                stub -> stub.update(AddressUpdateRequest.newBuilder()
                        .setId(id)
                        .setContactName(nz(body.contactName()))
                        .setContactPhone(nz(body.contactPhone()))
                        .setAddressLine1(nz(body.addressLine1()))
                        .setAddressLine2(nz(body.addressLine2()))
                        .setDistrict(nz(body.district()))
                        .setCity(nz(body.city()))
                        .setCountry(nz(body.country()))
                        .setPostalCode(nz(body.postalCode()))
                        .build())
        );
    }

    @DeleteMapping(value = "/{id}",
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> softDelete(
            @PathVariable String id){
        return GrpcHelper.callGrpcVoid(
                coreChannel,
                AddressServiceGrpc::newBlockingStub,
                stub -> stub.softDelete(IdRequest.newBuilder()
                        .setId(id)
                        .build())
        );
    }

    @PostMapping(value = "/{id}/default-shipping",
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> setDefaultShipping(
            @PathVariable String id){
        return GrpcHelper.callGrpcVoid(
                coreChannel,
                AddressServiceGrpc::newBlockingStub,
                stub -> stub.setDefaultShipping(IdRequest.newBuilder().setId(id).build())
        );
    }

    @PostMapping(value = "/{id}/default-billing",
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> setDefaultBilling(@PathVariable String id){
        return GrpcHelper.callGrpcVoid(
                coreChannel,
                AddressServiceGrpc::newBlockingStub,
                stub -> stub.setDefaultBilling(IdRequest.newBuilder()
                        .setId(id)
                        .build())
        );
    }

    @GetMapping(value = "/user/{userId}",
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Envelope.Page<AddressResponseView>>>> listByUser(
            @PathVariable String userId,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size){
        return GrpcHelper.callGrpc(
                coreChannel,
                AddressServiceGrpc::newBlockingStub,
                stub -> stub.listByUser(UserIdRequest.newBuilder()
                        .setUserId(userId)
                        .setPage(page)
                        .setSize(size)
                        .build()),
                p -> Envelope.Page.<AddressResponseView>builder()
                        .page(p.getPage())
                        .size(p.getSize())
                        .total(p.getTotal())
                        .totalPages(p.getTotalPages())
                        .docs(p.getDocsList().stream().map(d -> new AddressResponseView(
                                d.getId(), d.getContactName(), d.getContactPhone(),
                                d.getAddressLine1(), z(d.getAddressLine2()),
                                d.getDistrict(), d.getCity(), z(d.getCountry()),
                                z(d.getPostalCode()),
                                d.getIsDefaultShipping(), d.getIsDefaultBilling()
                        )).toList())
                        .build()
        );
    }
}

package com.gatewayserver.controller;

import com.common.grpc.AuthServiceGrpc;
import com.common.grpc.IntrospectRequest;
import com.common.grpc.LoginRequest;
import com.common.grpc.LogoutRequest;
import com.common.grpc.RefreshRequest;
import com.common.grpc.RegisterRequest;
import com.gatewayserver.dto.request.authentication.IntrospectRequestBody;
import com.gatewayserver.dto.request.authentication.LoginRequestBody;
import com.gatewayserver.dto.request.authentication.LogoutRequestBody;
import com.gatewayserver.dto.request.authentication.RefreshRequestBody;
import com.gatewayserver.dto.request.authentication.RegisterRequestBody;
import com.gatewayserver.dto.response.authentication.IntrospectView;
import com.gatewayserver.dto.response.authentication.LoginView;
import com.gatewayserver.dto.response.authentication.RefreshView;
import com.gatewayserver.helper.GrpcHelper;
import lombok.RequiredArgsConstructor;
import net.devh.boot.grpc.client.inject.GrpcClient;
import org.common.http.Envelope;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("/auth")
@RequiredArgsConstructor
public class AuthController {


    @GrpcClient("core")
    private AuthServiceGrpc.AuthServiceBlockingStub auth;

    @PostMapping(
            value = "/register",
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> register(
            @RequestBody RegisterRequestBody body) {
        return GrpcHelper.callGrpcVoid(
                () -> auth.register(RegisterRequest.newBuilder()
                        .setUsername(body.username())
                        .setEmail(body.email())
                        .setPassword(body.password())
                        .build()));
    }

    @PostMapping(
            value = "/login",
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<LoginView>>> login(
            @RequestBody LoginRequestBody body) {
        return GrpcHelper.callGrpc(() -> auth.login(LoginRequest.newBuilder()
                        .setUsername(body.username())
                        .setEmail(body.email())
                        .setPassword(body.password())
                        .build()),
                response -> new LoginView(
                        response.getAccessToken(),
                        response.getRefreshToken(),
                        response.getAccessExpiry(),
                        response.getRefreshExpiry()
                )
        );
    }

    @PostMapping(
            value = "/refresh",
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<RefreshView>>> refresh(
            @RequestBody RefreshRequestBody body) {
        return GrpcHelper.callGrpc(
                () -> auth.refresh(
                        RefreshRequest.newBuilder().setToken(body.token())
                                .build()),
                resp -> new RefreshView(
                        resp.getAccessToken(),
                        resp.getRefreshToken(),
                        resp.getAccessExpiry(),
                        resp.getRefreshExpiry()
                )
        );
    }

    @PostMapping(
            value = "/introspect",
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<IntrospectView>>> introspect(
            @RequestBody IntrospectRequestBody body) {
        return GrpcHelper.callGrpc(
                () -> auth.introspect(
                        IntrospectRequest.newBuilder().setToken(body.token())
                                .build()),
                resp -> new IntrospectView(resp.getValid(), resp.getUserId())
        );
    }

    @PostMapping(
            value = "/logout",
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> logout(
            @RequestBody LogoutRequestBody body) {
        return GrpcHelper.callGrpcVoid(
                () -> auth.logout(LogoutRequest.newBuilder()
                        .setToken(body.token())
                        .build()));
    }
}

package com.gatewayserver.controller;

import com.common.grpc.BrandCreateRequest;
import com.common.grpc.BrandListRequest;
import com.common.grpc.BrandServiceGrpc;
import com.common.grpc.BrandUpdateRequest;
import com.common.grpc.IdRequest;
import com.common.grpc.SlugRequest;
import com.gatewayserver.dto.request.brand.BrandCreateRequestBody;
import com.gatewayserver.dto.request.brand.BrandUpdateRequestBody;
import com.gatewayserver.dto.response.brand.BrandView;
import com.gatewayserver.helper.GrpcHelper;
import io.grpc.Channel;
import lombok.RequiredArgsConstructor;
import net.devh.boot.grpc.client.inject.GrpcClient;
import org.common.http.Envelope;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("/business/brands")
@RequiredArgsConstructor
public class BrandController {

    @GrpcClient("business")
    private Channel businessChannel;

    @PostMapping(
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> create(
            @RequestBody BrandCreateRequestBody body){
        return GrpcHelper.callGrpcVoid(
                businessChannel,
                BrandServiceGrpc::newBlockingStub,
                stub -> stub.create(BrandCreateRequest.newBuilder()
                        .setName(body.name())
                        .setSlug(body.slug())
                        .setDescription(body.description()==null?"":body.description())
                        .build()));
    }

    @PatchMapping(
        value ="/{id}",
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> update(
            @PathVariable String id,
            @RequestBody BrandUpdateRequestBody body){
        return GrpcHelper.callGrpcVoid(
                businessChannel,
                BrandServiceGrpc::newBlockingStub,
                stub -> stub.update(BrandUpdateRequest.newBuilder()
                        .setId(id)
                        .setName(body.name()==null?"":body.name())
                        .setSlug(body.slug()==null?"":body.slug())
                        .setDescription(body.description() == null
                                ? ""
                                : body.description())
                        .build()));
    }

    @DeleteMapping(
        value = "/{id}",
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> softDelete(
            @PathVariable String id){
        return GrpcHelper.callGrpcVoid(
                businessChannel, BrandServiceGrpc::newBlockingStub,
                stub -> stub.softDelete(IdRequest.newBuilder()
                        .setId(id)
                        .build()));
    }

    @PostMapping(
        value = "/{id}/restore",
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> restore(
            @PathVariable String id){
        return GrpcHelper.callGrpcVoid(
                businessChannel, BrandServiceGrpc::newBlockingStub,
                stub -> stub.restore(IdRequest.newBuilder()
                        .setId(id)
                        .build()));
    }

    @GetMapping(
        value = "/{id}",
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<BrandView>>> getById(
            @PathVariable String id){
        return GrpcHelper.callGrpc(
                businessChannel, BrandServiceGrpc::newBlockingStub,
                stub -> stub.getById(IdRequest.newBuilder()
                        .setId(id)
                        .build()),
                r -> new BrandView(
                        r.getId(),
                        r.getName(),
                        r.getSlug(),
                        r.getDescription().isBlank()
                                ? null
                                : r.getDescription()));
    }

    @GetMapping(
        value = "/slug/{slug}",
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<BrandView>>> getBySlug(
            @PathVariable String slug){
        return GrpcHelper.callGrpc(
                businessChannel, BrandServiceGrpc::newBlockingStub,
                stub -> stub.getBySlug(SlugRequest.newBuilder()
                        .setSlug(slug)
                        .build()),
                r -> new BrandView(
                        r.getId(),
                        r.getName(),
                        r.getSlug(),
                        r.getDescription().isBlank()
                                ? null
                                : r.getDescription()));
    }

    @GetMapping(
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Envelope.Page<BrandView>>>> list(
            @RequestParam(required = false) String q,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size){
        return GrpcHelper.callGrpc(
                businessChannel, BrandServiceGrpc::newBlockingStub,
                stub -> stub.list(BrandListRequest.newBuilder()
                        .setQ(q == null ? "" : q)
                        .setPage(page)
                        .setSize(size)
                        .build()),
                p -> Envelope.Page.<BrandView>builder()
                        .page(p.getPage())
                        .size(p.getSize())
                        .total(p.getTotal())
                        .totalPages(p.getTotalPages())
                        .docs(p.getDocsList()
                                .stream()
                                .map(d -> new BrandView(
                                        d.getId(),
                                        d.getName(),
                                        d.getSlug(),
                                        d.getDescription().isBlank()
                                                ? null
                                                : d.getDescription()))
                                .toList())
                        .build());
    }
}

package com.gatewayserver.controller;

import com.common.grpc.CategoryCreateRequest;
import com.common.grpc.CategoryListRequest;
import com.common.grpc.CategoryReparentRequest;
import com.common.grpc.CategoryServiceGrpc;
import com.common.grpc.CategoryUpdateRequest;
import com.common.grpc.IdRequest;
import com.common.grpc.SlugRequest;
import com.gatewayserver.dto.request.category.CategoryCreateRequestBody;
import com.gatewayserver.dto.request.category.CategoryReparentRequestBody;
import com.gatewayserver.dto.request.category.CategoryUpdateRequestBody;
import com.gatewayserver.dto.response.category.CategoryView;
import com.gatewayserver.helper.GrpcHelper;
import io.grpc.Channel;
import lombok.RequiredArgsConstructor;
import net.devh.boot.grpc.client.inject.GrpcClient;
import org.common.http.Envelope;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("/business/categories")
@RequiredArgsConstructor
public class CategoryController {

    @GrpcClient("business")
    private Channel businessChannel;

    @PostMapping(
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> create(
            @RequestBody CategoryCreateRequestBody body){
        return GrpcHelper.callGrpcVoid(
                businessChannel, CategoryServiceGrpc::newBlockingStub,
                stub -> stub.create(CategoryCreateRequest.newBuilder()
                        .setName(body.name())
                        .setSlug(body.slug())
                        .setDescription(body.description() == null
                                ? ""
                                : body.description())
                        .setParentId(body.parentId() == null
                                ? ""
                                : body.parentId())
                        .build()));
    }

    @PatchMapping(
        value = "/{id}",
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> update(
        @PathVariable String id,
        @RequestBody CategoryUpdateRequestBody body){
        return GrpcHelper.callGrpcVoid(
                businessChannel, CategoryServiceGrpc::newBlockingStub,
                stub -> stub.update(CategoryUpdateRequest.newBuilder()
                        .setId(id)
                        .setName(body.name() == null
                            ? ""
                            : body.name())
                        .setSlug(body.slug() == null
                            ? ""
                            : body.slug())
                        .setDescription(body.description() == null
                            ? ""
                            : body.description())
                        .build()));
    }

    @PostMapping(
        value = "/{id}/reparent",
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> reparent(
        @PathVariable String id,
        @RequestBody CategoryReparentRequestBody body){
        return GrpcHelper.callGrpcVoid(
                businessChannel, CategoryServiceGrpc::newBlockingStub,
                stub -> stub.reparent(CategoryReparentRequest.newBuilder()
                        .setId(id)
                        .setNewParentId(body.newParentId() == null
                            ? ""
                            : body.newParentId())
                        .build()));
    }

    @DeleteMapping(
        value = "/{id}",
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> softDelete(
        @PathVariable String id){
        return GrpcHelper.callGrpcVoid(
                businessChannel, CategoryServiceGrpc::newBlockingStub,
                stub -> stub.softDelete(IdRequest.newBuilder()
                    .setId(id)
                    .build()));
    }

    @PostMapping(
        value = "/{id}/restore",
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> restore(
        @PathVariable String id){
        return GrpcHelper.callGrpcVoid(
                businessChannel, CategoryServiceGrpc::newBlockingStub,
                stub -> stub.restore(IdRequest.newBuilder()
                    .setId(id)
                    .build()));
    }

    @GetMapping(
        value = "/{id}",
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<CategoryView>>> getById(
        @PathVariable String id){
        return GrpcHelper.callGrpc(
                businessChannel, CategoryServiceGrpc::newBlockingStub,
                stub -> stub.getById(IdRequest.newBuilder()
                    .setId(id)
                    .build()),
                r -> new CategoryView(
                    r.getId(),
                    r.getName(),
                    r.getSlug(),
                    r.getDescription().isBlank()
                        ? null
                        : r.getDescription(),
                    r.getParentId().isBlank()
                        ? null
                        : r.getParentId()));
    }

    @GetMapping(
        value = "/slug/{slug}",
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<CategoryView>>> getBySlug(
        @PathVariable String slug){
        return GrpcHelper.callGrpc(
                businessChannel, CategoryServiceGrpc::newBlockingStub,
                stub -> stub.getBySlug(SlugRequest.newBuilder()
                    .setSlug(slug)
                    .build()),
                r -> new CategoryView(
                    r.getId(),
                    r.getName(),
                    r.getSlug(),
                    r.getDescription().isBlank()
                        ? null
                        : r.getDescription(),
                    r.getParentId().isBlank()
                        ? null
                        : r.getParentId()));
    }

    @GetMapping(
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Envelope.Page<CategoryView>>>> list(
            @RequestParam(required = false) String q,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size){
        return GrpcHelper.callGrpc(
                businessChannel, CategoryServiceGrpc::newBlockingStub,
                stub -> stub.list(CategoryListRequest.newBuilder()
                    .setQ(q == null ? "" : q)
                    .setPage(page)
                    .setSize(size)
                    .build()),
                p -> Envelope.Page.<CategoryView>builder()
                    .page(p.getPage())
                    .size(p.getSize())
                    .total(p.getTotal()).totalPages(p.getTotalPages())
                    .docs(p.getDocsList().stream()
                                .map(d -> new CategoryView(
                                    d.getId(),
                                    d.getName(),
                                    d.getSlug(),
                                    d.getDescription().isBlank()
                                        ? null
                                        : d.getDescription(),
                                        d.getParentId().isBlank()
                                            ? null
                                            : d.getParentId()))
                                .toList())
                        .build());
    }
}

package com.gatewayserver.controller;

import com.common.grpc.OtpServiceGrpc;
import com.common.grpc.OtpVerificationRequest;
import com.common.grpc.ResetPasswordRequest;
import com.common.grpc.UserOtpRequest;
import com.gatewayserver.dto.request.otp.OtpVerificationRequestBody;
import com.gatewayserver.dto.request.otp.ResetPasswordRequestBody;
import com.gatewayserver.dto.request.otp.UserOtpRequestBody;
import com.gatewayserver.dto.response.otp.OtpResponseView;
import com.gatewayserver.helper.GrpcHelper;
import lombok.RequiredArgsConstructor;
import net.devh.boot.grpc.client.inject.GrpcClient;
import org.common.http.Envelope;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("/auth")
@RequiredArgsConstructor
public class OtpController {

    @GrpcClient("core")
    private OtpServiceGrpc.OtpServiceBlockingStub stub;

    //OTP
    @PostMapping(
            value = "/otp",
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<OtpResponseView>>> sendOtp(
            @RequestBody UserOtpRequestBody body) {
        return GrpcHelper.callGrpc(() -> stub.sendOtp(UserOtpRequest.newBuilder()
                        .setEmail(body.email())
                        .build()),
                response -> new OtpResponseView(
                        response.getEmail(),
                        response.getMessage()
                )
        );
    }

    @PostMapping(
            value = "/otp/verify",
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> verifyOtp(
            @RequestBody OtpVerificationRequestBody body) {
        return GrpcHelper.callGrpcVoid(() -> stub.verifyOtp(
                OtpVerificationRequest.newBuilder()
                        .setEmail(body.email())
                        .setOtpCode(body.otpCode())
                        .build()));
    }

    //Password
    @PostMapping(
            value = "/password-reset",
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<OtpResponseView>>> requestResetPassword(
            @RequestBody UserOtpRequestBody body) {
        return GrpcHelper.callGrpc(() -> stub.requestResetPassword(
                        UserOtpRequest.newBuilder()
                                .setEmail(body.email()).build()),
                response -> new OtpResponseView(
                        response.getEmail(),
                        response.getMessage()
                )
        );
    }

    @PostMapping(
            value = "/password-reset/verify",
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> verifyOtpPassword(
            @RequestBody OtpVerificationRequestBody body) {
        return GrpcHelper.callGrpcVoid(() -> stub.verifyOtpPassword(
                OtpVerificationRequest.newBuilder()
                        .setEmail(body.email())
                        .setOtpCode(body.otpCode())
                        .build()));
    }

    @PostMapping(
            value = "/password-reset/reset",
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> resetPassword(
            @RequestBody ResetPasswordRequestBody body) {
        return GrpcHelper.callGrpcVoid(() -> stub.resetPassword(
                ResetPasswordRequest.newBuilder()
                        .setEmail(body.email())
                        .setOtp(body.otp())
                        .setNewPassword(body.newPassword())
                        .build()));
    }
}

package com.gatewayserver.controller;

import com.common.grpc.ArchiveRequest;
import com.common.grpc.AssignCategoryRequest;
import com.common.grpc.IdRequest;
import com.common.grpc.ProductCreateRequest;
import com.common.grpc.ProductListRequest;
import com.common.grpc.ProductServiceGrpc;
import com.common.grpc.ProductStatus;
import com.common.grpc.ProductUpdateRequest;
import com.common.grpc.PublishRequest;
import com.common.grpc.SlugRequest;
import com.common.grpc.UnassignCategoryRequest;
import com.common.grpc.UnpublishRequest;
import com.gatewayserver.dto.request.product.AssignCategoryRequestBody;
import com.gatewayserver.dto.request.product.ProductCreateRequestBody;
import com.gatewayserver.dto.request.product.ProductUpdateRequestBody;
import com.gatewayserver.dto.response.product.ProductView;
import com.gatewayserver.helper.GrpcHelper;
import io.grpc.Channel;
import lombok.RequiredArgsConstructor;
import net.devh.boot.grpc.client.inject.GrpcClient;
import org.common.http.Envelope;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("/business/products")
@RequiredArgsConstructor
public class ProductController {

    @GrpcClient("business")
    private Channel businessChannel;

    private static String nz(String s){return s == null ? "" : s;}
    private static String z(String s){return (s == null || s.isBlank()) ? null : s;}

    @PostMapping(
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> create(
        @RequestBody ProductCreateRequestBody body){
        return GrpcHelper.callGrpcVoid(
                businessChannel, ProductServiceGrpc::newBlockingStub,
                stub -> stub.create(ProductCreateRequest.newBuilder()
                    .setName(body.name())
                    .setSlug(body.slug())
                    .setDescription(nz(body.description()))
                    .setBrandId(nz(body.brandId()))
                    .build()));
    }

    @PatchMapping(
        value="/{id}",
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ResponseEntity<Envelope<Void>>> update(
        @PathVariable String id,
        @RequestBody ProductUpdateRequestBody body){
        return GrpcHelper.callGrpcVoid(
                businessChannel, ProductServiceGrpc::newBlockingStub,
                stub -> stub.update(ProductUpdateRequest.newBuilder()
                        .setId(id)
                        .setName(nz(body.name()))
                        .setSlug(nz(body.slug()))
                        .setDescription(nz(body.description()))
                        .setBrandId(nz(body.brandId()))
                        .build()));
    }

    @DeleteMapping(
        value = "/{id}",
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> softDelete(
        @PathVariable String id){
        return GrpcHelper.callGrpcVoid(
                businessChannel, ProductServiceGrpc::newBlockingStub,
                stub -> stub.softDelete(IdRequest.newBuilder()
                    .setId(id)
                    .build()));
    }

    @PostMapping(
        value = "/{id}/restore",
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> restore(
        @PathVariable String id){
        return GrpcHelper.callGrpcVoid(
                businessChannel, ProductServiceGrpc::newBlockingStub,
                stub -> stub.restore(IdRequest.newBuilder()
                    .setId(id)
                    .build()));
    }

    @PostMapping(
        value = "/{id}/publish",
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> publish(
        @PathVariable String id){
        return GrpcHelper.callGrpcVoid(
                businessChannel, ProductServiceGrpc::newBlockingStub,
                stub -> stub.publish(PublishRequest.newBuilder()
                    .setId(id)
                    .build()));
    }
    @PostMapping(
        value = "/{id}/unpublish",
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> unpublish(
        @PathVariable String id){
        return GrpcHelper.callGrpcVoid(
                businessChannel, ProductServiceGrpc::newBlockingStub,
                stub -> stub.unpublish(UnpublishRequest.newBuilder().setId(id)
                    .build()));
    }
    @PostMapping(
        value = "/{id}/archive",
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> archive(
        @PathVariable String id){
        return GrpcHelper.callGrpcVoid(
                businessChannel, ProductServiceGrpc::newBlockingStub,
                stub -> stub.archive(ArchiveRequest.newBuilder()
                    .setId(id)
                    .build()));
    }

    @GetMapping(
        value = "/{id}",
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<ProductView>>> getById(
        @PathVariable String id){
        return GrpcHelper.callGrpc(
                businessChannel, ProductServiceGrpc::newBlockingStub,
                stub -> stub.getById(IdRequest.newBuilder()
                    .setId(id)
                    .build()),
                r -> new ProductView(
                    r.getId(),
                    r.getName(),
                    r.getSlug(),
                    r.getDescription().isBlank()
                        ? null
                        : r.getDescription(),
                    r.getStatus().name(),
                    r.getBrandId().isBlank()
                        ? null
                        : r.getBrandId()));
    }

    @GetMapping(
        value = "/slug/{slug}",
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<ProductView>>> getBySlug(
        @PathVariable String slug){
        return GrpcHelper.callGrpc(
                businessChannel, ProductServiceGrpc::newBlockingStub,
                stub -> stub.getBySlug(SlugRequest.newBuilder()
                    .setSlug(slug)
                    .build()),
                r -> new ProductView(
                    r.getId(),
                    r.getName(),
                    r.getSlug(),
                    r.getDescription().isBlank()
                        ? null
                        : r.getDescription(),
                    r.getStatus().name(),
                    r.getBrandId().isBlank()
                        ? null
                        : r.getBrandId()));
    }

    @GetMapping(
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Envelope.Page<ProductView>>>> list(
            @RequestParam(required = false) String q,
            @RequestParam(required = false) String brandId,
            @RequestParam(required = false) String categoryId,
            @RequestParam(required = false) String status,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size){
        return GrpcHelper.callGrpc(
                businessChannel, ProductServiceGrpc::newBlockingStub,
                stub -> {
                    ProductListRequest.Builder b = ProductListRequest.newBuilder()
                            .setQ(nz(q))
                            .setBrandId(nz(brandId))
                            .setCategoryId(nz(categoryId))
                            .setPage(page).setSize(size);
                    if (status!=null && !status.isBlank()) {
                        b.setStatus(ProductStatus.valueOf(status));
                    }
                    return stub.list(b.build());
                },
                p -> Envelope.Page.<ProductView>builder()
                    .page(p.getPage())
                    .size(p.getSize())
                    .total(p.getTotal())
                    .totalPages(p.getTotalPages())
                    .docs(p.getDocsList().stream()
                                .map(d -> new ProductView(
                                        d.getId(), d.getName(), d.getSlug(),
                                        d.getDescription().isBlank()?null:d.getDescription(),
                                        d.getStatus().name(),
                                        d.getBrandId().isBlank()?null:d.getBrandId()))
                                .toList())
                        .build());
    }

    @PostMapping(
        value = "/assign-category",
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> assignCategory(
        @RequestBody AssignCategoryRequestBody body){
        return GrpcHelper.callGrpcVoid(
                businessChannel, ProductServiceGrpc::newBlockingStub,
                stub -> stub.assignCategory(AssignCategoryRequest.newBuilder()
                        .setProductId(body.productId())
                        .setCategoryId(body.categoryId())
                        .build()));
    }

    @PostMapping(
        value = "/unassign-category",
        consumes = MediaType.APPLICATION_JSON_VALUE,
        produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> unassignCategory(
        @RequestBody AssignCategoryRequestBody body){
        return GrpcHelper.callGrpcVoid(
                businessChannel, ProductServiceGrpc::newBlockingStub,
                stub -> stub.unassignCategory(UnassignCategoryRequest.newBuilder()
                        .setProductId(body.productId())
                        .setCategoryId(body.categoryId())
                        .build()));
    }
}

package com.gatewayserver.controller;

import com.common.grpc.AssignRoleRequest;
import com.common.grpc.CreateRoleRequest;
import com.common.grpc.PageRequest;
import com.common.grpc.RoleName;
import com.common.grpc.RoleServiceGrpc;
import com.gatewayserver.dto.request.user.AssignRoleRequestBody;
import com.gatewayserver.dto.request.user.CreateRoleRequestBody;
import com.gatewayserver.dto.response.user.RoleResponseView;
import com.gatewayserver.helper.GrpcHelper;
import io.grpc.Channel;
import lombok.RequiredArgsConstructor;
import net.devh.boot.grpc.client.inject.GrpcClient;
import org.common.http.Envelope;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("/roles")
@RequiredArgsConstructor
public class RoleController {

    @GrpcClient("core")
    private Channel coreChannel;

    @PostMapping
    public Mono<ResponseEntity<Envelope<Void>>> create(
            @RequestBody CreateRoleRequestBody body){
        return GrpcHelper.callGrpcVoid(
                coreChannel,
                RoleServiceGrpc::newBlockingStub,
                stub -> stub.create(CreateRoleRequest.newBuilder()
                        .setName(body.name())
                        .build()));
    }

    @DeleteMapping("/{name}")
    public Mono<ResponseEntity<Envelope<Void>>> softDelete(
            @PathVariable String name){
        return GrpcHelper.callGrpcVoid(
                coreChannel,
                RoleServiceGrpc::newBlockingStub,
                stub -> stub.softDelete(RoleName.newBuilder()
                        .setName(name)
                        .build()));
    }

    @PostMapping("/{name}/restore")
    public Mono<ResponseEntity<Envelope<Void>>> restore(
            @PathVariable String name){
        return GrpcHelper.callGrpcVoid(
                coreChannel,
                RoleServiceGrpc::newBlockingStub,
                stub -> stub.restore(RoleName.newBuilder()
                        .setName(name)
                        .build()));
    }

    @PostMapping("/assign")
    public Mono<ResponseEntity<Envelope<Void>>> assign(
            @RequestBody AssignRoleRequestBody body){
        return GrpcHelper.callGrpcVoid(
                coreChannel,
                RoleServiceGrpc::newBlockingStub,
                stub -> stub.assign(AssignRoleRequest.newBuilder()
                        .setUserId(body.userId())
                        .setRoleName(body.roleName())
                        .build()));
    }

    @PostMapping("/remove")
    public Mono<ResponseEntity<Envelope<Void>>> remove(
            @RequestBody AssignRoleRequestBody body){
        return GrpcHelper.callGrpcVoid(
                coreChannel,
                RoleServiceGrpc::newBlockingStub,
                stub -> stub.remove(AssignRoleRequest.newBuilder()
                        .setUserId(body.userId())
                        .setRoleName(body.roleName())
                        .build()));
    }

    @GetMapping("/user/{userId}")
    public Mono<ResponseEntity<Envelope<Envelope.Page<RoleResponseView>>>> listUserRoles(
            @PathVariable String userId){
        return GrpcHelper.callGrpc(
                coreChannel,
                RoleServiceGrpc::newBlockingStub,
                stub -> stub.listUserRoles(AssignRoleRequest.newBuilder()
                        .setUserId(userId)
                        .build()),
                p -> Envelope.Page.<RoleResponseView>builder()
                        .page(p.getPage())
                        .size(p.getSize())
                        .total(p.getTotal())
                        .totalPages(p.getTotalPages())
                        .docs(p.getDocsList().stream()
                                .map(d -> new RoleResponseView(d.getName()))
                                .toList())
                        .build());
    }

    @GetMapping
    public Mono<ResponseEntity<Envelope<Envelope.Page<RoleResponseView>>>> listAll(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size){
        return GrpcHelper.callGrpc(
                coreChannel,
                RoleServiceGrpc::newBlockingStub,
                stub -> stub.listAll(PageRequest.newBuilder()
                        .setPage(page)
                        .setSize(size)
                        .build()),
                p -> Envelope.Page.<RoleResponseView>builder()
                        .page(p.getPage())
                        .size(p.getSize())
                        .total(p.getTotal())
                        .totalPages(p.getTotalPages())
                        .docs(p.getDocsList().stream()
                                .map(d -> new RoleResponseView(d.getName()))
                                .toList())
                        .build());
    }
}

package com.gatewayserver.controller;

import com.common.grpc.ToggleActiveRequest;
import com.common.grpc.UpdateProfileRequest;
import com.common.grpc.UserServiceGrpc;
import com.gatewayserver.dto.request.user.UpdateProfileRequestBody;
import com.gatewayserver.dto.response.user.MeResponseView;
import com.gatewayserver.helper.GrpcHelper;
import com.google.protobuf.Empty;
import io.grpc.Channel;
import lombok.RequiredArgsConstructor;
import net.devh.boot.grpc.client.inject.GrpcClient;
import org.common.http.Envelope;
import org.springdoc.core.service.GenericResponseService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("/users")
@RequiredArgsConstructor
public class UserController {
    @GrpcClient("core")
    private Channel coreChannel;

    @PostMapping("/toggle-active")
    public Mono<ResponseEntity<Envelope<Void>>> toggleActive(
            @RequestParam String userId,
            @RequestParam boolean active){
        return GrpcHelper.callGrpcVoid(
                coreChannel,
                UserServiceGrpc::newBlockingStub,
                stub -> stub.toggleActive(ToggleActiveRequest.newBuilder()
                        .setUserId(userId)
                        .setActive(active)
                        .build()));
    }

    @GetMapping("/me")
    public Mono<ResponseEntity<Envelope<MeResponseView>>> me(){
        return GrpcHelper.callGrpc(
                coreChannel,
                UserServiceGrpc::newBlockingStub,
                stub -> stub.getMe(Empty.getDefaultInstance()),
                resp -> new MeResponseView(
                        resp.getId(),
                        resp.getUsername(),
                        resp.getEmail(),
                        resp.getFullName().isBlank() ? null : resp.getFullName(),
                        resp.getPhoneNumber().isBlank() ? null : resp.getPhoneNumber(),
                        resp.getIsActive(),
                        resp.getIsVerified()
                )
        );
    }

    @PatchMapping("/me")
    public Mono<ResponseEntity<Envelope<Void>>> update(
            @RequestBody UpdateProfileRequestBody body){
        String fullName = body.fullName() == null ? "" : body.fullName();
        String phone = body.phoneNumber() == null ? "" : body.phoneNumber();

        return GrpcHelper.callGrpcVoid(
                coreChannel,
                UserServiceGrpc::newBlockingStub,
                stub -> stub.updateProfile(UpdateProfileRequest.newBuilder()
                        .setFullName(fullName)
                        .setPhoneNumber(phone)
                        .build()));
    }
}

package com.gatewayserver.dto.request.authentication;

public record IntrospectRequestBody(String token) {
}

package com.gatewayserver.dto.request.authentication;

public record LoginRequestBody(
        String username,
        String email,
        String password) {
}

package com.gatewayserver.dto.request.authentication;

public record LogoutRequestBody(String token) {
}
package com.gatewayserver.dto.request.authentication;

public record RefreshRequestBody(String token) {
}
package com.gatewayserver.dto.request.authentication;

public record RegisterRequestBody(
        String username,
        String email,
        String password) {
}

package com.gatewayserver.dto.request.brand;

public record BrandCreateRequestBody(
        String name,
        String slug,
        String description) {}


package com.gatewayserver.dto.request.brand;

public record BrandUpdateRequestBody(
        String name,
        String slug,
        String description) {}


package com.gatewayserver.dto.request.category;

public record CategoryCreateRequestBody(
        String name,
        String slug,
        String description,
        String parentId) {}

package com.gatewayserver.dto.request.category;

public record CategoryReparentRequestBody(
        String newParentId) {}

 package com.gatewayserver.dto.request.category;

 public record CategoryUpdateRequestBody(
         String name,
         String slug,
         String description) {}

 package com.gatewayserver.dto.request.otp;

 public record OtpVerificationRequestBody(
         String email,
         String otpCode) {
 }

 package com.gatewayserver.dto.request.otp;

 public record ResetPasswordRequestBody(
         String email,
         String otp,
         String newPassword) {
 }

package com.gatewayserver.dto.request.otp;

public record UserOtpRequestBody(String email) {
}

package com.gatewayserver.dto.request.product;
public record AssignCategoryRequestBody(
        String productId,
        String categoryId) {}

package com.gatewayserver.dto.request.product;

public record ProductCreateRequestBody(
        String name,
        String slug,
        String description,
        String brandId) {}
package com.gatewayserver.dto.request.product;

public record ProductUpdateRequestBody(
        String name,
        String slug,
        String description,
        String brandId) {}

package com.gatewayserver.dto.request.user;


public record AddressCreateRequestBody (
    String contactName,
    String contactPhone,
    String addressLine1,
    String addressLine2,
    String district,
    String city,
    String country,
    String postalCode)
{}

package com.gatewayserver.dto.request.user;

public record AddressUpdateRequestBody (
    String contactName,
    String contactPhone,
    String addressLine1,
    String addressLine2,
    String district,
    String city,
    String country,
    String postalCode){
}
package com.gatewayserver.dto.request.user;

public record AssignRoleRequestBody (
    String userId,
    String roleName){
}
package com.gatewayserver.dto.request.user;

public record CreateRoleRequestBody (
    String name){
}
package com.gatewayserver.dto.request.user;

public record UpdateProfileRequestBody (
    String fullName,
    String phoneNumber){
}

package com.gatewayserver.dto.response.authentication;

public record IntrospectView(
        boolean valid,
        String userId) {
}

package com.gatewayserver.dto.response.authentication;

public record LoginView(
        String accessToken,
        String refreshToken,
        String accessExpiry,
        String refreshExpiry) {
}
package com.gatewayserver.dto.response.authentication;

public record RefreshView(
        String accessToken,
        String refreshToken,
        String accessExpiry,
        String refreshExpiry) {
}
package com.gatewayserver.dto.response.brand;

public record BrandView(
        String id,
        String name,
        String slug,
        String description) {}

package com.gatewayserver.dto.response.category;

public record CategoryView(
        String id,
        String name,
        String slug,
        String description,
        String parentId) {}

package com.gatewayserver.dto.response.otp;

public record OtpResponseView(
        String email,
        String message
) {
}

package com.gatewayserver.dto.response.product;

public record ProductView(
        String id,
        String name,
        String slug,
        String description,
        String status,
        String brandId) {}

package com.gatewayserver.dto.response.user;


public record AddressResponseView (
    String id,
    String contactName,
    String contactPhone,
    String addressLine1,
    String addressLine2,
    String district,
    String city,
    String country,
    String postalCode,
    Boolean isDefaultShipping,
    Boolean isDefaultBilling){
}

package com.gatewayserver.dto.response.user;


public record MeResponseView (
    String id,
    String username,
    String email,
    String fullName,
    String phoneNumber,
    Boolean isActive,
    Boolean isVerified){
}

package com.gatewayserver.dto.response.user;

public record RoleResponseView (
    String name){
}

package com.gatewayserver.exception;

import io.grpc.StatusRuntimeException;
import org.common.http.Envelope;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
public class GlobalErrorHandler {

    @ExceptionHandler(StatusRuntimeException.class)
    public ResponseEntity<Envelope<Void>> handleGrpcException(
            StatusRuntimeException statusRuntimeException){
        Envelope<Void> envelope = GrpcErrorMapper.toEnvelope(statusRuntimeException);
        return ResponseEntity.status(envelope.getStatus())
                .body(envelope);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Envelope<Void>> handleAnyException(
            Exception exception){
        Envelope<Void> envelope = Envelope.err(
                500,
                "UNCATEGORIZED_EXCEPTION",
                exception.getMessage(),
                null
        );
        return ResponseEntity.status(500)
                .body(envelope);
    }
}

package com.gatewayserver.exception;

import io.grpc.Status;
import io.grpc.StatusRuntimeException;
import lombok.NoArgsConstructor;
import org.common.exception.ErrorCode;
import org.common.http.Envelope;

import java.util.EnumMap;
import java.util.Map;
import java.util.Optional;

@NoArgsConstructor
public final class GrpcErrorMapper {
    private static final Map<Status.Code, ErrorCode> FALLBACK_BY_GRPC =
            new EnumMap<>(Status.Code.class);
    static {
        FALLBACK_BY_GRPC.put(Status.Code.UNAUTHENTICATED, ErrorCode.UNAUTHENTICATED);
        FALLBACK_BY_GRPC.put(Status.Code.PERMISSION_DENIED, ErrorCode.UNAUTHORIZED);
        FALLBACK_BY_GRPC.put(Status.Code.NOT_FOUND, ErrorCode.USER_NOT_FOUND);
        FALLBACK_BY_GRPC.put(Status.Code.ALREADY_EXISTS, ErrorCode.USER_ALREADY_EXISTS);
        FALLBACK_BY_GRPC.put(Status.Code.INVALID_ARGUMENT, ErrorCode.FAILED_VALIDATE_TOKEN);
        FALLBACK_BY_GRPC.put(Status.Code.FAILED_PRECONDITION, ErrorCode.FAILED_VALIDATE_TOKEN);
    }

    private static Optional<ErrorCode> fromName(
            String name){
        if (name == null || name.isBlank()) {
            return Optional.empty();
        }
        try {
            return Optional.of(ErrorCode.valueOf(name));
        } catch (IllegalArgumentException ex) {
            return Optional.empty();
        }
    }

    public static <T> Envelope<T> toEnvelope(
            StatusRuntimeException exception){
        String description = exception.getStatus().getDescription();
        Status.Code grpc = exception.getStatus().getCode();

        ErrorCode errorCode = fromName(description)
                .orElse(FALLBACK_BY_GRPC.getOrDefault(grpc, ErrorCode.UNCATEGORIZED_EXCEPTION));

        return Envelope.err(
                errorCode.http(),
                errorCode.name(),
                errorCode.getMessage(),
                null
        );
    }
}

package com.gatewayserver.helper;

import com.gatewayserver.configuration.grpc.ClientBearerInterceptor;
import com.gatewayserver.configuration.helper.ReactiveTokenHelper;
import com.gatewayserver.exception.GrpcErrorMapper;
import io.grpc.Channel;
import io.grpc.StatusRuntimeException;
import lombok.experimental.UtilityClass;
import org.common.http.Envelope;
import org.springframework.http.ResponseEntity;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

import java.util.function.Function;
import java.util.function.Supplier;

@UtilityClass
public class GrpcHelper {

    // ===== Helper chung cho tất cả endpoint =====
    public <R, V> Mono<ResponseEntity<Envelope<V>>> callGrpc(
            Supplier<R> supplier,
            Function<R, V> mapper) {
        return Mono.fromCallable(supplier::get)
                .map(mapper)
                .map(Envelope::ok)
                .map(ResponseEntity::ok)
                .onErrorResume(StatusRuntimeException.class, ex ->
                        Mono.just(GrpcErrorMapper.<V>toEnvelope(ex))
                                .map(env -> ResponseEntity
                                        .status(env.getStatus())
                                        .body(env)))
                .subscribeOn(Schedulers.boundedElastic());
    }

    public Mono<ResponseEntity<Envelope<Void>>> callGrpcVoid(
            Runnable runnable) {
        return Mono.fromRunnable(runnable)
                .thenReturn(Envelope.<Void>ok(null))
                .map(ResponseEntity::ok)
                .onErrorResume(io.grpc.StatusRuntimeException.class, ex ->
                        Mono.just(GrpcErrorMapper.<Void>toEnvelope(ex))
                                .map(env -> ResponseEntity
                                        .status(env.getStatus())
                                        .body(env)))
                .subscribeOn(Schedulers.boundedElastic());
    }

    /**
     * Tạo STUB theo từng request + gắn Bearer token vào Metadata
     * @param channel   Channel đã @GrpcClient(...)
     * @param stubMaker Hàm nhận Channel => trả về Stub (BlockingStub)
     * @param caller    Gọi gRPC bằng stub đã gắn token
     * @param mapper    Map response ra view
     */
    public <StubT, RespT, ViewT> Mono<ResponseEntity<Envelope<ViewT>>> callGrpc(
            Channel channel,
            Function<Channel, StubT> stubMaker,
            Function<StubT, RespT> caller,
            Function<RespT, ViewT> mapper
    ) {
        return ReactiveTokenHelper.currentBearerToken()
                .switchIfEmpty(Mono.error(new RuntimeException("UNAUTHENTICATED")))
                .flatMap(token -> Mono.fromCallable(() -> {
                                    Channel authed = ClientBearerInterceptor.withToken(channel, token);
                                    StubT stub = stubMaker.apply(authed);
                                    return caller.apply(stub);
                                })
                                .map(mapper)
                                .map(Envelope::ok)
                                .map(ResponseEntity::ok)
                                .onErrorResume(io.grpc.StatusRuntimeException.class, ex ->
                                        Mono.just(com.gatewayserver.exception.GrpcErrorMapper.<ViewT>toEnvelope(ex))
                                                .map(env -> ResponseEntity.status(env.getStatus()).body(env)))
                                .subscribeOn(Schedulers.boundedElastic())
                );
    }

    public <StubT> Mono<ResponseEntity<Envelope<Void>>> callGrpcVoid(
            Channel channel,
            Function<Channel, StubT> stubMaker,
            java.util.function.Consumer<StubT> caller
    ) {
        return ReactiveTokenHelper.currentBearerToken()
                .switchIfEmpty(Mono.error(new RuntimeException("UNAUTHENTICATED")))
                .flatMap(token -> Mono.fromRunnable(() -> {
                                    Channel authed = ClientBearerInterceptor.withToken(channel, token);
                                    StubT stub = stubMaker.apply(authed);
                                    caller.accept(stub);
                                })
                                .thenReturn(Envelope.<Void>ok(null))
                                .map(ResponseEntity::ok)
                                .onErrorResume(io.grpc.StatusRuntimeException.class, ex ->
                                        Mono.just(com.gatewayserver.exception.GrpcErrorMapper.<Void>toEnvelope(ex))
                                                .map(env -> ResponseEntity.status(env.getStatus()).body(env)))
                                .subscribeOn(Schedulers.boundedElastic())
                );
    }
}

server:
  port: 8092

spring:
  application:
    name: "gatewayserver"
  config:
    import: "optional:configserver:http://localhost:8091/"
  cloud:
    gateway:
      server:
        webflux:
          discovery:
            locator:
              enabled: true
              lower-case-service-id: true
          httpclient:
            connect-timeout: 1000
            response-timeout: 10s
          default-filters: []
          filter:
            json-to-grpc:
              enabled:
                false

eureka:
  instance:
    preferIpAddress: true
  client:
    registerWithEureka: true
    fetchRegistry: true
    serviceUrl:
      defaultZone: "http://localhost:8090/eureka/"

  main:
    web-application-type: reactive
  data:
    redis:
      connect-timeout: 2s
      host: localhost
      port: 6379
      timeout: 1s

grpc:
  client:
    core:
      address: 'static://localhost:50051'
      enableKeepAlive: true
      keepAliveWithoutCalls: true
      negotiationType: plaintext
    business:
      address: 'static://localhost:50052'
      negotiationType: PLAINTEXT

management:
  endpoints:
    web:
      exposure:
        include: "*"
  endpoint:
    gateway:
      access: unrestricted
  info:
    env:
      enabled: true

info:
  app:
    name: "gatewayserver"
    description: "Yunomi Xavia Gateway Server Application"
    version: "1.0.0"

logging:
  level:
    com:
      eazybytes:
        gatewayserver: DEBUG

resilience4j.circuitbreaker:
  configs:
    default:
      slidingWindowSize: 10
      permittedNumberOfCallsInHalfOpenState: 2
      failureRateThreshold: 50
      waitDurationInOpenState: 10000



common
package org.common.constant;

import lombok.NoArgsConstructor;
import org.springframework.http.HttpStatus;

@NoArgsConstructor
public final class ErrorCodeConstant {
    public static final String INTERNAL_SERVER_STATUS = HttpStatus.INTERNAL_SERVER_ERROR.toString();
    public static final String BAD_REQUEST_STATUS    = HttpStatus.BAD_REQUEST.toString();
    public static final String UNAUTHORIZED_STATUS   = HttpStatus.UNAUTHORIZED.toString();
    public static final String FORBIDDEN_STATUS      = HttpStatus.FORBIDDEN.toString();
    public static final String NOT_FOUND_STATUS      = HttpStatus.NOT_FOUND.toString();
    public static final String CONFLICT_STATUS       = HttpStatus.CONFLICT.toString();
}

package org.common.constant;

public final class SecurityConstants {
    // Headers
    public static final String AUTHORIZATION_HEADER = "Authorization";
    public static final String CONTENT_TYPE_HEADER  = "Content-Type";
    public static final String ACCEPT_HEADER        = "Accept";

    // CORS mặc định
    public static final String FRONTEND_ENDPOINT = "http://localhost:4200";

    // Public endpoints chuẩn
    public static final String[] PUBLIC_ENDPOINTS = {
            "/health", "/actuator/**", "/auth/**", "/h2-console/**"
    };

    // Methods
    public static final String GET="GET", POST="POST", PUT="PUT", DELETE="DELETE", PATCH="PATCH", OPTIONS="OPTIONS";

    // Path
    public static final String URL_PATTERN_ALL = "/**";

    private SecurityConstants(){}
}

package org.common.exception;


import lombok.Getter;

@Getter
public class AppException extends RuntimeException {
    private final ErrorCode errorCode;
    public AppException(ErrorCode errorCode) {
        super(errorCode.getMessage());
        this.errorCode = errorCode;
    }
}

package org.common.exception;

import lombok.Getter;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;

import static org.common.constant.ErrorCodeConstant.BAD_REQUEST_STATUS;
import static org.common.constant.ErrorCodeConstant.CONFLICT_STATUS;
import static org.common.constant.ErrorCodeConstant.FORBIDDEN_STATUS;
import static org.common.constant.ErrorCodeConstant.INTERNAL_SERVER_STATUS;
import static org.common.constant.ErrorCodeConstant.NOT_FOUND_STATUS;
import static org.common.constant.ErrorCodeConstant.UNAUTHORIZED_STATUS;
import static org.springframework.http.HttpStatus.BAD_REQUEST;

@Getter
public enum ErrorCode {
    // 500
    UNCATEGORIZED_EXCEPTION(999, INTERNAL_SERVER_STATUS, "Lỗi chưa phân loại", HttpStatus.INTERNAL_SERVER_ERROR),

    // 400
    VALIDATION_FAILED(400, BAD_REQUEST_STATUS, "Dữ liệu không hợp lệ!", org.springframework.http.HttpStatus.BAD_REQUEST),
    INVALID_OTP(400, BAD_REQUEST_STATUS, "OTP không hợp lệ!", BAD_REQUEST),
    OTP_EXPIRED(400, BAD_REQUEST_STATUS, "OTP đã hết hạn!", BAD_REQUEST),
    EMAIL_SEND_FAILED(4008003, BAD_REQUEST_STATUS, "Gửi email thất bại!", BAD_REQUEST),
    PARENT_CYCLE(400, BAD_REQUEST_STATUS, "Chu kỳ danh mục (parent) không hợp lệ", BAD_REQUEST),
    THUMBNAIL_ALREADY_SET(400, BAD_REQUEST_STATUS, "Đã có thumbnail cho thực thể này", BAD_REQUEST),

    // 401
    UNAUTHENTICATED(401, UNAUTHORIZED_STATUS, "Chưa xác thực!", HttpStatus.UNAUTHORIZED),
    INVALID_CREDENTIALS(401, UNAUTHORIZED_STATUS, "Thông tin đăng nhập không hợp lệ!", HttpStatus.UNAUTHORIZED),
    INVALID_TOKEN(401, UNAUTHORIZED_STATUS, "Token không hợp lệ!", HttpStatus.UNAUTHORIZED),
    TOKEN_REVOKED(401, UNAUTHORIZED_STATUS, "Token đã bị thu hồi!", HttpStatus.UNAUTHORIZED),

    // 403
    UNAUTHORIZED(403, FORBIDDEN_STATUS, "Bạn không có quyền truy cập!", HttpStatus.FORBIDDEN),

    // 404
    USER_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy user", HttpStatus.NOT_FOUND),
    ROLE_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy vai trò", HttpStatus.NOT_FOUND),
    ADDRESS_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy địa chỉ", HttpStatus.NOT_FOUND),
    EMAIL_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy email", HttpStatus.NOT_FOUND),
    BRAND_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy thương hiệu", HttpStatus.NOT_FOUND),
    CATEGORY_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy danh mục", HttpStatus.NOT_FOUND),
    PRODUCT_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy sản phẩm", HttpStatus.NOT_FOUND),
    VARIANT_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy biến thể", HttpStatus.NOT_FOUND),
    ATTRIBUTE_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy thuộc tính", HttpStatus.NOT_FOUND),
    IMAGE_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy ảnh", HttpStatus.NOT_FOUND),

    // 409
    USER_ALREADY_EXISTS(409, CONFLICT_STATUS, "Người dùng đã tồn tại!", HttpStatus.CONFLICT),
    EMAIL_ALREADY_EXISTS(409, CONFLICT_STATUS, "Email đã tồn tại!", HttpStatus.CONFLICT),
    PASSWORD_ALREADY_EXISTS(409, CONFLICT_STATUS, "Mật khẩu đã tồn tại!", HttpStatus.CONFLICT),
    ROLE_ALREADY_EXISTS(409, CONFLICT_STATUS, "Vai trò đã tồn tại!", HttpStatus.CONFLICT),
    SLUG_CONFLICT(409, CONFLICT_STATUS, "Slug đã tồn tại", HttpStatus.CONFLICT),
    SKU_CONFLICT(409, CONFLICT_STATUS, "SKU đã tồn tại", HttpStatus.CONFLICT),

    // 500
    FAILED_GENERATE_TOKEN(500, INTERNAL_SERVER_STATUS, "Lỗi tạo JWT token!", HttpStatus.INTERNAL_SERVER_ERROR),
    FAILED_VALIDATE_TOKEN(500, INTERNAL_SERVER_STATUS, "Lỗi xác thực token!", HttpStatus.INTERNAL_SERVER_ERROR),
    MAIL_DELIVERY_FAILED(500, INTERNAL_SERVER_STATUS, "Gửi email thất bại!", HttpStatus.INTERNAL_SERVER_ERROR);

    private final int code;
    private final String status;
    private final String message;
    private final HttpStatusCode statusCode;

    ErrorCode(int code, String status, String message, HttpStatusCode statusCode) {
        this.code = code;
        this.status = status;
        this.message = message;
        this.statusCode = statusCode;
    }

    public int http() { return statusCode.value(); }
}

package org.common.exception;

import io.grpc.Status;
import io.grpc.StatusRuntimeException;
import jakarta.validation.ConstraintViolationException;
import lombok.extern.slf4j.Slf4j;
import net.devh.boot.grpc.server.advice.GrpcAdvice;
import net.devh.boot.grpc.server.advice.GrpcExceptionHandler;
import org.springframework.security.access.AccessDeniedException;

@Slf4j
@GrpcAdvice
public class GrpcServerExceptionAdvice {

    @GrpcExceptionHandler(AppException.class)
    public StatusRuntimeException handleAppException(AppException appException) {
        return GrpcStatusMapper.ex(appException.getErrorCode());
    }

    @GrpcExceptionHandler(AccessDeniedException.class)
    public StatusRuntimeException handleDeniedException(
            AccessDeniedException accessDeniedException) {
        return GrpcStatusMapper.ex(ErrorCode.UNAUTHORIZED);
    }

    @GrpcExceptionHandler(ConstraintViolationException.class)
    public StatusRuntimeException handleBadException(
            ConstraintViolationException constraintViolationException) {
        return GrpcStatusMapper.ex(ErrorCode.VALIDATION_FAILED);
    }

    @GrpcExceptionHandler(Throwable.class)
    public StatusRuntimeException handleAnyException(
            Throwable throwable) {
        return Status.INTERNAL.withDescription(ErrorCode.UNCATEGORIZED_EXCEPTION.name())
                .asRuntimeException();
    }
}

package org.common.exception;

import com.google.protobuf.Empty;
import io.grpc.Status;
import io.grpc.StatusRuntimeException;
import io.grpc.stub.StreamObserver;
import lombok.experimental.UtilityClass;

@UtilityClass
public class GrpcStatusMapper {

    public Status statusFor(
            ErrorCode errorCode) {
        return switch (errorCode) {
            case UNAUTHENTICATED, INVALID_CREDENTIALS, INVALID_TOKEN,
                 TOKEN_REVOKED -> Status.UNAUTHENTICATED;
            case UNAUTHORIZED -> Status.PERMISSION_DENIED;
            case USER_NOT_FOUND, EMAIL_NOT_FOUND -> Status.NOT_FOUND;
            case USER_ALREADY_EXISTS, EMAIL_ALREADY_EXISTS,
                 PASSWORD_ALREADY_EXISTS -> Status.ALREADY_EXISTS;
            case FAILED_VALIDATE_TOKEN, INVALID_OTP, VALIDATION_FAILED,
                 OTP_EXPIRED, EMAIL_SEND_FAILED -> Status.INVALID_ARGUMENT;
            default -> Status.INTERNAL;
        };
    }

    public StatusRuntimeException ex(
            ErrorCode errorCode) {
        return statusFor(errorCode).withDescription(errorCode.name())
                .asRuntimeException();
    }

    public <T> void fail(
            StreamObserver<T> streamObserver,
            ErrorCode errorCode) {
        streamObserver.onError(ex(errorCode));
    }

    public void ok(
            StreamObserver<Empty> streamObserver) {
        streamObserver.onNext(Empty.getDefaultInstance());
        streamObserver.onCompleted();
    }

    public static <T> void ok(StreamObserver<? super T> streamObserver, T payload) {
        streamObserver.onNext(payload);
        streamObserver.onCompleted();
    }
}

package org.common.http;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;

import java.time.Instant;
import java.util.List;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = lombok.AccessLevel.PRIVATE)
public class Envelope<T> {

    @Builder.Default
    int status = 200;

    String error;

    @Builder.Default
    String msg = "OK";

    @Builder.Default
    Instant currentTime = Instant.now();

    T data;

    /* Helpers */
    public static <T> Envelope<T> ok(T data){
        return Envelope.<T>builder()
                .status(200)
                .error(null)
                .msg("OK")
                .currentTime(Instant.now())
                .data(data)
                .build();
    }
    public static <T> Envelope<T> err(
            int status,
            String code,
            String message,
            T data){
        return Envelope.<T>builder()
                .status(status)
                .error(code)
                .msg(message)
                .currentTime(Instant.now())
                .data(data)
                .build();
    }

    public static <TDoc> Envelope<Page<TDoc>> okPage(
            int page, int size,
            long total, int totalPages,
            List<TDoc> docs){
        return Envelope.ok(Page.<TDoc>builder()
                .page(page)
                .size(size)
                .total(total)
                .totalPages(totalPages)
                .docs(docs)
                .build()
        );
    }

    @Getter @Setter @Builder
    @NoArgsConstructor @AllArgsConstructor
    @FieldDefaults(level = lombok.AccessLevel.PRIVATE)
    public static class Page<TDoc>{
        int page;
        int size;
        long total;
        int totalPages;

        @Builder.Default
        List<TDoc> docs = List.of();
    }
}

syntax = "proto3";
package onlineshopping.v1;
option java_multiple_files = true;
option java_package = "com.common.grpc";
option java_outer_classname = "BrandProto";
import "google/protobuf/empty.proto";

import "common.proto";

message BrandCreateRequest {
  string name = 1;
  string slug = 2;
  string description = 3;
}
message BrandUpdateRequest {
  string id = 1;            // cập nhật theo id
  string name = 2;
  string slug = 3;
  string description = 4;
}

message BrandView {
  string id = 1;
  string name = 2;
  string slug = 3;
  string description = 4;
}

message BrandListRequest {
  string q = 1;         // search theo name/slug
  int32 page = 2;
  int32 size = 3;
}
message PageBrand {
  int32 page = 1;
  int32 size = 2;
  int64 total = 3;
  int32 total_pages = 4;
  repeated BrandView docs = 5;
}

service BrandService {
  rpc Create(BrandCreateRequest) returns (google.protobuf.Empty);
  rpc Update(BrandUpdateRequest) returns (google.protobuf.Empty);
  rpc SoftDelete(IdRequest) returns (google.protobuf.Empty);
  rpc Restore(IdRequest) returns (google.protobuf.Empty);

  rpc GetById(IdRequest) returns (BrandView);
  rpc GetBySlug(SlugRequest) returns (BrandView);
  rpc List(BrandListRequest) returns (PageBrand);
}

syntax = "proto3";
package onlineshopping.v1;
option java_multiple_files = true;
option java_package = "com.common.grpc";
option java_outer_classname = "CategoryProto";
import "google/protobuf/empty.proto";

import "common.proto";

message CategoryCreateRequest {
  string name = 1;
  string slug = 2;
  string description = 3;
  string parent_id = 4;   // optional
}
message CategoryUpdateRequest {
  string id = 1;
  string name = 2;
  string slug = 3;
  string description = 4;
}
message CategoryReparentRequest {
  string id = 1;
  string new_parent_id = 2; // null/empty => lên root
}

message CategoryView {
  string id = 1;
  string name = 2;
  string slug = 3;
  string description = 4;
  string parent_id = 5;
}

message CategoryListRequest {
  string q = 1;   // search theo name/slug
  int32 page = 2;
  int32 size = 3;
}
message PageCategory {
  int32 page = 1;
  int32 size = 2;
  int64 total = 3;
  int32 total_pages = 4;
  repeated CategoryView docs = 5;
}

message CategoryTreeNode {
  CategoryView data = 1;
  repeated CategoryTreeNode children = 2;
}

message CategoryChildrenRequest {
  string id = 1;     // lấy children của node (id = null -> root level)
}
message CategoryProductsRequest {
  string category_id = 1;
  int32 page = 2;
  int32 size = 3;
}

service CategoryService {
  rpc Create(CategoryCreateRequest) returns (google.protobuf.Empty);
  rpc Update(CategoryUpdateRequest) returns (google.protobuf.Empty);
  rpc SoftDelete(IdRequest) returns (google.protobuf.Empty);
  rpc Restore(IdRequest) returns (google.protobuf.Empty);
  rpc Reparent(CategoryReparentRequest) returns (google.protobuf.Empty);

  rpc GetById(IdRequest) returns (CategoryView);
  rpc GetBySlug(SlugRequest) returns (CategoryView);
  rpc List(CategoryListRequest) returns (PageCategory);

  rpc Tree(google.protobuf.Empty) returns (CategoryTreeNode);  // full tree
  rpc Children(CategoryChildrenRequest) returns (PageCategory); // 1 cấp con
}

syntax = "proto3";
package onlineshopping.v1;
option java_multiple_files = true;
option java_package = "com.common.grpc";
option java_outer_classname = "ProductProto";
import "google/protobuf/empty.proto";

import "common.proto";

enum ProductStatus {
  DRAFT = 0;
  PUBLISHED = 1;
  UNPUBLISHED = 2;
  ARCHIVED = 3;
}

message ProductCreateRequest {
  string name = 1;
  string slug = 2;
  string description = 3;
  string brand_id = 4;     // gán brand
}
message ProductUpdateRequest {
  string id = 1;
  string name = 2;
  string slug = 3;
  string description = 4;
  string brand_id = 5;
}

message ProductView {
  string id = 1;
  string name = 2;
  string slug = 3;
  string description = 4;
  ProductStatus status = 5;
  string brand_id = 6;
}

message ProductListRequest {
  string q = 1;              // text search
  string brand_id = 2;
  string category_id = 3;
  optional ProductStatus status = 4;
  int32 page = 5;
  int32 size = 6;
}
message PageProduct {
  int32 page = 1;
  int32 size = 2;
  int64 total = 3;
  int32 total_pages = 4;
  repeated ProductView docs = 5;
}

message PublishRequest { string id = 1; }
message UnpublishRequest { string id = 1; }
message ArchiveRequest { string id = 1; }

message AssignCategoryRequest {
  string product_id = 1;
  string category_id = 2;
}
message UnassignCategoryRequest {
  string product_id = 1;
  string category_id = 2;
}

service ProductService {
  rpc Create(ProductCreateRequest) returns (google.protobuf.Empty);
  rpc Update(ProductUpdateRequest) returns (google.protobuf.Empty);
  rpc SoftDelete(IdRequest) returns (google.protobuf.Empty);
  rpc Restore(IdRequest) returns (google.protobuf.Empty);

  rpc Publish(PublishRequest) returns (google.protobuf.Empty);
  rpc Unpublish(UnpublishRequest) returns (google.protobuf.Empty);
  rpc Archive(ArchiveRequest) returns (google.protobuf.Empty);

  rpc GetById(IdRequest) returns (ProductView);
  rpc GetBySlug(SlugRequest) returns (ProductView);
  rpc List(ProductListRequest) returns (PageProduct);

  rpc AssignCategory(AssignCategoryRequest) returns (google.protobuf.Empty);
  rpc UnassignCategory(UnassignCategoryRequest) returns (google.protobuf.Empty);
}

syntax = "proto3";
package onlineshopping.v1;
option java_multiple_files = true;
option java_package = "com.common.grpc";
option java_outer_classname = "AddressProto";
import "google/protobuf/empty.proto";

import "common.proto";

message AddressCreateRequest {
  string contact_name = 1;
  string contact_phone = 2;
  string address_line1 = 3;
  string address_line2 = 4;
  string district = 5;
  string city = 6;
  string country = 7;
  string postal_code = 8;
}
message AddressUpdateRequest {
  string id = 1;
  string contact_name = 2;
  string contact_phone = 3;
  string address_line1 = 4;
  string address_line2 = 5;
  string district = 6;
  string city = 7;
  string country = 8;
  string postal_code = 9;
}

message UserIdRequest {
  string user_id = 1;
  int32 page = 2;
  int32 size = 3;
}

message AddressView {
  string id = 1;
  string contact_name = 2;
  string contact_phone = 3;
  string address_line1 = 4;
  string address_line2 = 5;
  string district = 6;
  string city = 7;
  string country = 8;
  string postal_code = 9;
  bool is_default_shipping = 10;
  bool is_default_billing = 11;
}
message PageAddress {
  int32 page = 1;
  int32 size = 2;
  int64 total = 3;
  int32 total_pages = 4;
  repeated AddressView docs = 5;
}

service AddressService {
  rpc Create(AddressCreateRequest) returns (google.protobuf.Empty);
  rpc Update(AddressUpdateRequest) returns (google.protobuf.Empty);
  rpc SoftDelete(IdRequest) returns (google.protobuf.Empty);
  rpc SetDefaultShipping(IdRequest) returns (google.protobuf.Empty);
  rpc SetDefaultBilling(IdRequest) returns (google.protobuf.Empty);
  rpc ListByUser(UserIdRequest) returns (PageAddress);
}

syntax = "proto3";
package onlineshopping.v1;

option java_multiple_files = true;
option java_package = "com.common.grpc";
option java_outer_classname = "AuthProto";

// Register
message RegisterRequest {
  string username = 1;
  string email = 2;
  string password = 3;
}

message RegisterResponse {}

// Login
message LoginRequest {
  string username = 1;
  string email = 2;
  string password = 3;
}

message LoginResponse {
  string access_token = 1;
  string refresh_token = 2;
  string access_expiry = 3;
  string refresh_expiry = 4;
}

// Introspect
message IntrospectRequest {
  string token = 1;
}

message IntrospectResponse {
  bool valid = 1;
  string user_id = 2;
}

// Refresh
message RefreshRequest {
  string token = 1;
}

message RefreshResponse {
  string access_token = 1;
  string refresh_token = 2;
  string access_expiry = 3;
  string refresh_expiry = 4;
}

// Logout
message LogoutRequest {
  string token = 1;
}

message LogoutResponse {}

service AuthService {
  rpc Register(RegisterRequest) returns (RegisterResponse);
  rpc Login(LoginRequest) returns (LoginResponse);
  rpc Refresh(RefreshRequest) returns (RefreshResponse);
  rpc Introspect(IntrospectRequest) returns (IntrospectResponse);
  rpc Logout(LogoutRequest) returns (LogoutResponse);
}

syntax = "proto3";
package onlineshopping.v1;

option java_multiple_files = true;
option java_package = "com.common.grpc";
option java_outer_classname = "OtpProto";

import "google/protobuf/empty.proto";

message UserOtpRequest {
  string email = 1;
}

message OtpResponse {
  string email = 1;
  string message = 2;
}

message OtpVerificationRequest {
  string email = 1;
  string otpCode = 2;
}

message ResetPasswordRequest {
  string email = 1;
  string otp = 2;
  string newPassword = 3;
}

service OtpService {
  // OTP
  rpc SendOtp(UserOtpRequest) returns (OtpResponse);
  rpc VerifyOtp(OtpVerificationRequest) returns (google.protobuf.Empty);

  // Password
  rpc RequestResetPassword(UserOtpRequest) returns (OtpResponse);
  rpc VerifyOtpPassword(OtpVerificationRequest) returns (google.protobuf.Empty);
  rpc ResetPassword(ResetPasswordRequest) returns (google.protobuf.Empty);
}

syntax = "proto3";
package onlineshopping.v1;
option java_multiple_files = true;
option java_package = "com.common.grpc";
option java_outer_classname = "RoleProto";
import "google/protobuf/empty.proto";

message CreateRoleRequest {
  string name = 1;
}
message RoleName {
  string name = 1;
}
message AssignRoleRequest {
  string user_id = 1;
  string role_name = 2;
}
message RoleResponse {
  string name = 1;
}

message PageRequest {
  int32 page = 1;
  int32 size = 2;
}
message PageRole {
  int32 page = 1;
  int32 size = 2;
  int64 total = 3;
  int32 total_pages = 4;
  repeated RoleResponse docs = 5;
}
message MeLite {
  string id = 1;
  string username = 2;
  string email = 3;
  string full_name = 4;
}
message PageUser {
  int32 page = 1;
  int32 size = 2;
  int64 total = 3;
  int32 total_pages = 4;
  repeated MeLite docs = 5;
}

service RoleService {
  rpc Create(CreateRoleRequest) returns (google.protobuf.Empty);
  rpc SoftDelete(RoleName) returns (google.protobuf.Empty);
  rpc Restore(RoleName) returns (google.protobuf.Empty);
  rpc Assign(AssignRoleRequest) returns (google.protobuf.Empty);
  rpc Remove(AssignRoleRequest) returns (google.protobuf.Empty);
  rpc ListUserRoles(AssignRoleRequest) returns (PageRole); // use user_id, ignore role_name
  rpc ListUsersByRole(RoleName) returns (PageUser);
  rpc ListAll(PageRequest) returns (PageRole);
}

syntax = "proto3";
package onlineshopping.v1;
option java_multiple_files = true;
option java_package = "com.common.grpc";
option java_outer_classname = "UserProto";
import "google/protobuf/empty.proto";

message ToggleActiveRequest {
  string user_id = 1;
  bool active = 2;
}

message MeResponse {
  string id = 1;
  string username = 2;
  string email = 3;
  string full_name = 4;
  string phone_number = 5;
  bool is_active = 6;
  bool is_verified = 7;
}
message UpdateProfileRequest {
  string full_name = 1;
  string phone_number = 2;
}

service UserService {
  rpc ToggleActive(ToggleActiveRequest) returns (google.protobuf.Empty);
  rpc GetMe(google.protobuf.Empty) returns (MeResponse);
  rpc UpdateProfile(UpdateProfileRequest) returns (google.protobuf.Empty);
}

syntax = "proto3";

package onlineshopping.v1;
option java_package = "com.common.grpc";

option java_multiple_files = true;

message IdRequest {
  string id = 1;
}

message SlugRequest {
  string slug = 1;
}


bussiness-service
package com.business.entity;

import com.business.entity.audit.AuditMetadata;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.Table;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;
import org.hibernate.annotations.SQLDelete;
import org.hibernate.annotations.Where;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(
        name = "attributes",
        indexes = {@Index(name = "idx_attr_name", columnList = "name")}
)
@SQLDelete(sql = "UPDATE attributes SET deleted_by = ?, deleted_at = now() WHERE attribute_id = ?")
@Where(clause = "deleted_at IS NULL")
public class Attribute extends AuditMetadata {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "attribute_id", length = 36)
    String id;

    @Column(length = 100, nullable = false, unique = true)
    String name;

    @Column(length = 100, nullable = false)
    String value;
}

package com.business.entity;

import com.business.entity.audit.AuditMetadata;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.Table;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;
import org.hibernate.annotations.SQLDelete;
import org.hibernate.annotations.Where;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(
        name = "brands",
        indexes = {
                @Index(name = "idx_brands_name", columnList = "name"),
                @Index(name = "idx_brands_slug", columnList = "slug")
        })
@SQLDelete(sql = "UPDATE brands SET deleted_by = ?, deleted_at = now() WHERE brand_id = ?")
@Where(clause = "deleted_at IS NULL")
public class Brand extends AuditMetadata {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "brand_id", length = 36)
    String id;

    @Column(length = 100, nullable = false, unique = true)
    String name;

    @Column(length = 110, nullable = false, unique = true)
    String slug;

    @Column(name = "logo_url", length = 255)
    String logoUrl;
}

package com.business.entity;

import com.business.entity.audit.AuditMetadata;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.Table;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;
import org.hibernate.annotations.SQLDelete;
import org.hibernate.annotations.Where;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(
        name = "carts",
        indexes = {@Index(name = "idx_carts_user", columnList = "user_id")}
)
@SQLDelete(sql = "UPDATE carts SET deleted_by = ?, deleted_at = now() WHERE user_id = ?")
@Where(clause = "deleted_at IS NULL")
public class Cart extends AuditMetadata {

    @Id
    @Column(name = "user_id", length = 36)
    String userId; // PK = user_id (1-1)
}

package com.business.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import jakarta.persistence.UniqueConstraint;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(
        name = "cart_items",
        indexes = {
                @Index(name = "idx_cart_items_user", columnList = "user_id"),
                @Index(name = "idx_cart_items_variant", columnList = "variant_id")
        },
        uniqueConstraints = @UniqueConstraint(name = "uk_user_variant", columnNames = {
                "user_id", "variant_id"})
)
public class CartItem {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "cart_item_id", length = 36)
    String id;

    @Column(name = "user_id", length = 36, nullable = false)
    String userId;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "variant_id", nullable = false)
    ProductVariant variant;

    @Column(nullable = false)
    Integer quantity = 1;
}

package com.business.entity;

import com.business.entity.audit.AuditMetadata;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;
import org.hibernate.annotations.SQLDelete;
import org.hibernate.annotations.Where;

import java.util.HashSet;
import java.util.Set;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(
        name = "categories",
        indexes = {
                @Index(name = "idx_categories_name", columnList = "name"),
                @Index(name = "idx_categories_slug", columnList = "slug"),
                @Index(name = "idx_categories_parent", columnList = "parent_id")
        })
@SQLDelete(sql = "UPDATE categories SET deleted_by = ?, deleted_at = now() WHERE category_id = ?")
@Where(clause = "deleted_at IS NULL")
public class Category extends AuditMetadata {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "category_id", length = 36)
    String id;

    @Column(length = 100, nullable = false)
    String name;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "parent_id")
    Category parent;

    @OneToMany(mappedBy = "parent")
    Set<Category> children = new HashSet<>();

    @Column(length = 110, nullable = false, unique = true)
    String slug;
}

package com.business.entity;

import com.business.constant.DiscountType;
import com.business.entity.audit.AuditMetadata;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.Table;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;
import org.hibernate.annotations.SQLDelete;
import org.hibernate.annotations.Where;

import java.math.BigDecimal;
import java.time.Instant;


@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(
        name = "discounts",
        indexes = {
                @Index(name = "idx_discounts_code", columnList = "code"),
                @Index(name = "idx_discounts_active", columnList = "is_active"),
                @Index(name = "idx_discounts_window", columnList = "start_date,end_date")
        })
@SQLDelete(sql = "UPDATE discounts SET deleted_by = ?, deleted_at = now() WHERE discount_id = ?")
@Where(clause = "deleted_at IS NULL")
public class Discount extends AuditMetadata {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "discount_id", length = 36)
    String id;

    @Column(length = 50, nullable = false, unique = true)
    String code;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    DiscountType type;

    @Column(precision = 10, scale = 2, nullable = false)
    BigDecimal value;

    @Column(name = "start_date")
    Instant startDate;

    @Column(name = "end_date")
    Instant endDate;

    @Column(name = "min_order_value", precision = 10, scale = 2)
    BigDecimal minOrderValue = BigDecimal.ZERO;

    @Column(name = "is_active", nullable = false)
    Boolean active = true;
}

package com.business.entity;

import com.business.constant.OrderStatus;
import com.business.entity.audit.AuditMetadata;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.Lob;
import jakarta.persistence.Table;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;
import org.hibernate.annotations.SQLDelete;
import org.hibernate.annotations.Where;

import java.math.BigDecimal;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(
        name = "orders",
        indexes = {
                @Index(name = "idx_orders_user", columnList = "user_id"),
                @Index(name = "idx_orders_status", columnList = "status"),
                @Index(name = "idx_orders_created", columnList = "created_at")
        })
@SQLDelete(sql = "UPDATE orders SET deleted_by = ?, deleted_at = now() WHERE order_id = ?")
@Where(clause = "deleted_at IS NULL")
public class Order extends AuditMetadata {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "order_id", length = 36)
    String id;

    @Column(name = "user_id", length = 36, nullable = false)
    String userId;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    OrderStatus status = OrderStatus.pending;

    @Column(precision = 10, scale = 2, nullable = false)
    BigDecimal subtotal;

    @Column(name = "shipping_fee", precision = 10, scale = 2, nullable = false)
    BigDecimal shippingFee = BigDecimal.ZERO;

    @Column(name = "discount_amount", precision = 10, scale = 2, nullable = false)
    BigDecimal discountAmount = BigDecimal.ZERO;

    @Column(name = "total_amount", precision = 10, scale = 2, nullable = false)
    BigDecimal totalAmount;

    @Lob
    @Column(name = "shipping_address", nullable = false, columnDefinition = "text")
    String shippingAddress;

    @Lob
    @Column(name = "billing_address", columnDefinition = "text")
    String billingAddress;

    @Column(name = "payment_method_name", length = 100)
    String paymentMethodName;

    @Column(name = "shipping_method_name", length = 100)
    String shippingMethodName;

    @Column(name = "discount_code", length = 50)
    String discountCode;
}

package com.business.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;

import java.math.BigDecimal;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(
        name = "order_items",
        indexes = {
                @Index(name = "idx_order_items_order", columnList = "order_id"),
                @Index(name = "idx_order_items_variant", columnList = "variant_id")
        })
public class OrderItem {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "order_item_id", length = 36)
    String id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false)
    Order order;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "variant_id", nullable = false)
    ProductVariant variant;

    @Column(length = 100) // denormalized
    String sku;

    @Column(name = "product_name", length = 255, nullable = false)
    // denormalized
    String productName;

    @Column(nullable = false)
    Integer quantity;

    @Column(precision = 10, scale = 2, nullable = false)
    BigDecimal price; // giá tại thời điểm mua
}

package com.business.entity;

import com.business.constant.ProductStatus;
import com.business.entity.audit.AuditMetadata;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.Lob;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;
import org.hibernate.annotations.SQLDelete;
import org.hibernate.annotations.Where;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(
        name = "products",
        indexes = {
                @Index(name = "idx_products_name", columnList = "name"),
                @Index(name = "idx_products_slug", columnList = "slug"),
                @Index(name = "idx_products_brand", columnList = "brand_id"),
                @Index(name = "idx_products_status", columnList = "status")
        })
@SQLDelete(sql = "UPDATE products SET deleted_by = ?, deleted_at = now() WHERE product_id = ?")
@Where(clause = "deleted_at IS NULL")
public class Product extends AuditMetadata {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "product_id", length = 36)
    String id;

    @Column(length = 255, nullable = false)
    String name;

    @Lob
    @Column(columnDefinition = "text")
    String description;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "brand_id")
    Brand brand;

    @Column(length = 255, nullable = false, unique = true)
    String slug;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    ProductStatus status = ProductStatus.draft;
}


package com.business.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import jakarta.persistence.UniqueConstraint;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(
        name = "product_categories",
        indexes = {
                @Index(name = "idx_pc_product", columnList = "product_id"),
                @Index(name = "idx_pc_category", columnList = "category_id")
        },
        uniqueConstraints = @UniqueConstraint(name = "uk_product_category", columnNames = {
                "product_id", "category_id"})
)
public class ProductCategory {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(length = 36)
    String id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    Product product;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id", nullable = false)
    Category category;
}

package com.business.entity;

import com.business.entity.audit.AuditMetadata;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;
import org.hibernate.annotations.SQLDelete;
import org.hibernate.annotations.Where;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(
        name = "product_images",
        indexes = {
                @Index(name = "idx_images_product", columnList = "product_id"),
                @Index(name = "idx_images_variant", columnList = "variant_id"),
                @Index(name = "idx_images_thumbnail", columnList = "is_thumbnail")
        })
@SQLDelete(sql = "UPDATE product_images SET deleted_by = ?, deleted_at = now() WHERE image_id = ?")
@Where(clause = "deleted_at IS NULL")
public class ProductImage extends AuditMetadata {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "image_id", length = 36)
    String id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id")
    Product product;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "variant_id")
    ProductVariant variant;

    @Column(name = "image_url", length = 255, nullable = false)
    String imageUrl;

    @Column(name = "is_thumbnail", nullable = false)
    Boolean thumbnail = false;
}

package com.business.entity;

import com.business.entity.audit.AuditMetadata;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;
import org.hibernate.annotations.SQLDelete;
import org.hibernate.annotations.Where;

import java.math.BigDecimal;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(
        name = "product_variants",
        indexes = {
                @Index(name = "idx_variants_product", columnList = "product_id"),
                @Index(name = "idx_variants_sku", columnList = "sku"),
                @Index(name = "idx_variants_price", columnList = "price")
        })
@SQLDelete(sql = "UPDATE product_variants SET deleted_by = ?, deleted_at = now() WHERE variant_id = ?")
@Where(clause = "deleted_at IS NULL")
public class ProductVariant extends AuditMetadata {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "variant_id", length = 36)
    String id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    Product product;

    @Column(length = 100, nullable = false, unique = true)
    String sku;

    @Column(precision = 10, scale = 2, nullable = false)
    BigDecimal price;

    @Column(name = "original_price", precision = 10, scale = 2)
    BigDecimal originalPrice;
}

package com.business.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import jakarta.persistence.UniqueConstraint;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(
        name = "variant_attribute_values",
        indexes = {
                @Index(name = "idx_vav_variant", columnList = "variant_id"),
                @Index(name = "idx_vav_attribute", columnList = "attribute_id")
        },
        uniqueConstraints = @UniqueConstraint(name = "uk_variant_attribute", columnNames = {
                "variant_id", "attribute_id"})
)
public class VariantAttributeValue {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(length = 36)
    String id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "variant_id", nullable = false)
    ProductVariant variant;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "attribute_id", nullable = false)
    Attribute attribute;
}

package com.business.entity.audit;

import jakarta.persistence.Column;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;
import lombok.experimental.FieldDefaults;
import org.springframework.data.annotation.CreatedBy;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedBy;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;

@Getter
@Setter
@ToString
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
@FieldDefaults(level = AccessLevel.PROTECTED)
public class AuditMetadata implements SoftDeletable {
    /* ---- create ---- */
    @CreatedBy
    @Column(name = "created_by")
    String createdBy;

    @CreatedDate
    @Column(name = "created_at")
    Instant createdAt;

    /* ---- update ---- */
    @LastModifiedBy
    @Column(name = "updated_by")
    String updatedBy;

    @LastModifiedDate
    @Column(name = "updated_at")
    Instant updatedAt;

    /* ---- soft-delete ---- */
    @Column(name = "deleted_by")
    String deletedBy;

    @Column(name = "deleted_at")
    Instant deletedAt;

    @Override
    public void markDeleted(String by) {
        this.deletedBy = by;
        this.deletedAt = Instant.now();
    }

    @Override
    public boolean isDeleted() {
        return deletedAt != null;
    }
}

package com.business.entity.audit;

public interface SoftDeletable {
    void markDeleted(String by);

    boolean isDeleted();

    String getDeletedBy();
}

package com.business.constant;

public enum DiscountType {
    percentage,
    fixed_amount
}

package com.business.constant;

public enum OrderStatus {
    pending,
    processing,
    shipped,
    completed,
    cancelled
}

package com.business.constant;

public enum ProductStatus { published, draft, archived }

package com.business.configuration.audit;

import org.hibernate.Interceptor;
import org.springframework.boot.autoconfigure.orm.jpa.HibernatePropertiesCustomizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class HibernateInterceptorConfig {
    @Bean
    public Interceptor softDeleteInterceptor() {
        return new SoftDeleteInterceptor();
    }

    @Bean
    public HibernatePropertiesCustomizer interceptorCustomizer(
            Interceptor softDeleteInterceptor) {

        return props -> props.put(
                "hibernate.session_factory.interceptor",
                softDeleteInterceptor);
    }
}

package com.business.configuration.audit;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.domain.AuditorAware;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;

import java.util.Optional;

@Configuration
@EnableJpaAuditing(auditorAwareRef = "auditorProvider")
public class JpaAuditConfiguration {
    /**
     * Trả về username hiện tại (hoặc “System” nếu chưa đăng nhập).
     * Spring Data sẽ dùng giá trị này để gán vào @CreatedBy / @LastModifiedBy.
     */
    @Bean
    public AuditorAware<String> auditorProvider() {
        return () -> {
            Authentication auth = SecurityContextHolder
                    .getContext()
                    .getAuthentication();

            return Optional.ofNullable(auth)
                    .map(Authentication::getName)
                    .or(() -> Optional.of("System"));
        };
    }
}

package com.business.configuration.audit;

import com.business.entity.audit.SoftDeletable;
import lombok.extern.slf4j.Slf4j;
import org.hibernate.EmptyInterceptor;
import org.hibernate.type.Type;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;

import java.time.Instant;
import java.util.Optional;

@Slf4j
public class SoftDeleteInterceptor extends EmptyInterceptor {
    @Override
    public void onDelete(
            Object entity,
            Object id,
            Object[] state,
            String[] propertyNames,
            Type[] types) {

        if (!(entity instanceof SoftDeletable soft)) {
            super.onDelete(
                    entity,
                    id,
                    state,
                    propertyNames,
                    types
            );
            return;
        }

        // Chặn DELETE -> UPDATE
        String by = Optional.ofNullable(SecurityContextHolder
                        .getContext()
                        .getAuthentication())
                .map(Authentication::getName)
                .orElse("System");

        soft.markDeleted(by);

        // Đẩy giá trị vào state[] để Hibernate cập nhật DB
        Instant now = Instant.now();
        for (int i = 0; i < propertyNames.length; i++) {
            switch (propertyNames[i]) {
                case "deletedBy" -> state[i] = by;
                case "deletedAt" -> state[i] = now;
            }
        }

    }
}
package com.business.configuration.security;


import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.oauth2.jose.jws.MacAlgorithm;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.stereotype.Component;

import javax.crypto.spec.SecretKeySpec;
import java.util.Objects;


@Component
public class CustomJwtDecoder implements JwtDecoder {

    @Value("${app.jwt.signerKey}")
    private String signerKey;

    private NimbusJwtDecoder nimbusJwtDecoder;

    @Override
    public Jwt decode(String token) throws JwtException {

        if (Objects.isNull(nimbusJwtDecoder)) {
            SecretKeySpec secretKeySpec =
                    new SecretKeySpec(signerKey.getBytes(), "HS512");

            nimbusJwtDecoder = NimbusJwtDecoder.withSecretKey(secretKeySpec)
                    .macAlgorithm(MacAlgorithm.HS512)
                    .build();
        }

        return nimbusJwtDecoder.decode(token);
    }
}

package com.business.configuration.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.ProviderManager;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationProvider;

@Configuration
public class GrpcJwtAuthManagerConfig {

    @Bean
    public JwtAuthenticationConverter grpcJwtAuthenticationConverter() {
        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
        return jwtAuthenticationConverter;
    }

    @Bean
    public AuthenticationManager grpcAuthenticationManager(
            JwtDecoder jwtDecoder,
            JwtAuthenticationConverter grpcJwtAuthenticationConverter) {

        JwtAuthenticationProvider provider = new JwtAuthenticationProvider(jwtDecoder);
        provider.setJwtAuthenticationConverter(grpcJwtAuthenticationConverter);
        return new ProviderManager(provider);
    }
}



package com.business.configuration.security;

import io.grpc.CallOptions;
import io.grpc.Channel;
import io.grpc.ClientCall;
import io.grpc.ClientInterceptor;
import io.grpc.ForwardingClientCall;
import io.grpc.Metadata;
import io.grpc.MethodDescriptor;
import net.devh.boot.grpc.client.interceptor.GlobalClientInterceptorConfigurer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.oauth2.server.resource.authentication.BearerTokenAuthentication;

@Configuration
public class GrpcJwtClientPropagationConfig {

    static class JwtPropagatingClientInterceptor implements ClientInterceptor {
        private static final Metadata.Key<String> AUTH =
                Metadata.Key.of("Authorization", Metadata.ASCII_STRING_MARSHALLER);

        @Override
        public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(
                MethodDescriptor<ReqT, RespT> method,
                CallOptions callOptions,
                Channel next) {

            return new ForwardingClientCall.SimpleForwardingClientCall<>(next.newCall(method, callOptions)) {
                @Override
                public void start(Listener<RespT> responseListener, Metadata headers) {
                    String token = resolveToken();
                    if (token != null && !token.isBlank()) {
                        headers.put(AUTH, "Bearer " + token);
                    }
                    super.start(responseListener, headers);
                }
            };
        }

        private String resolveToken() {
            var ctx = SecurityContextHolder.getContext();
            if (ctx == null || ctx.getAuthentication() == null) return null;
            if (ctx.getAuthentication() instanceof BearerTokenAuthentication b) {
                return b.getToken().getTokenValue();
            }
            return null;
        }
    }

    @Bean
    public GlobalClientInterceptorConfigurer jwtPropagationConfigurer() {
        return interceptors -> interceptors.add(
                new JwtPropagatingClientInterceptor());
    }
}

package com.business.configuration.security;

import net.devh.boot.grpc.server.security.authentication.BearerAuthenticationReader;
import net.devh.boot.grpc.server.security.authentication.GrpcAuthenticationReader;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.oauth2.server.resource.authentication.BearerTokenAuthenticationToken;

@Configuration
public class GrpcServerSecurityConfig {
    @Bean
    public GrpcAuthenticationReader grpcAuthenticationReader() {
        return new BearerAuthenticationReader(token ->
                new BearerTokenAuthenticationToken(token));
    }
}


package com.business.configuration.security;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.common.exception.ErrorCode;
import org.common.http.Envelope;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;

import java.io.IOException;

public class JwtAuthenticationEntryPoint
        implements AuthenticationEntryPoint {
    @Override
    public void commence(
            HttpServletRequest request,
            HttpServletResponse response,
            AuthenticationException authException)
            throws IOException {
        ErrorCode errorCode = ErrorCode.UNAUTHENTICATED;
        Envelope<Void> envelope = Envelope.err(
                        errorCode.http(),
                        errorCode.name(),
                        errorCode.getMessage(),
                        null);

        response.setStatus(errorCode.http());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        new ObjectMapper().writeValue(response.getWriter(), envelope);
        response.flushBuffer();
    }
}

package com.business.configuration.security;

import lombok.NoArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.access.hierarchicalroles.RoleHierarchy;
import org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
@NoArgsConstructor
public class SecurityBeanConfig {


    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }


    @Bean
    public RoleHierarchy roleHierarchy() {
        return RoleHierarchyImpl.fromHierarchy("ROLE_ADMIN > ROLE_USER");
    }
}


package com.business.configuration.security;

import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.List;

import static org.common.constant.SecurityConstants.ACCEPT_HEADER;
import static org.common.constant.SecurityConstants.AUTHORIZATION_HEADER;
import static org.common.constant.SecurityConstants.CONTENT_TYPE_HEADER;
import static org.common.constant.SecurityConstants.FRONTEND_ENDPOINT;
import static org.common.constant.SecurityConstants.PUBLIC_ENDPOINTS;
import static org.common.constant.SecurityConstants.URL_PATTERN_ALL;
import static org.springdoc.core.utils.Constants.DELETE_METHOD;
import static org.springdoc.core.utils.Constants.GET_METHOD;
import static org.springdoc.core.utils.Constants.OPTIONS_METHOD;
import static org.springdoc.core.utils.Constants.PATCH_METHOD;
import static org.springdoc.core.utils.Constants.POST_METHOD;
import static org.springdoc.core.utils.Constants.PUT_METHOD;


@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfiguration {

    @Autowired
    private CustomJwtDecoder customJwtDecoder;


    @Bean
    public SecurityFilterChain securityFilterChain(
            HttpSecurity httpSecurity) throws Exception {
        httpSecurity
                .headers(headers -> headers.frameOptions(
                        frame -> frame.sameOrigin()))
                .authorizeHttpRequests(request -> request
                        .requestMatchers(PUBLIC_ENDPOINTS)
                        .permitAll()
                        .anyRequest()
                        .authenticated());

        httpSecurity.oauth2ResourceServer(
                oauth2 -> oauth2.jwt(jwtConfigurer -> jwtConfigurer
                                .decoder(customJwtDecoder)
                                .jwtAuthenticationConverter(
                                        jwtAuthenticationConverter()))
                        .authenticationEntryPoint(
                                new JwtAuthenticationEntryPoint()));
        httpSecurity.csrf(AbstractHttpConfigurer::disable);

        return httpSecurity.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();

        configuration.setAllowedOriginPatterns(List.of(
                FRONTEND_ENDPOINT
        ));

        configuration.setAllowedMethods(
                List.of(GET_METHOD, POST_METHOD, PUT_METHOD, DELETE_METHOD,
                        PATCH_METHOD, OPTIONS_METHOD));

        configuration.setAllowedHeaders(
                List.of(AUTHORIZATION_HEADER, CONTENT_TYPE_HEADER,
                        ACCEPT_HEADER));

        // Cho phép gửi credentials (cookie, header, v.v.)
        configuration.setAllowCredentials(true);

        // Expose header "Authorization"
        configuration.setExposedHeaders(List.of(AUTHORIZATION_HEADER));

        // Thời gian cache preflight request
        configuration.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source =
                new UrlBasedCorsConfigurationSource();

        // Áp dụng cấu hình cho tất cả các endpoint
        source.registerCorsConfiguration(URL_PATTERN_ALL, configuration);
        return source;
    }


    @Bean
    JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter authConverter =
                new JwtGrantedAuthoritiesConverter();
        authConverter.setAuthorityPrefix("");

        JwtAuthenticationConverter converter = new JwtAuthenticationConverter();
        converter.setJwtGrantedAuthoritiesConverter(authConverter);

        converter.setPrincipalClaimName("userId");

        return converter;
    }
}


package com.business.constant;

public enum ProductStatus {
    PUBLISHED,
    UNPUBLISHED,
    DRAFT,
    ARCHIVED
}

package com.business.controller;

import com.business.dto.request.BrandCreateRequestDto;
import com.business.dto.request.BrandUpdateRequestDto;
import com.business.dto.response.BrandResponseDto;
import com.business.service.IBrandService;
import com.common.grpc.BrandCreateRequest;
import com.common.grpc.BrandListRequest;
import com.common.grpc.BrandServiceGrpc;
import com.common.grpc.BrandUpdateRequest;
import com.common.grpc.BrandView;
import com.common.grpc.IdRequest;
import com.common.grpc.PageBrand;
import com.common.grpc.SlugRequest;
import com.google.protobuf.Empty;
import io.grpc.stub.StreamObserver;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.AccessLevel;
import net.devh.boot.grpc.server.service.GrpcService;
import org.common.exception.GrpcStatusMapper;
import org.common.http.Envelope;

@GrpcService
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class BrandGrpcServer
        extends BrandServiceGrpc.BrandServiceImplBase {
    IBrandService brandService;

    @Override
    public void create(
            BrandCreateRequest request,
            StreamObserver<Empty> responseObserver) {
        brandService.create(BrandCreateRequestDto.builder()
                .name(request.getName())
                .slug(request.getSlug())
                .description(request.getDescription())
                .build());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void update(
            BrandUpdateRequest brandUpdateRequest,
            StreamObserver<Empty> responseObserver) {
        brandService.update(
                brandUpdateRequest.getId(),
                BrandUpdateRequestDto.builder()
                        .name(brandUpdateRequest.getName())
                        .slug(brandUpdateRequest.getSlug())
                        .description(brandUpdateRequest.getDescription())
                        .build()
        );
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void softDelete(
            IdRequest request,
            StreamObserver<Empty> responseObserver) {
        brandService.softDelete(request.getId());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void restore(
            IdRequest request,
            StreamObserver<Empty> responseObserver) {
        brandService.restore(request.getId());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void getById(
            IdRequest request,
            StreamObserver<BrandView> responseObserver) {
        BrandResponseDto d = brandService.getById(request.getId());
        GrpcStatusMapper.ok(
                responseObserver,
                BrandView.newBuilder()
                        .setId(d.getId())
                        .setName(d.getName()).setSlug(d.getSlug())
                        .setDescription(d.getDescription() == null
                                ? ""
                                : d.getDescription())
                .build());
    }

    @Override
    public void getBySlug(
            SlugRequest request,
            StreamObserver<BrandView> responseObserver) {
        BrandResponseDto d = brandService.getBySlug(request.getSlug());
        GrpcStatusMapper.ok(
                responseObserver,
                BrandView.newBuilder()
                        .setId(d.getId())
                        .setName(d.getName())
                        .setSlug(d.getSlug())
                        .setDescription(d.getDescription() == null
                                ? ""
                                : d.getDescription())
                        .build());
    }

    @Override
    public void list(
            BrandListRequest request,
            StreamObserver<PageBrand> responseObserver) {
        Envelope.Page<BrandResponseDto> page = brandService.list(
                request.getQ(),
                request.getPage(),
                request.getSize()
        );
        PageBrand.Builder b = PageBrand.newBuilder()
                .setPage(page.getPage())
                .setSize(page.getSize())
                .setTotal(page.getTotal())
                .setTotalPages(page.getTotalPages());
        page.getDocs().forEach(d -> b.addDocs(BrandView.newBuilder()
                .setId(d.getId())
                .setName(d.getName())
                .setSlug(d.getSlug())
                .setDescription(d.getDescription() == null
                        ? ""
                        : d.getDescription())
                .build()));
        GrpcStatusMapper.ok(responseObserver, b.build());
    }
}

package com.business.controller;

import com.business.dto.request.CategoryCreateRequestDto;
import com.business.dto.request.CategoryUpdateRequestDto;
import com.business.dto.response.CategoryResponseDto;
import com.business.service.ICategoryService;
import com.common.grpc.CategoryChildrenRequest;
import com.common.grpc.CategoryCreateRequest;
import com.common.grpc.CategoryListRequest;
import com.common.grpc.CategoryReparentRequest;
import com.common.grpc.CategoryServiceGrpc;
import com.common.grpc.CategoryTreeNode;
import com.common.grpc.CategoryUpdateRequest;
import com.common.grpc.CategoryView;
import com.common.grpc.IdRequest;
import com.common.grpc.PageCategory;
import com.common.grpc.SlugRequest;
import com.google.protobuf.Empty;
import io.grpc.stub.StreamObserver;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import net.devh.boot.grpc.server.service.GrpcService;
import org.common.exception.GrpcStatusMapper;
import org.common.http.Envelope;

@GrpcService
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class CategoryGrpcServer extends CategoryServiceGrpc.CategoryServiceImplBase {

    ICategoryService categoryService;

    @Override
    public void create(
            CategoryCreateRequest request,
            StreamObserver<Empty> responseObserver) {
        categoryService.create(CategoryCreateRequestDto.builder()
                .name(request.getName())
                .slug(request.getSlug())
                .description(request.getDescription())
                .parentId(request.getParentId().isBlank()
                        ? null
                        : request.getParentId())
                .build());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void update(
            CategoryUpdateRequest request,
            StreamObserver<Empty> responseObserver) {
        categoryService.update(
                request.getId(),
                CategoryUpdateRequestDto.builder()
                    .name(request.getName())
                    .slug(request.getSlug())
                    .description(request.getDescription())
                    .build());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void softDelete(
            IdRequest request,
            StreamObserver<Empty> responseObserver) {
        categoryService.softDelete(request.getId());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void restore(IdRequest request, StreamObserver<Empty> responseObserver) {
        categoryService.restore(request.getId());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void reparent(
            CategoryReparentRequest request,
            StreamObserver<Empty> responseObserver) {
        categoryService.reparent(request.getId(),
                request.getNewParentId().isBlank()
                        ? null
                        : request.getNewParentId());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void getById(
            IdRequest request,
            StreamObserver<CategoryView> responseObserver) {
        CategoryResponseDto d = categoryService.getById(request.getId());
        GrpcStatusMapper.ok(responseObserver, CategoryView.newBuilder()
                .setId(d.getId())
                .setName(d.getName())
                .setSlug(d.getSlug())
                .setDescription(d.getDescription() == null
                        ? ""
                        : d.getDescription())
                .setParentId(d.getParentId() == null
                        ? ""
                        : d.getParentId())
                .build());
    }

    @Override
    public void getBySlug(
            SlugRequest request,
            StreamObserver<CategoryView> responseObserver) {
        CategoryResponseDto d = categoryService.getBySlug(request.getSlug());
        GrpcStatusMapper.ok(
                responseObserver,
                CategoryView.newBuilder()
                    .setId(d.getId())
                    .setName(d.getName())
                    .setSlug(d.getSlug())
                    .setDescription(d.getDescription()==null
                            ? ""
                            : d.getDescription())
                    .setParentId(d.getParentId() == null
                            ? ""
                            : d.getParentId())
                    .build());
    }

    @Override
    public void list(
            CategoryListRequest request,
            StreamObserver<PageCategory> responseObserver) {
        Envelope.Page<CategoryResponseDto> page = categoryService.list(
                request.getQ(),
                request.getPage(),
                request.getSize()
        );
        PageCategory.Builder b = PageCategory.newBuilder()
                .setPage(page.getPage())
                .setSize(page.getSize())
                .setTotal(page.getTotal())
                .setTotalPages(page.getTotalPages());
        page.getDocs().forEach(d -> b.addDocs(CategoryView.newBuilder()
                .setId(d.getId())
                .setName(d.getName())
                .setSlug(d.getSlug())
                .setDescription(d.getDescription() == null
                        ? ""
                        : d.getDescription())
                .setParentId(d.getParentId() == null
                        ? ""
                        : d.getParentId())
                .build()));
        GrpcStatusMapper.ok(responseObserver, b.build());
    }

    // full tree
    @Override
    public void tree(
            Empty request,
            StreamObserver<CategoryTreeNode> responseObserver) {
        com.business.dto.model.CategoryTreeNode root = categoryService.tree();
        GrpcStatusMapper.ok(responseObserver, toGrpc(root));
    }

    private CategoryTreeNode toGrpc(com.business.dto.model.CategoryTreeNode n){
        CategoryTreeNode.Builder builder = CategoryTreeNode.newBuilder();
        if (n.getData()!=null){
            var d = n.getData();
            builder.setData(CategoryView.newBuilder()
                    .setId(d.getId())
                    .setName(d.getName())
                    .setSlug(d.getSlug())
                    .setDescription(d.getDescription() == null
                            ? ""
                            : d.getDescription())
                    .setParentId(d.getParentId() == null
                            ? ""
                            : d.getParentId())
                    .build());
        }
        n.getChildren().forEach(c -> builder.addChildren(toGrpc(c)));
        return builder.build();
    }

    @Override
    public void children(
            CategoryChildrenRequest request,
            StreamObserver<PageCategory> responseObserver) {
        Envelope.Page<CategoryResponseDto> page = categoryService.children(
                request.getId().isBlank()
                        ? null
                        : request.getId(),
                0, Integer.MAX_VALUE);
        PageCategory.Builder b = PageCategory.newBuilder()
                .setPage(page.getPage())
                .setSize(page.getSize())
                .setTotal(page.getTotal())
                .setTotalPages(page.getTotalPages());
        page.getDocs().forEach(d -> b.addDocs(CategoryView.newBuilder()
                .setId(d.getId())
                .setName(d.getName())
                .setSlug(d.getSlug())
                .setDescription(d.getDescription() == null
                        ? ""
                        : d.getDescription())
                .setParentId(d.getParentId() == null
                        ? ""
                        : d.getParentId())
                .build()));
        GrpcStatusMapper.ok(responseObserver, b.build());
    }
}

package com.business.controller;

import com.business.dto.request.ProductCreateRequestDto;
import com.business.dto.request.ProductUpdateRequestDto;
import com.business.dto.response.ProductResponseDto;
import com.business.service.IProductService;
import com.common.grpc.ArchiveRequest;
import com.common.grpc.AssignCategoryRequest;
import com.common.grpc.IdRequest;
import com.common.grpc.PageProduct;
import com.common.grpc.ProductCreateRequest;
import com.common.grpc.ProductListRequest;
import com.common.grpc.ProductServiceGrpc;
import com.common.grpc.ProductStatus;
import com.common.grpc.ProductUpdateRequest;
import com.common.grpc.ProductView;
import com.common.grpc.PublishRequest;
import com.common.grpc.SlugRequest;
import com.common.grpc.UnassignCategoryRequest;
import com.common.grpc.UnpublishRequest;
import com.google.protobuf.Empty;
import io.grpc.stub.StreamObserver;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import net.devh.boot.grpc.server.service.GrpcService;
import org.common.exception.GrpcStatusMapper;
import org.common.http.Envelope;

import static com.business.constant.ProductStatus.ARCHIVED;
import static com.business.constant.ProductStatus.DRAFT;
import static com.business.constant.ProductStatus.PUBLISHED;
import static com.business.constant.ProductStatus.UNPUBLISHED;

@GrpcService
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class ProductGrpcServer extends ProductServiceGrpc.ProductServiceImplBase {
    IProductService productService;

    private ProductView map(ProductResponseDto d){
        return ProductView.newBuilder()
                .setId(d.getId())
                .setName(d.getName())
                .setSlug(d.getSlug())
                .setDescription(d.getDescription()==null?"":d.getDescription())
                .setStatus(ProductStatus.valueOf(d.getStatus().name()))
                .setBrandId(d.getBrandId()==null?"":d.getBrandId())
                .build();
    }

    private ProductStatus toGrpc(com.business.constant.ProductStatus s) {
        switch (s) {
            case PUBLISHED: return ProductStatus.PUBLISHED;
            case ARCHIVED:  return ProductStatus.ARCHIVED;
            case UNPUBLISHED: return ProductStatus.UNPUBLISHED;
            default: return ProductStatus.DRAFT;
        }
    }

    private com.business.constant.ProductStatus toDomain(ProductStatus s) {
        switch (s) {
            case ProductStatus.PUBLISHED:     return PUBLISHED;
            case ProductStatus.ARCHIVED: return ARCHIVED;
            case ProductStatus.UNPUBLISHED:  return UNPUBLISHED;
            default: return DRAFT;
        }
    }


    @Override
    public void create(
            ProductCreateRequest request,
            StreamObserver<Empty> responseObserver) {
        productService.create(ProductCreateRequestDto.builder()
                .name(request.getName())
                .slug(request.getSlug())
                .description(request.getDescription())
                .brandId(request.getBrandId().isBlank()
                        ? null
                        : request.getBrandId())
                .build());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void update(
            ProductUpdateRequest request,
            StreamObserver<Empty> responseObserver) {
        productService.update(
                request.getId(),
                ProductUpdateRequestDto.builder()
                    .name(request.getName())
                    .slug(request.getSlug())
                    .description(request.getDescription())
                    .brandId(request.getBrandId().isBlank()?null:request.getBrandId())
                    .build());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override public void softDelete(
            IdRequest request,
            StreamObserver<Empty> responseObserver){
        productService.softDelete(request.getId());
        GrpcStatusMapper.ok(responseObserver);
    }
    @Override public void restore(
            IdRequest request,
            StreamObserver<Empty> responseObserver){
        productService.restore(request.getId());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override public void publish(
            PublishRequest request,
            StreamObserver<Empty> responseObserver){
        productService.publish(request.getId());
        GrpcStatusMapper.ok(responseObserver);
    }
    @Override public void unpublish(
            UnpublishRequest request,
            StreamObserver<Empty> responseObserver){
        productService.unpublish(request.getId());
        GrpcStatusMapper.ok(responseObserver);
    }
    @Override public void archive(
            ArchiveRequest request,
            StreamObserver<Empty> responseObserver){
        productService.archive(request.getId());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void getById(
            IdRequest request,
            StreamObserver<ProductView> responseObserver) {
        GrpcStatusMapper.ok(responseObserver, map(productService.getById(request.getId())));
    }
    @Override
    public void getBySlug(
            SlugRequest request,
            StreamObserver<ProductView> responseObserver) {
        GrpcStatusMapper.ok(responseObserver, map(productService.getBySlug(request.getSlug())));
    }

    @Override
    public void list(
            ProductListRequest request,
            StreamObserver<PageProduct> responseObserver) {
        ProductStatus status = request.hasStatus()
                ? ProductStatus.valueOf(request.getStatus().name())
                : null;
        Envelope.Page<ProductResponseDto> page = productService.list(
                request.getQ(),
                request.getBrandId().isBlank()
                        ? null
                        : request.getBrandId(),
                request.getCategoryId().isBlank()
                        ? null
                        : request.getCategoryId(),
                toDomain(status), request.getPage(), request.getSize());

        PageProduct.Builder b = PageProduct.newBuilder()
                .setPage(page.getPage())
                .setSize(page.getSize())
                .setTotal(page.getTotal())
                .setTotalPages(page.getTotalPages());
        page.getDocs().forEach(d -> b.addDocs(map(d)));
        GrpcStatusMapper.ok(responseObserver, b.build());
    }

    @Override
    public void assignCategory(
            AssignCategoryRequest request,
            StreamObserver<Empty> responseObserver) {
        productService.assignCategory(request.getProductId(), request.getCategoryId());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void unassignCategory(
            UnassignCategoryRequest request,
            StreamObserver<Empty> responseObserver) {
        productService.unassignCategory(request.getProductId(), request.getCategoryId());
        GrpcStatusMapper.ok(responseObserver);
    }
}

package com.business.dto.model;

import com.business.dto.response.CategoryResponseDto;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.List;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CategoryTreeNode {
    CategoryResponseDto data;
    List<CategoryTreeNode> children;
}

package com.business.dto.request;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class BrandCreateRequestDto {
    String name;
    String slug;
    String description;
}

package com.business.dto.request;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class BrandUpdateRequestDto {
    String name;
    String slug;
    String description;
}

package com.business.dto.request;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CategoryCreateRequestDto {
    String name;
    String slug;
    String description;
    String parentId;
}

package com.business.dto.request;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CategoryUpdateRequestDto {
    String name;
    String slug;
    String description;
}

package com.business.dto.request;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ProductCreateRequestDto {
    String name;
    String slug;
    String description;
    String brandId;
}

package com.business.dto.request;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ProductUpdateRequestDto {
    String name;
    String slug;
    String description;
    String brandId;
}

package com.business.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class BrandResponseDto {
    String id;
    String name;
    String slug;
    String description;
}

package com.business.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CategoryResponseDto {
    String id;
    String name;
    String slug;
    String description;
    String parentId;
}

package com.business.dto.response;

import com.business.constant.ProductStatus;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ProductResponseDto {
    String id;
    String name;
    String slug;
    String description;
    ProductStatus status;
    String brandId;
}

package com.business.exception;

import lombok.extern.slf4j.Slf4j;
import org.common.exception.AppException;
import org.common.exception.ErrorCode;
import org.common.http.Envelope;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

@Slf4j
@ControllerAdvice
@ConditionalOnProperty(
        name = "core.http.error.enabled",
        havingValue = "true",
        matchIfMissing = false
)
public class GlobalExceptionHandler {

    @ExceptionHandler(AppException.class)
    public ResponseEntity<Envelope<Void>> handleAppException(
            AppException appException){
        ErrorCode errorCode = appException.getErrorCode();
        return ResponseEntity.status(errorCode.getStatusCode())
                .body(Envelope.err(
                        errorCode.http(),
                        errorCode.name(),
                        errorCode.getMessage(),
                        null)
                );
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Envelope<Void>> handleAnyException(
            Exception exception){
        ErrorCode errorCode = ErrorCode.UNCATEGORIZED_EXCEPTION;
        return ResponseEntity.status(errorCode.getStatusCode())
                .body(Envelope.err(
                        errorCode.http(),
                        errorCode.name(),
                        errorCode.getMessage(),
                        null)
                );
    }
}

package com.business.helper;

import lombok.experimental.UtilityClass;
import org.common.exception.AppException;
import org.common.exception.ErrorCode;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;

import java.util.Set;
import java.util.stream.Collectors;

@UtilityClass
public class AuthenticationHelper {
    public String getMyUserId() {
        Authentication a = SecurityContextHolder.getContext().getAuthentication();
        if (a == null || a.getName() == null) throw new AppException(ErrorCode.UNAUTHENTICATED);
        return a.getName();
    }

    public Set<String> getMyRoles() {
        Authentication a = SecurityContextHolder.getContext().getAuthentication();
        if (a == null) throw new AppException(ErrorCode.UNAUTHENTICATED);
        return a.getAuthorities()
                .stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.toSet());
    }

    public void requireAdmin() {
        if (!getMyRoles().contains("ROLE_ADMIN") && !getMyRoles().contains("ADMIN")) {
            throw new AppException(ErrorCode.UNAUTHORIZED);
        }
    }
}

package com.business.mapper;

import com.business.dto.request.BrandCreateRequestDto;
import com.business.dto.request.BrandUpdateRequestDto;
import com.business.dto.response.BrandResponseDto;
import com.business.entity.Brand;
import org.mapstruct.Mapper;
import org.mapstruct.MappingTarget;
import org.mapstruct.NullValuePropertyMappingStrategy;
import org.mapstruct.ReportingPolicy;

@Mapper(componentModel = "spring",
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public interface BrandMapper {
    Brand toBrandFromBrandCreateRequestDto(
            BrandCreateRequestDto brandCreateRequestDto);

    void patchBrandFromBrandUpdateRequestDto(
            @MappingTarget Brand brand,
            BrandUpdateRequestDto brandUpdateRequestDto
    );

    BrandResponseDto toBrandResponseDtoFromBrand(
            Brand brand
    );
}

package com.business.mapper;

import com.business.dto.request.CategoryCreateRequestDto;
import com.business.dto.request.CategoryUpdateRequestDto;
import com.business.dto.response.CategoryResponseDto;
import com.business.entity.Category;
import org.mapstruct.Mapper;
import org.mapstruct.MappingTarget;
import org.mapstruct.NullValuePropertyMappingStrategy;
import org.mapstruct.ReportingPolicy;

@Mapper(componentModel = "spring",
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public interface CategoryMapper {
    Category toCategoryFromCategoryCreateRequestDto(
            CategoryCreateRequestDto categoryCreateRequestDto);
    void patchCategoryFromCategoryUpdateRequestDto(
            @MappingTarget Category category,
            CategoryUpdateRequestDto categoryUpdateRequestDto
    );
    CategoryResponseDto toCategoryResponseDtoFromCategory(
            Category category);
}

package com.business.mapper;

import com.business.dto.request.ProductCreateRequestDto;
import com.business.dto.request.ProductUpdateRequestDto;
import com.business.dto.response.ProductResponseDto;
import com.business.entity.Product;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.NullValuePropertyMappingStrategy;
import org.mapstruct.ReportingPolicy;

@Mapper(
        componentModel = "spring",
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE
)
public interface ProductMapper {
    Product toProductFromProductCreateRequestDto(
            ProductCreateRequestDto productCreateRequestDto);
    void patchProductFromProductUpdateRequestDto(
            @MappingTarget Product target,
            ProductUpdateRequestDto dto
    );
    @Mapping(source = "brand.id", target = "brandId")
    ProductResponseDto toProductResponseDtoFromProduct(
            Product product);
}

package com.business.repository;

import com.business.entity.Brand; // entity sẵn có
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.*;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface BrandsRepository
        extends JpaRepository<Brand, String> {

    Optional<Brand> findBySlug(String slug);

    @Query(value = """
       update brands
          set deleted_at = null, deleted_by = null
        where id = :id
       """, nativeQuery = true)
    @Modifying
    int nativeRestore(@Param("id") String id);

    @Query(value = """
        select b from Brand b
         where ( :q is null or :q = ''
                 or lower(b.name) like lower(concat('%', :q, '%'))
                 or lower(b.slug) like lower(concat('%', :q, '%')) )
        order by b.createdAt desc
       """)
    Page<Brand> search(@Param("q") String q, Pageable pageable);
}


package com.business.repository;

import com.business.entity.Category;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.*;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface CategoriesRepository
        extends JpaRepository<Category, String> {

    Optional<Category> findBySlug(String slug);

    @Query(value = """
       update categories
          set deleted_at = null, deleted_by = null
        where id = :id
       """, nativeQuery = true)
    @Modifying
    int nativeRestore(@Param("id") String id);

    @Query("""
        select c from Category c
         where (:q is null or :q = ''
               or lower(c.name) like lower(concat('%', :q, '%'))
               or lower(c.slug) like lower(concat('%', :q, '%')) )
         order by c.createdAt desc
    """)
    Page<Category> search(@Param("q") String q, Pageable pageable);


    List<Category> findByParentIdOrderByNameAsc(String parentId);
}


package com.business.repository;

import com.business.entity.ProductCategory;
import org.springframework.data.jpa.repository.*;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

@Repository
public interface ProductCategoriesRepository
        extends JpaRepository<ProductCategory, String> {

    @Query("""
      select count(pc) > 0 from ProductCategory pc
       where pc.product.id = :productId and pc.category.id = :categoryId
    """)
    boolean existsLink(
            @Param("productId") String productId,
            @Param("categoryId") String categoryId
    );

    @Modifying
    @Query("""
      delete from ProductCategory pc
       where pc.product.id = :productId and pc.category.id = :categoryId
    """)
    int deleteLink(
            @Param("productId") String productId,
            @Param("categoryId") String categoryId
    );
}

package com.business.repository;

import com.business.constant.ProductStatus;
import com.business.entity.Product;
import org.springframework.data.jpa.repository.*;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import org.springframework.data.domain.*;

import java.util.Optional;

@Repository
public interface ProductsRepository
        extends JpaRepository<Product, String> {

    Optional<Product> findBySlug(String slug);

    @Query(value = """
       update products
          set deleted_at = null, deleted_by = null
        where id = :id
       """, nativeQuery = true)
    @Modifying
    int nativeRestore(@Param("id") String id);

    @Query("""
      select p from Product p
       left join ProductCategory pc on pc.product.id = p.id
      where (:q is null or :q = ''
             or lower(p.name) like lower(concat('%', :q, '%'))
             or lower(p.slug) like lower(concat('%', :q, '%'))
             or lower(p.description) like lower(concat('%', :q, '%')))
        and (:brandId is null or :brandId = '' or p.brand.id = :brandId)
        and (:categoryId is null or :categoryId = '' or pc.category.id = :categoryId)
        and (:status is null or p.status = :status)
      group by p
      order by p.createdAt desc
    """)
    Page<Product> filter(
            @Param("q") String q,
            @Param("brandId") String brandId,
            @Param("categoryId") String categoryId,
            @Param("status") ProductStatus status,
            Pageable pageable);
}

package com.business.service.impl;

import com.business.dto.request.BrandCreateRequestDto;
import com.business.dto.request.BrandUpdateRequestDto;
import com.business.dto.response.BrandResponseDto;
import com.business.entity.Brand;
import com.business.helper.AuthenticationHelper;
import com.business.mapper.BrandMapper;
import com.business.repository.BrandsRepository;
import com.business.service.IBrandService;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import org.common.exception.AppException;
import org.common.exception.ErrorCode;
import org.common.http.Envelope;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class BrandServiceImpl implements IBrandService {

    BrandsRepository brandsRepository;
    BrandMapper brandMapper;

    @Override @Transactional
    public void create(BrandCreateRequestDto brandCreateRequestDto) {
        Brand b = brandMapper.toBrandFromBrandCreateRequestDto(
                brandCreateRequestDto);
        brandsRepository.save(b);
    }

    @Override @Transactional
    public void update(
            String id,
            BrandUpdateRequestDto brandUpdateRequestDto) {
        Brand b = brandsRepository.findById(id)
                .orElseThrow(() -> new AppException(ErrorCode.BRAND_NOT_FOUND));
        brandMapper.patchBrandFromBrandUpdateRequestDto(b, brandUpdateRequestDto);
        brandsRepository.save(b);
    }

    @Override
    @Transactional
    public void softDelete(String id) {
        Brand b = brandsRepository.findById(id)
                .orElseThrow(() -> new AppException(ErrorCode.BRAND_NOT_FOUND));
        b.markDeleted(AuthenticationHelper.getMyUserId());
        brandsRepository.save(b);
    }

    @Override
    @Transactional
    public void restore(String id) {
        brandsRepository.findById(id)
                .orElseThrow(() -> new AppException(ErrorCode.BRAND_NOT_FOUND));
        int n = brandsRepository.nativeRestore(id);
        if (n == 0) {
            throw new AppException(ErrorCode.BRAND_NOT_FOUND);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public BrandResponseDto getById(String id) {
        return brandsRepository.findById(id)
                .map(brandMapper::toBrandResponseDtoFromBrand)
                .orElseThrow(() -> new AppException(ErrorCode.BRAND_NOT_FOUND));
    }

    @Override
    @Transactional(readOnly = true)
    public BrandResponseDto getBySlug(String slug) {
        return brandsRepository.findBySlug(slug)
                .map(brandMapper::toBrandResponseDtoFromBrand)
                .orElseThrow(() -> new AppException(ErrorCode.BRAND_NOT_FOUND));
    }

    @Override @Transactional(readOnly = true)
    public Envelope.Page<BrandResponseDto> list(
            String q,
            int page, int size) {
        Page<Brand> p = brandsRepository.search(q, PageRequest.of(page, size));
        return Envelope.Page.<BrandResponseDto>builder()
                .page(page)
                .size(size)
                .total(p.getTotalElements())
                .totalPages(Math.max(1, p.getTotalPages()))
                .docs(p.map(brandMapper::toBrandResponseDtoFromBrand).getContent())
                .build();
    }
}


package com.business.service.impl;

import com.business.dto.request.CategoryCreateRequestDto;
import com.business.dto.request.CategoryUpdateRequestDto;
import com.business.dto.response.CategoryResponseDto;
import com.business.entity.Category;
import com.business.helper.AuthenticationHelper;
import com.business.mapper.CategoryMapper;
import com.business.repository.CategoriesRepository;
import com.business.service.ICategoryService;
import com.business.dto.model.CategoryTreeNode;
import lombok.*;
import lombok.experimental.FieldDefaults;
import org.common.exception.AppException;
import org.common.exception.ErrorCode;
import org.common.http.Envelope;
import org.springframework.data.domain.*;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class CategoryServiceImpl implements ICategoryService {

    CategoriesRepository categoriesRepository;
    CategoryMapper categoryMapper;

    @Override
    @Transactional
    public void create(CategoryCreateRequestDto categoryCreateRequestDto) {
        Category c = categoryMapper.toCategoryFromCategoryCreateRequestDto(
                categoryCreateRequestDto);
        if (categoryCreateRequestDto.getParentId() != null
                && !categoryCreateRequestDto.getParentId().isBlank()) {
            categoriesRepository.findById(categoryCreateRequestDto.getParentId())
                    .orElseThrow(() -> new AppException(ErrorCode.CATEGORY_NOT_FOUND));
            c.getParent().setId(categoryCreateRequestDto.getParentId());
        } else {
            c.getParent().setId(null);
        }
        categoriesRepository.save(c);
    }

    @Override
    @Transactional
    public void update(
            String id,
            CategoryUpdateRequestDto categoryUpdateRequestDto) {
        Category c = categoriesRepository.findById(id)
                .orElseThrow(() -> new AppException(ErrorCode.CATEGORY_NOT_FOUND));
        categoryMapper.patchCategoryFromCategoryUpdateRequestDto(c,
                categoryUpdateRequestDto);
        categoriesRepository.save(c);
    }

    @Override
    @Transactional
    public void softDelete(String id) {
        Category c = categoriesRepository.findById(id)
                .orElseThrow(() -> new AppException(ErrorCode.CATEGORY_NOT_FOUND));
        c.markDeleted(AuthenticationHelper.getMyUserId());
        categoriesRepository.save(c);
    }

    @Override
    @Transactional
    public void restore(String id) {
        categoriesRepository.findById(id)
                .orElseThrow(() -> new AppException(ErrorCode.CATEGORY_NOT_FOUND));
        int n = categoriesRepository.nativeRestore(id);
        if (n == 0) {
            throw new AppException(ErrorCode.CATEGORY_NOT_FOUND);
        }
    }

    @Override
    @Transactional
    public void reparent(String id, String newParentId) {
        Category c = categoriesRepository.findById(id)
                .orElseThrow(() -> new AppException(ErrorCode.CATEGORY_NOT_FOUND));
        if (newParentId == null || newParentId.isBlank()) {
            c.getParent().setId(null);
        } else {
            categoriesRepository.findById(newParentId)
                    .orElseThrow(() -> new AppException(ErrorCode.CATEGORY_NOT_FOUND));
            c.getParent().setId(newParentId);
        }
        categoriesRepository.save(c);
    }

    @Override
    @Transactional(readOnly = true)
    public CategoryResponseDto getById(String id) {
        return categoriesRepository.findById(id)
                .map(categoryMapper::toCategoryResponseDtoFromCategory)
                .orElseThrow(() -> new AppException(ErrorCode.CATEGORY_NOT_FOUND));
    }

    @Override
    @Transactional(readOnly = true)
    public CategoryResponseDto getBySlug(String slug) {
        return categoriesRepository.findBySlug(slug)
                .map(categoryMapper::toCategoryResponseDtoFromCategory)
                .orElseThrow(() -> new AppException(ErrorCode.CATEGORY_NOT_FOUND));
    }

    @Override
    @Transactional(readOnly = true)
    public Envelope.Page<CategoryResponseDto> list(
            String q,
            int page, int size) {
        Page<Category> p = categoriesRepository.search(q, PageRequest.of(page, size));
        return Envelope.Page.<CategoryResponseDto>builder()
                .page(page)
                .size(size)
                .total(p.getTotalElements())
                .totalPages(Math.max(1, p.getTotalPages()))
                .docs(p.map(categoryMapper::toCategoryResponseDtoFromCategory).getContent())
                .build();
    }

    @Override
    @Transactional(readOnly = true)
    public CategoryTreeNode tree() {
        List<Category> all = categoriesRepository.findAll(Sort.by("name")
                .ascending());
        Map<String, List<Category>> byParent = all.stream()
                .collect(Collectors.groupingBy(c -> Optional.ofNullable(c.getParent().getId())
                        .orElse("ROOT")));

        return CategoryTreeNode.builder()
                .data(null)
                .children(buildChildren("ROOT", byParent))
                .build();
    }

    private List<CategoryTreeNode> buildChildren(
            String parentKey,
            Map<String,List<Category>> byParent){
        return byParent.getOrDefault(parentKey, List.of())
                .stream()
                .map(c -> CategoryTreeNode.builder()
                        .data(categoryMapper.toCategoryResponseDtoFromCategory(c))
                        .children(buildChildren(c.getId(), byParent))
                        .build())
                .toList();
    }

    @Override
    @Transactional(readOnly = true)
    public Envelope.Page<CategoryResponseDto> children(
            String id,
            int page, int size) {
        String parent = (id == null || id.isBlank())
                ? null
                : id;
        List<CategoryResponseDto> docs = categoriesRepository
                .findByParentIdOrderByNameAsc(parent)
                .stream()
                .map(categoryMapper::toCategoryResponseDtoFromCategory)
                .toList();
        int total = docs.size();
        int from = Math.min(page*size, total);
        int to = Math.min(from+size, total);
        return Envelope.Page.<CategoryResponseDto>builder()
                .page(page)
                .size(size)
                .total(total)
                .totalPages((int)Math.max(1, Math.ceil(total/(double)size)))
                .docs(docs.subList(from, to))
                .build();
    }
}

package com.business.service.impl;

import com.business.constant.ProductStatus;
import com.business.dto.request.ProductCreateRequestDto;
import com.business.dto.request.ProductUpdateRequestDto;
import com.business.dto.response.ProductResponseDto;
import com.business.entity.*;
import com.business.helper.AuthenticationHelper;
import com.business.mapper.ProductMapper;
import com.business.repository.*;
import com.business.service.IProductService;
import lombok.*;
import lombok.experimental.FieldDefaults;
import org.common.exception.AppException;
import org.common.exception.ErrorCode;
import org.common.http.Envelope;
import org.springframework.data.domain.*;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class ProductServiceImpl implements IProductService {

    ProductsRepository productsRepository;
    BrandsRepository brandsRepository;
    CategoriesRepository categoriesRepository;
    ProductCategoriesRepository productCategoriesRepository;
    ProductMapper productMapper;

    @Override
    @Transactional
    public void create(ProductCreateRequestDto productCreateRequestDto) {
        Product p = productMapper.toProductFromProductCreateRequestDto(
                productCreateRequestDto);
        if (productCreateRequestDto.getBrandId() != null
                && !productCreateRequestDto.getBrandId().isBlank()) {
            Brand b = brandsRepository.findById(productCreateRequestDto.getBrandId())
                    .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
            p.setBrand(b);
        } else p.setBrand(null);
        p.setStatus(ProductStatus.DRAFT);
        productsRepository.save(p);
    }

    @Override
    @Transactional
    public void update(
            String id,
            ProductUpdateRequestDto productUpdateRequestDto) {
        Product p = productsRepository.findById(id)
                .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
        productMapper.patchProductFromProductUpdateRequestDto(p,
                productUpdateRequestDto);
        if (productUpdateRequestDto.getBrandId()!=null) {
            if (productUpdateRequestDto.getBrandId().isBlank()) {
                p.setBrand(null);
            } else {
                Brand b = brandsRepository.findById(productUpdateRequestDto.getBrandId())
                        .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
                p.setBrand(b);
            }
        }
        productsRepository.save(p);
    }

    @Override
    @Transactional
    public void softDelete(String id) {
        Product p = productsRepository.findById(id)
                .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
        p.markDeleted(AuthenticationHelper.getMyUserId());
        productsRepository.save(p);
    }

    @Override
    @Transactional
    public void restore(String id) {
        productsRepository.findById(id)
                .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
        int n = productsRepository.nativeRestore(id);
        if (n == 0) {
            throw new AppException(ErrorCode.PRODUCT_NOT_FOUND);
        }
    }

    @Override
    @Transactional
    public void publish(String id) {
        Product p = productsRepository.findById(id)
                .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
        p.setStatus(ProductStatus.PUBLISHED);
        productsRepository.save(p);
    }

    @Override
    @Transactional
    public void unpublish(String id) {
        Product p = productsRepository.findById(id)
                .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
        p.setStatus(ProductStatus.UNPUBLISHED);
        productsRepository.save(p);
    }

    @Override
    @Transactional
    public void archive(String id) {
        Product p = productsRepository.findById(id)
                .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
        p.setStatus(ProductStatus.ARCHIVED);
        productsRepository.save(p);
    }

    @Override
    @Transactional(readOnly = true)
    public ProductResponseDto getById(String id) {
        return productsRepository.findById(id)
                .map(productMapper::toProductResponseDtoFromProduct)
                .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
    }

    @Override
    @Transactional(readOnly = true)
    public ProductResponseDto getBySlug(String slug) {
        return productsRepository.findBySlug(slug)
                .map(productMapper::toProductResponseDtoFromProduct)
                .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
    }

    @Override
    @Transactional(readOnly = true)
    public Envelope.Page<ProductResponseDto> list(
            String q,
            String brandId, String categoryId,
            ProductStatus status, int page, int size) {
        Page<Product> p = productsRepository.filter(
                q,
                brandId,
                categoryId,
                status,
                PageRequest.of(page, size)
        );
        return Envelope.Page.<ProductResponseDto>builder()
                .page(page)
                .size(size)
                .total(p.getTotalElements())
                .totalPages(Math.max(1, p.getTotalPages()))
                .docs(p.map(productMapper::toProductResponseDtoFromProduct).getContent())
                .build();
    }

    @Override
    @Transactional
    public void assignCategory(String productId, String categoryId) {
        Product p = productsRepository.findById(productId)
                .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
        Category c = categoriesRepository.findById(categoryId)
                .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));

        if (!productCategoriesRepository.existsLink(productId, categoryId)) {
            ProductCategory link = new ProductCategory();
            link.setProduct(p);
            link.setCategory(c);
            productCategoriesRepository.save(link);
        }
    }

    @Override
    @Transactional
    public void unassignCategory(String productId, String categoryId) {
        productsRepository.findById(productId)
                .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
        categoriesRepository.findById(categoryId)
                .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
        productCategoriesRepository.deleteLink(productId, categoryId);
    }
}

package com.business.service;

import com.business.dto.request.BrandCreateRequestDto;
import com.business.dto.request.BrandUpdateRequestDto;
import com.business.dto.response.BrandResponseDto;
import org.common.http.Envelope;

public interface IBrandService {
    void create(BrandCreateRequestDto brandCreateRequestDto);

    void update(String id, BrandUpdateRequestDto brandUpdateRequestDto);

    void softDelete(String id);

    void restore(String id);

    BrandResponseDto getById(String id);

    BrandResponseDto getBySlug(String slug);

    Envelope.Page<BrandResponseDto> list(
            String q,
            int page, int size
    );
}

package com.business.service;

import com.business.dto.model.CategoryTreeNode;
import com.business.dto.request.CategoryCreateRequestDto;
import com.business.dto.request.CategoryUpdateRequestDto;
import com.business.dto.response.CategoryResponseDto;
import org.common.http.Envelope;

public interface ICategoryService {
    void create(CategoryCreateRequestDto categoryCreateRequestDto);

    void update(
            String id,
            CategoryUpdateRequestDto categoryUpdateRequestDto
    );

    void softDelete(String id);

    void restore(String id);

    void reparent(String id, String newParentId);

    CategoryResponseDto getById(String id);

    CategoryResponseDto getBySlug(String slug);

    Envelope.Page<CategoryResponseDto> list(
            String q,
            int page, int size
    );

    // tree/children
    CategoryTreeNode tree();

    Envelope.Page<CategoryResponseDto> children(
            String id,
            int page, int size
    );
}

package com.business.service;

import com.business.constant.ProductStatus;
import com.business.dto.request.ProductCreateRequestDto;
import com.business.dto.request.ProductUpdateRequestDto;
import com.business.dto.response.ProductResponseDto;
import org.common.http.Envelope;

public interface IProductService {
    void create(ProductCreateRequestDto productCreateRequestDto);

    void update(
            String id,
            ProductUpdateRequestDto productUpdateRequestDto
    );

    void softDelete(String id);

    void restore(String id);

    void publish(String id);

    void unpublish(String id);

    void archive(String id);

    ProductResponseDto getById(String id);

    ProductResponseDto getBySlug(String slug);

    Envelope.Page<ProductResponseDto> list(
            String q,
            String brandId,
            String categoryId,
            ProductStatus status,
            int page, int size);

    void assignCategory(String productId, String categoryId);

    void unassignCategory(String productId, String categoryId);
}


server:
  port: 8094

spring:
  application:
    name: "business-ms"
  profiles:
    active: "dev"
  datasource:
    url: jdbc:h2:mem:testdb
    driverClassName: org.h2.Driver
    username: sa
    password: ''
  #    url: jdbc:postgresql://localhost:5431/identity_db
  #    username: postgres_identity
  #    password: dinhanst2832004
  #    driver-class-name: org.postgresql.Driver
  h2:
    console:
      enabled: true
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: update
    show-sql: true
  config:
    import: "optional:configserver:http://localhost:8091/"
  cloud:
    openfeign:
      circuitbreaker:
        enabled: true

app:
  jwt:
    signerKey: "1TjXchw5FloESb63Kc+DFhTARvpWL4jUGCwfGWxuG5SIf/1y/LgJxHnMqaF6A/ij"

management:
  endpoints:
    web:
      exposure:
        include: "*"
  health:
    readiness-state:
      enabled: true
    liveness-state:
      enabled: true
  endpoint:
    shutdown:
      access: unrestricted
    health:
      probes:
        enabled: true
  info:
    env:
      enabled: true

eureka:
  instance:
    preferIpAddress: true
  client:
    fetchRegistry: true
    registerWithEureka: true
    serviceUrl:
      defaultZone: http://localhost:8090/eureka/

info:
  app:
    name: "business-ms"
    description: "Yunomi Xavia Business Project"
    version: "1.0.0"

logging:
  level:
    com:
      demo: DEBUG

resilience4j.circuitbreaker:
  configs:
    default:
      slidingWindowSize: 10
      permittedNumberOfCallsInHalfOpenState: 2
      failureRateThreshold: 50
      waitDurationInOpenState: 10000

resilience4j.retry:
  configs:
    default:
      maxAttempts: 3
      waitDuration: 500
      enableExponentialBackoff: true
      exponentialBackoffMultiplier: 2
      ignoreExceptions:
        - java.lang.NullPointerException
      retryExceptions:
        - java.util.concurrent.TimeoutException

resilience4j.ratelimiter:
  configs:
    default:
      timeoutDuration: 1000
      limitRefreshPeriod: 5000
      limitForPeriod: 1
