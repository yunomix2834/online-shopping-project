(Không dùng Canvas) Bạn có thể code để thực hiện toàn bộ các chức năng sau được không (Ở business-service, service riêng khác với core-service)

- Chia các proto riêng ra theo từng chức năng
- Sử dụng dto request, response với các api create, update, patch thì trả ra void. Để format giống với core-service và ở gateway, những dto ở trong service thì kết thúc có "Dto", những dto request ở gateway thì có "Body", response ở gateway thì có "View", là class hay record và có các annotation theo đúng format đã có từ trước
- Map bằng mapstruct (có đặt tên mapper giống với format)
- với các phương tức delete, không dùng repository.delete() mà mark delete, với restore thì dùng native query không thì không query được vì entity theo @Where
- controller ở gateway thì thêm cả consumer và producer
- Sửa để có thêm quản trị theo Role (requireAdmin)

- Không sửa các entity, query dùng bảng trung gian
Code tiếp các controller ở gateway của cart và order

common.
order.proto
syntax = "proto3";
package onlineshopping.v1;
option java_multiple_files = true;
option java_package = "com.common.grpc";
option java_outer_classname = "OrderProto";
import "google/protobuf/empty.proto";
import "common.proto";

enum OrderStatusGrpc {
  PENDING=0;
  PROCESSING=1;
  SHIPPED=2;
  COMPLETED=3;
  CANCELLED=4;
}

message OrderItemView {
  string id=1;
  string variant_id=2;
  string sku=3;
  string product_name=4;
  string price=5;
  int32 quantity=6;
  string line_total=7;
}
message OrderView {
  string id=1;
  string user_id=2;
  OrderStatusGrpc status=3;
  string subtotal=4;
  string discount_amount=5;
  string shipping_fee=6;
  string total_amount=7;
  string shipping_address=8;
  string billing_address=9;
  string payment_method_name=10;
  string shipping_method_name=11;
  string discount_code=12;
  repeated OrderItemView items=13;
  string created_at=14;
}
message OrderListRequest {
  string user_id=1;
  string status=2;
  string date_from=3;
  string date_to=4;
  int32 page=5;
  int32 size=6;
}
message PageOrder {
  int32 page=1;
  int32 size=2;
  int64 total=3;
  int32 total_pages=4;
  repeated OrderView docs=5;
}

message CreateOrderFromCartRequest {
  string user_id=1;
  string shipping_address=2;
  string billing_address=3;
  string payment_method_name=4;
  string shipping_method_name=5;
  string discount_code=6;
}
message CreateOrderDirectRequest {
  string user_id=1;
  string shipping_address=2;
  string billing_address=3;
  string payment_method_name=4;
  string shipping_method_name=5;
  string discount_code=6;
  repeated DirectLine lines=7;
  message DirectLine {
    string variant_id=1;
    int32 quantity=2;
  }
}
message OrderIdRequest {
  string id=1;
}
message OrderUpdateStatusRequest {
  string id=1;
  OrderStatusGrpc status=2;
}
message OrderCancelRequest {
  string id=1;
}
message OrderPatchChargesRequest {
  string id=1;
  string shipping_fee=2;
  string payment_method_name=3;
  string shipping_method_name=4;
}
message OrderApplyOrSwapCodeRequest {
  string id=1;
  string discount_code=2;
}

service OrderService {
  rpc CreateFromCart(CreateOrderFromCartRequest) returns (OrderView);
  rpc CreateDirect(CreateOrderDirectRequest) returns (OrderView);
  rpc GetDetail(OrderIdRequest) returns (OrderView);
  rpc List(OrderListRequest) returns (PageOrder);
  rpc UpdateStatus(OrderUpdateStatusRequest) returns (google.protobuf.Empty);
  rpc Cancel(OrderCancelRequest) returns (google.protobuf.Empty);
  rpc PatchCharges(OrderPatchChargesRequest) returns (google.protobuf.Empty);
  rpc ApplyOrSwapCode(OrderApplyOrSwapCodeRequest) returns (google.protobuf.Empty);
}

cart.proto
syntax = "proto3";
package onlineshopping.v1;
option java_multiple_files = true;
option java_package = "com.common.grpc";
option java_outer_classname = "CartProto";
import "google/protobuf/empty.proto";
import "common.proto";

message CartGetOrCreateRequest {
  string user_id = 1;
}
message CartView {
  string user_id = 1;
  repeated CartItemView items = 2;
  string subtotal = 3;
  string discount_amount = 4;
  string shipping_fee = 5;
  string total = 6;
}
message CartItemView {
  string id = 1;
  string variant_id = 2;
  string sku = 3;
  string product_name = 4;
  string price = 5;
  int32 quantity = 6;
  string line_total = 7;
}
message CartAddItemRequest {
  string user_id = 1;
  string variant_id = 2;
  int32 quantity = 3;
}
message CartUpdateQtyRequest {
  string cart_item_id = 1;
  int32 quantity = 2;
}
message CartRemoveItemRequest {
  string cart_item_id = 1;
}
message CartClearRequest {
  string user_id = 1;
}
message CartListRequest {
  string user_id = 1;
}
message CartApplyCodeRequest {
  string user_id = 1;
  string code = 2;
  string at = 3;
}
message CartMergeRequest {
  string from_user_id = 1;
  string to_user_id = 2;
}

service CartService {
  rpc GetOrCreate(CartGetOrCreateRequest) returns (CartView);
  rpc AddItem(CartAddItemRequest) returns (google.protobuf.Empty);
  rpc UpdateQty(CartUpdateQtyRequest) returns (google.protobuf.Empty);
  rpc RemoveItem(CartRemoveItemRequest) returns (google.protobuf.Empty);
  rpc Clear(CartClearRequest) returns (google.protobuf.Empty);
  rpc List(CartListRequest) returns (CartView);
  rpc ApplyCode(CartApplyCodeRequest) returns (CartView);
  rpc Merge(CartMergeRequest) returns (google.protobuf.Empty);
}



common.proto
syntax = "proto3";

package onlineshopping.v1;
option java_package = "com.common.grpc";

option java_multiple_files = true;

message IdRequest {
  string id = 1;
}

message SlugRequest {
  string slug = 1;
}

attribute.proto
syntax = "proto3";
package onlineshopping.v1;
option java_multiple_files = true;
option java_package = "com.common.grpc";
option java_outer_classname = "AttributeProto";
import "google/protobuf/empty.proto";
import "common.proto";

message AttributeCreateRequest {
  string name = 1;
  string value = 2;
}
message AttributeView {
  string id = 1;
  string name = 2;
  string value = 3;
}
message AttributeListRequest {
  string q = 1;
  int32 page = 2;
  int32 size = 3;
}
message PageAttribute {
  int32 page = 1;
  int32 size = 2;
  int64 total = 3;
  int32 total_pages = 4;
  repeated AttributeView docs = 5;
}

message VariantAttributeAssignRequest {
  string variant_id = 1;
  string attribute_id = 2;
}
message VariantIdRequest {
  string variant_id = 1;
  int32 page = 2;
  int32 size = 3;
}

service AttributeService {
  rpc Create(AttributeCreateRequest) returns (google.protobuf.Empty);
  rpc SoftDelete(IdRequest) returns (google.protobuf.Empty);
  rpc Restore(IdRequest) returns (google.protobuf.Empty);

  rpc List(AttributeListRequest) returns (PageAttribute);

  rpc AssignToVariant(VariantAttributeAssignRequest) returns (google.protobuf.Empty);
  rpc UnassignFromVariant(VariantAttributeAssignRequest) returns (google.protobuf.Empty);
  rpc ListByVariant(VariantIdRequest) returns (PageAttribute);
}

brand.proto
syntax = "proto3";
package onlineshopping.v1;
option java_multiple_files = true;
option java_package = "com.common.grpc";
option java_outer_classname = "BrandProto";
import "google/protobuf/empty.proto";

import "common.proto";

message BrandCreateRequest {
  string name = 1;
  string slug = 2;
  string description = 3;
}
message BrandUpdateRequest {
  string id = 1;            // cập nhật theo id
  string name = 2;
  string slug = 3;
  string description = 4;
}

message BrandView {
  string id = 1;
  string name = 2;
  string slug = 3;
  string description = 4;
}

message BrandListRequest {
  string q = 1;         // search theo name/slug
  int32 page = 2;
  int32 size = 3;
}
message PageBrand {
  int32 page = 1;
  int32 size = 2;
  int64 total = 3;
  int32 total_pages = 4;
  repeated BrandView docs = 5;
}

service BrandService {
  rpc Create(BrandCreateRequest) returns (google.protobuf.Empty);
  rpc Update(BrandUpdateRequest) returns (google.protobuf.Empty);
  rpc SoftDelete(IdRequest) returns (google.protobuf.Empty);
  rpc Restore(IdRequest) returns (google.protobuf.Empty);

  rpc GetById(IdRequest) returns (BrandView);
  rpc GetBySlug(SlugRequest) returns (BrandView);
  rpc List(BrandListRequest) returns (PageBrand);
}


category.proto
syntax = "proto3";
package onlineshopping.v1;
option java_multiple_files = true;
option java_package = "com.common.grpc";
option java_outer_classname = "CategoryProto";
import "google/protobuf/empty.proto";

import "common.proto";

message CategoryCreateRequest {
  string name = 1;
  string slug = 2;
  string description = 3;
  string parent_id = 4;   // optional
}
message CategoryUpdateRequest {
  string id = 1;
  string name = 2;
  string slug = 3;
  string description = 4;
}
message CategoryReparentRequest {
  string id = 1;
  string new_parent_id = 2; // null/empty => lên root
}

message CategoryView {
  string id = 1;
  string name = 2;
  string slug = 3;
  string description = 4;
  string parent_id = 5;
}

message CategoryListRequest {
  string q = 1;   // search theo name/slug
  int32 page = 2;
  int32 size = 3;
}
message PageCategory {
  int32 page = 1;
  int32 size = 2;
  int64 total = 3;
  int32 total_pages = 4;
  repeated CategoryView docs = 5;
}

message CategoryTreeNode {
  CategoryView data = 1;
  repeated CategoryTreeNode children = 2;
}

message CategoryChildrenRequest {
  string id = 1;     // lấy children của node (id = null -> root level)
}
message CategoryProductsRequest {
  string category_id = 1;
  int32 page = 2;
  int32 size = 3;
}

service CategoryService {
  rpc Create(CategoryCreateRequest) returns (google.protobuf.Empty);
  rpc Update(CategoryUpdateRequest) returns (google.protobuf.Empty);
  rpc SoftDelete(IdRequest) returns (google.protobuf.Empty);
  rpc Restore(IdRequest) returns (google.protobuf.Empty);
  rpc Reparent(CategoryReparentRequest) returns (google.protobuf.Empty);

  rpc GetById(IdRequest) returns (CategoryView);
  rpc GetBySlug(SlugRequest) returns (CategoryView);
  rpc List(CategoryListRequest) returns (PageCategory);

  rpc Tree(google.protobuf.Empty) returns (CategoryTreeNode);  // full tree
  rpc Children(CategoryChildrenRequest) returns (PageCategory); // 1 cấp con
}

discount.proto
syntax = "proto3";
package onlineshopping.v1;
option java_multiple_files = true;
option java_package = "com.common.grpc";
option java_outer_classname = "DiscountProto";
import "google/protobuf/empty.proto";
import "common.proto";

enum DiscountTypeGrpc { PERCENTAGE = 0; FIXED_AMOUNT = 1; }

message DiscountCreateRequest {
  string code = 1; DiscountTypeGrpc type = 2; string value = 3;
  string start_date = 4; string end_date = 5; string min_order_value = 6; bool is_active = 7;
}
message DiscountUpdateRequest {
  string id = 1; string code = 2; DiscountTypeGrpc type = 3; string value = 4;
  string start_date = 5; string end_date = 6; string min_order_value = 7; bool is_active = 8;
}
message DiscountToggleActiveRequest { string id = 1; bool is_active = 2; }
message DiscountCodeRequest { string code = 1; string order_value = 2; string at = 3; }

message DiscountView {
  string id = 1; string code = 2; DiscountTypeGrpc type = 3; string value = 4;
  string start_date = 5; string end_date = 6; string min_order_value = 7; bool is_active = 8;
}
message DiscountListRequest { bool only_effective = 1; string at = 2; int32 page = 3; int32 size = 4; }
message PageDiscount { int32 page = 1; int32 size = 2; int64 total = 3; int32 total_pages = 4; repeated DiscountView docs = 5; }

message DiscountValidationView { bool valid = 1; string reason = 2; string discount_amount = 3; }

service DiscountService {
  rpc Create(DiscountCreateRequest) returns (google.protobuf.Empty);
  rpc Update(DiscountUpdateRequest) returns (google.protobuf.Empty);
  rpc SoftDelete(IdRequest) returns (google.protobuf.Empty);
  rpc Restore(IdRequest) returns (google.protobuf.Empty);
  rpc ToggleActive(DiscountToggleActiveRequest) returns (google.protobuf.Empty);

  rpc GetByCode(DiscountCodeRequest) returns (DiscountView);
  rpc Validate(DiscountCodeRequest) returns (DiscountValidationView);
  rpc List(DiscountListRequest) returns (PageDiscount);
}

product.proto
syntax = "proto3";
package onlineshopping.v1;
option java_multiple_files = true;
option java_package = "com.common.grpc";
option java_outer_classname = "ProductProto";
import "google/protobuf/empty.proto";

import "common.proto";

enum ProductStatus {
  DRAFT = 0;
  PUBLISHED = 1;
  UNPUBLISHED = 2;
  ARCHIVED = 3;
}

message ProductCreateRequest {
  string name = 1;
  string slug = 2;
  string description = 3;
  string brand_id = 4;     // gán brand
}
message ProductUpdateRequest {
  string id = 1;
  string name = 2;
  string slug = 3;
  string description = 4;
  string brand_id = 5;
}

message ProductView {
  string id = 1;
  string name = 2;
  string slug = 3;
  string description = 4;
  ProductStatus status = 5;
  string brand_id = 6;
}

message ProductListRequest {
  string q = 1;              // text search
  string brand_id = 2;
  string category_id = 3;
  optional ProductStatus status = 4;
  int32 page = 5;
  int32 size = 6;
}
message PageProduct {
  int32 page = 1;
  int32 size = 2;
  int64 total = 3;
  int32 total_pages = 4;
  repeated ProductView docs = 5;
}

message PublishRequest { string id = 1; }
message UnpublishRequest { string id = 1; }
message ArchiveRequest { string id = 1; }

message AssignCategoryRequest {
  string product_id = 1;
  string category_id = 2;
}
message UnassignCategoryRequest {
  string product_id = 1;
  string category_id = 2;
}

service ProductService {
  rpc Create(ProductCreateRequest) returns (google.protobuf.Empty);
  rpc Update(ProductUpdateRequest) returns (google.protobuf.Empty);
  rpc SoftDelete(IdRequest) returns (google.protobuf.Empty);
  rpc Restore(IdRequest) returns (google.protobuf.Empty);

  rpc Publish(PublishRequest) returns (google.protobuf.Empty);
  rpc Unpublish(UnpublishRequest) returns (google.protobuf.Empty);
  rpc Archive(ArchiveRequest) returns (google.protobuf.Empty);

  rpc GetById(IdRequest) returns (ProductView);
  rpc GetBySlug(SlugRequest) returns (ProductView);
  rpc List(ProductListRequest) returns (PageProduct);

  rpc AssignCategory(AssignCategoryRequest) returns (google.protobuf.Empty);
  rpc UnassignCategory(UnassignCategoryRequest) returns (google.protobuf.Empty);
}

product_variant.proto
syntax = "proto3";
package onlineshopping.v1;
option java_multiple_files = true;
option java_package = "com.common.grpc";
option java_outer_classname = "ProductImageProto";
import "google/protobuf/empty.proto";
import "common.proto";

message ImageCreateRequest {
  string product_id = 1;
  string variant_id = 2;
  string image_url = 3;
}
message ImageView {
  string id = 1;
  string product_id = 2;
  string variant_id = 3;
  string image_url = 4;
  bool is_thumbnail = 5;
}
message ImageListRequest {
  string product_id = 1;
  string variant_id = 2;
  int32 page = 3;
  int32 size = 4;
}
message PageImage {
  int32 page = 1;
  int32 size = 2;
  int64 total = 3;
  int32 total_pages = 4;
  repeated ImageView docs = 5;
}

service ProductImageService {
  rpc Create(ImageCreateRequest) returns (google.protobuf.Empty);
  rpc SoftDelete(IdRequest) returns (google.protobuf.Empty);
  rpc Restore(IdRequest) returns (google.protobuf.Empty);

  rpc SetThumbnail(IdRequest) returns (google.protobuf.Empty);
  rpc UnsetThumbnail(IdRequest) returns (google.protobuf.Empty);
  rpc List(ImageListRequest) returns (PageImage);
}

variant.proto
syntax = "proto3";

package onlineshopping.v1;

import "common.proto";
import "google/protobuf/empty.proto";

option java_multiple_files = true;
option java_package = "com.common.grpc";
option java_outer_classname = "VariantProto";

message VariantCreateRequest {
  string product_id = 1;
  string sku = 2;
  string price = 3;
  string original_price = 4;
}
message VariantUpdateRequest {
  string id = 1;
  string sku = 2;
  string price = 3;
  string original_price = 4;
}
message VariantPricePatchRequest {
  string id = 1;
  string price = 2;
  string original_price = 3;
}
message VariantBySkuRequest {
  string sku = 1;
}
message VariantByProductRequest {
  string product_id = 1;
  int32 page = 2;
  int32 size = 3;
}

message VariantView {
    string id = 1;
    string product_id = 2;
    string sku = 3;
    string price = 4;
    string original_price = 5;
}
message PageVariant {
    int32 page = 1;
    int32 size = 2;
    int64 total = 3;
    int32 total_pages = 4;
    repeated VariantView docs = 5;
}

service VariantService {
    rpc Create (VariantCreateRequest) returns (google.protobuf.Empty);
    rpc Update (VariantUpdateRequest) returns (google.protobuf.Empty);
    rpc SoftDelete (IdRequest) returns (google.protobuf.Empty);
    rpc Restore (IdRequest) returns (google.protobuf.Empty);

    rpc FindBySku (VariantBySkuRequest) returns (VariantView);
    rpc PatchPrice (VariantPricePatchRequest) returns (google.protobuf.Empty);
    rpc ListByProduct (VariantByProductRequest) returns (PageVariant);
}

package org.common.http;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;

import java.time.Instant;
import java.util.List;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = lombok.AccessLevel.PRIVATE)
public class Envelope<T> {

    @Builder.Default
    int status = 200;

    String error;

    @Builder.Default
    String msg = "OK";

    @Builder.Default
    Instant currentTime = Instant.now();

    T data;

    /* Helpers */
    public static <T> Envelope<T> ok(T data){
        return Envelope.<T>builder()
                .status(200)
                .error(null)
                .msg("OK")
                .currentTime(Instant.now())
                .data(data)
                .build();
    }
    public static <T> Envelope<T> err(
            int status,
            String code,
            String message,
            T data){
        return Envelope.<T>builder()
                .status(status)
                .error(code)
                .msg(message)
                .currentTime(Instant.now())
                .data(data)
                .build();
    }

    public static <TDoc> Envelope<Page<TDoc>> okPage(
            int page, int size,
            long total, int totalPages,
            List<TDoc> docs){
        return Envelope.ok(Page.<TDoc>builder()
                .page(page)
                .size(size)
                .total(total)
                .totalPages(totalPages)
                .docs(docs)
                .build()
        );
    }

    @Getter @Setter @Builder
    @NoArgsConstructor @AllArgsConstructor
    @FieldDefaults(level = lombok.AccessLevel.PRIVATE)
    public static class Page<TDoc>{
        int page;
        int size;
        long total;
        int totalPages;

        @Builder.Default
        List<TDoc> docs = List.of();
    }
}

package org.common.exception;


import lombok.Getter;

@Getter
public class AppException extends RuntimeException {
    private final ErrorCode errorCode;
    public AppException(ErrorCode errorCode) {
        super(errorCode.getMessage());
        this.errorCode = errorCode;
    }
}

package org.common.exception;

import lombok.Getter;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;

import static org.common.constant.ErrorCodeConstant.BAD_REQUEST_STATUS;
import static org.common.constant.ErrorCodeConstant.CONFLICT_STATUS;
import static org.common.constant.ErrorCodeConstant.FORBIDDEN_STATUS;
import static org.common.constant.ErrorCodeConstant.INTERNAL_SERVER_STATUS;
import static org.common.constant.ErrorCodeConstant.NOT_FOUND_STATUS;
import static org.common.constant.ErrorCodeConstant.UNAUTHORIZED_STATUS;
import static org.springframework.http.HttpStatus.BAD_REQUEST;

@Getter
public enum ErrorCode {
    // 500
    UNCATEGORIZED_EXCEPTION(999, INTERNAL_SERVER_STATUS, "Lỗi chưa phân loại", HttpStatus.INTERNAL_SERVER_ERROR),

    // 400
    VALIDATION_FAILED(400, BAD_REQUEST_STATUS, "Dữ liệu không hợp lệ!", org.springframework.http.HttpStatus.BAD_REQUEST),
    INVALID_OTP(400, BAD_REQUEST_STATUS, "OTP không hợp lệ!", BAD_REQUEST),
    OTP_EXPIRED(400, BAD_REQUEST_STATUS, "OTP đã hết hạn!", BAD_REQUEST),
    EMAIL_SEND_FAILED(4008003, BAD_REQUEST_STATUS, "Gửi email thất bại!", BAD_REQUEST),
    PARENT_CYCLE(400, BAD_REQUEST_STATUS, "Chu kỳ danh mục (parent) không hợp lệ", BAD_REQUEST),
    THUMBNAIL_ALREADY_SET(400, BAD_REQUEST_STATUS, "Đã có thumbnail cho thực thể này", BAD_REQUEST),

    // 401
    UNAUTHENTICATED(401, UNAUTHORIZED_STATUS, "Chưa xác thực!", HttpStatus.UNAUTHORIZED),
    INVALID_CREDENTIALS(401, UNAUTHORIZED_STATUS, "Thông tin đăng nhập không hợp lệ!", HttpStatus.UNAUTHORIZED),
    INVALID_TOKEN(401, UNAUTHORIZED_STATUS, "Token không hợp lệ!", HttpStatus.UNAUTHORIZED),
    TOKEN_REVOKED(401, UNAUTHORIZED_STATUS, "Token đã bị thu hồi!", HttpStatus.UNAUTHORIZED),

    // 403
    UNAUTHORIZED(403, FORBIDDEN_STATUS, "Bạn không có quyền truy cập!", HttpStatus.FORBIDDEN),

    // 404
    USER_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy user", HttpStatus.NOT_FOUND),
    ROLE_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy vai trò", HttpStatus.NOT_FOUND),
    ADDRESS_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy địa chỉ", HttpStatus.NOT_FOUND),
    EMAIL_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy email", HttpStatus.NOT_FOUND),
    BRAND_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy thương hiệu", HttpStatus.NOT_FOUND),
    CATEGORY_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy danh mục", HttpStatus.NOT_FOUND),
    PRODUCT_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy sản phẩm", HttpStatus.NOT_FOUND),
    VARIANT_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy biến thể", HttpStatus.NOT_FOUND),
    ATTRIBUTE_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy thuộc tính", HttpStatus.NOT_FOUND),
    IMAGE_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy ảnh", HttpStatus.NOT_FOUND),
    DISCOUNT_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy mã giảm giá", HttpStatus.NOT_FOUND),

    // 409
    USER_ALREADY_EXISTS(409, CONFLICT_STATUS, "Người dùng đã tồn tại!", HttpStatus.CONFLICT),
    EMAIL_ALREADY_EXISTS(409, CONFLICT_STATUS, "Email đã tồn tại!", HttpStatus.CONFLICT),
    PASSWORD_ALREADY_EXISTS(409, CONFLICT_STATUS, "Mật khẩu đã tồn tại!", HttpStatus.CONFLICT),
    ROLE_ALREADY_EXISTS(409, CONFLICT_STATUS, "Vai trò đã tồn tại!", HttpStatus.CONFLICT),
    SLUG_CONFLICT(409, CONFLICT_STATUS, "Slug đã tồn tại", HttpStatus.CONFLICT),
    SKU_CONFLICT(409, CONFLICT_STATUS, "SKU đã tồn tại", HttpStatus.CONFLICT),

    // 500
    FAILED_GENERATE_TOKEN(500, INTERNAL_SERVER_STATUS, "Lỗi tạo JWT token!", HttpStatus.INTERNAL_SERVER_ERROR),
    FAILED_VALIDATE_TOKEN(500, INTERNAL_SERVER_STATUS, "Lỗi xác thực token!", HttpStatus.INTERNAL_SERVER_ERROR),
    MAIL_DELIVERY_FAILED(500, INTERNAL_SERVER_STATUS, "Gửi email thất bại!", HttpStatus.INTERNAL_SERVER_ERROR);

    private final int code;
    private final String status;
    private final String message;
    private final HttpStatusCode statusCode;

    ErrorCode(int code, String status, String message, HttpStatusCode statusCode) {
        this.code = code;
        this.status = status;
        this.message = message;
        this.statusCode = statusCode;
    }

    public int http() { return statusCode.value(); }
}

package org.common.exception;

import io.grpc.Status;
import io.grpc.StatusRuntimeException;
import jakarta.validation.ConstraintViolationException;
import lombok.extern.slf4j.Slf4j;
import net.devh.boot.grpc.server.advice.GrpcAdvice;
import net.devh.boot.grpc.server.advice.GrpcExceptionHandler;
import org.springframework.security.access.AccessDeniedException;

@Slf4j
@GrpcAdvice
public class GrpcServerExceptionAdvice {

    @GrpcExceptionHandler(AppException.class)
    public StatusRuntimeException handleAppException(AppException appException) {
        return GrpcStatusMapper.ex(appException.getErrorCode());
    }

    @GrpcExceptionHandler(AccessDeniedException.class)
    public StatusRuntimeException handleDeniedException(
            AccessDeniedException accessDeniedException) {
        return GrpcStatusMapper.ex(ErrorCode.UNAUTHORIZED);
    }

    @GrpcExceptionHandler(ConstraintViolationException.class)
    public StatusRuntimeException handleBadException(
            ConstraintViolationException constraintViolationException) {
        return GrpcStatusMapper.ex(ErrorCode.VALIDATION_FAILED);
    }

    @GrpcExceptionHandler(Throwable.class)
    public StatusRuntimeException handleAnyException(
            Throwable throwable) {
        return Status.INTERNAL.withDescription(ErrorCode.UNCATEGORIZED_EXCEPTION.name())
                .asRuntimeException();
    }
}

package org.common.exception;

import com.google.protobuf.Empty;
import io.grpc.Status;
import io.grpc.StatusRuntimeException;
import io.grpc.stub.StreamObserver;
import lombok.experimental.UtilityClass;

@UtilityClass
public class GrpcStatusMapper {

    public Status statusFor(
            ErrorCode errorCode) {
        return switch (errorCode) {
            case UNAUTHENTICATED, INVALID_CREDENTIALS, INVALID_TOKEN,
                 TOKEN_REVOKED -> Status.UNAUTHENTICATED;
            case UNAUTHORIZED -> Status.PERMISSION_DENIED;
            case USER_NOT_FOUND, EMAIL_NOT_FOUND -> Status.NOT_FOUND;
            case USER_ALREADY_EXISTS, EMAIL_ALREADY_EXISTS,
                 PASSWORD_ALREADY_EXISTS -> Status.ALREADY_EXISTS;
            case FAILED_VALIDATE_TOKEN, INVALID_OTP, VALIDATION_FAILED,
                 OTP_EXPIRED, EMAIL_SEND_FAILED -> Status.INVALID_ARGUMENT;
            default -> Status.INTERNAL;
        };
    }

    public StatusRuntimeException ex(
            ErrorCode errorCode) {
        return statusFor(errorCode).withDescription(errorCode.name())
                .asRuntimeException();
    }

    public <T> void fail(
            StreamObserver<T> streamObserver,
            ErrorCode errorCode) {
        streamObserver.onError(ex(errorCode));
    }

    public void ok(
            StreamObserver<Empty> streamObserver) {
        streamObserver.onNext(Empty.getDefaultInstance());
        streamObserver.onCompleted();
    }

    public static <T> void ok(StreamObserver<? super T> streamObserver, T payload) {
        streamObserver.onNext(payload);
        streamObserver.onCompleted();
    }
}

package org.common.constant;

import lombok.NoArgsConstructor;
import org.springframework.http.HttpStatus;

@NoArgsConstructor
public final class ErrorCodeConstant {
    public static final String INTERNAL_SERVER_STATUS = HttpStatus.INTERNAL_SERVER_ERROR.toString();
    public static final String BAD_REQUEST_STATUS    = HttpStatus.BAD_REQUEST.toString();
    public static final String UNAUTHORIZED_STATUS   = HttpStatus.UNAUTHORIZED.toString();
    public static final String FORBIDDEN_STATUS      = HttpStatus.FORBIDDEN.toString();
    public static final String NOT_FOUND_STATUS      = HttpStatus.NOT_FOUND.toString();
    public static final String CONFLICT_STATUS       = HttpStatus.CONFLICT.toString();
}

package org.common.constant;

public final class SecurityConstants {
    // Headers
    public static final String AUTHORIZATION_HEADER = "Authorization";
    public static final String CONTENT_TYPE_HEADER  = "Content-Type";
    public static final String ACCEPT_HEADER        = "Accept";

    // CORS mặc định
    public static final String FRONTEND_ENDPOINT = "http://localhost:4200";

    // Public endpoints chuẩn
    public static final String[] PUBLIC_ENDPOINTS = {
            "/health", "/actuator/**", "/auth/**", "/h2-console/**"
    };

    // Methods
    public static final String GET="GET", POST="POST", PUT="PUT", DELETE="DELETE", PATCH="PATCH", OPTIONS="OPTIONS";

    // Path
    public static final String URL_PATTERN_ALL = "/**";

    private SecurityConstants(){}
}

business-service

package com.business.service;

import org.springframework.stereotype.Component;
import java.math.BigDecimal;

@Component
public class OrderPricingRule {
  public BigDecimal shippingFor(BigDecimal subtotal) {
    if (subtotal == null) return BigDecimal.ZERO;
    return subtotal.compareTo(new BigDecimal("500000")) >= 0 ? BigDecimal.ZERO : new BigDecimal("30000");
  }
}
package com.business.service;

import com.business.constant.OrderStatus;
import com.business.dto.request.CreateOrderDirectRequestDto;
import com.business.dto.request.CreateOrderFromCartRequestDto;
import com.business.dto.response.OrderResponseDto;
import org.common.http.Envelope;
import java.math.BigDecimal;
import java.time.Instant;

public interface IOrderService {
  OrderResponseDto createFromCart(
      CreateOrderFromCartRequestDto dto);
  OrderResponseDto createDirect(
      CreateOrderDirectRequestDto dto);
  OrderResponseDto getDetail(String id);
  Envelope.Page<OrderResponseDto> list(
      String userId,
      OrderStatus status,
      Instant from, Instant to,
      int page, int size);
  void updateStatus(
      String id,
      OrderStatus toStatus);   // requireAdmin for PROCESSING/SHIPPED/COMPLETED
  void cancel(String id);      // user: only PENDING/PROCESSING
  void patchCharges(
      String id,
      BigDecimal shippingFee,
      String paymentMethodName,
      String shippingMethodName);
  void applyOrSwapCode(
      String id,
      String code);
}
package com.business.service;

import com.business.dto.response.CartResponseDto;
import java.time.Instant;

public interface ICartService {
  CartResponseDto getOrCreate(
      String userId);
  void addItem(
      String userId,
      String variantId,
      int quantity);
  void updateQty(
      String cartItemId,
      int quantity);
  void removeItem(
      String cartItemId);
  void clear(
      String userId);

  CartResponseDto list(
      String userId);
  CartResponseDto applyCode(
      String userId,
      String code,
      Instant at);
  void merge(
      String fromUserId,
      String toUserId);
}
package com.business.service.impl;

import com.business.constant.OrderStatus;
import com.business.dto.request.CreateOrderDirectRequestDto;
import com.business.dto.request.CreateOrderFromCartRequestDto;
import com.business.dto.response.OrderItemResponseDto;
import com.business.dto.response.OrderResponseDto;
import com.business.entity.CartItem;
import com.business.entity.Order;
import com.business.entity.OrderItem;
import com.business.entity.ProductVariant;
import com.business.helper.AuthenticationHelper;
import com.business.mapper.OrderMapper;
import com.business.repository.CartItemsRepository;
import com.business.repository.CartsRepository;
import com.business.repository.OrderItemsRepository;
import com.business.repository.OrdersRepository;
import com.business.repository.ProductVariantsRepository;
import com.business.service.IDiscountService;
import com.business.service.IOrderService;
import com.business.service.OrderPricingRule;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import org.common.exception.AppException;
import org.common.exception.ErrorCode;
import org.common.http.Envelope;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;
import java.util.Objects;

@Service
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class OrderServiceImpl implements IOrderService {

  OrdersRepository ordersRepo;
  OrderItemsRepository orderItemsRepo;
  ProductVariantsRepository variantsRepo;
  CartItemsRepository cartItemsRepo;
  CartsRepository cartsRepo;
  OrderPricingRule pricingRule;
  IDiscountService discountService;
  OrderMapper orderMapper;

  @Override
  @Transactional
  public OrderResponseDto createFromCart(
      CreateOrderFromCartRequestDto dto) {
    List<CartItem> cart = cartItemsRepo
        .listWithSnapshot(dto.getUserId());
    if (cart.isEmpty()) {
      throw new AppException(ErrorCode.VALIDATION_FAILED);
    }

    // snapshot + totals
    Totals t = totalsFromCart(cart, dto.getDiscountCode());

    Order o = Order.builder()
        .userId(dto.getUserId())
        .status(OrderStatus.pending)
        .subtotal(t.subtotal)
        .shippingFee(t.shipping)
        .discountAmount(t.discount)
        .totalAmount(t.total)
        .shippingAddress(dto.getShippingAddress())
        .billingAddress(Objects.toString(dto.getBillingAddress(), ""))
        .paymentMethodName(dto.getPaymentMethodName())
        .shippingMethodName(dto.getShippingMethodName())
        .discountCode(dto.getDiscountCode())
        .build();
    o = ordersRepo.save(o);

    for (CartItem ci : cart) {
      ProductVariant v = ci.getVariant();
      orderItemsRepo.save(OrderItem.builder()
          .order(o)
          .variant(v)
          .sku(v.getSku())
          .productName(v.getProduct().getName())
          .quantity(ci.getQuantity())
          .price(v.getPrice())
          .build());
    }

    // clear cart
    cartItemsRepo.deleteAllByUserId(dto.getUserId());
    return getDetail(o.getId());
  }

  @Override @Transactional
  public OrderResponseDto createDirect(
      CreateOrderDirectRequestDto dto) {
    if (dto.getLines() == null || dto.getLines().isEmpty()) {
      throw new AppException(ErrorCode.VALIDATION_FAILED);
    }

    BigDecimal subtotal = BigDecimal.ZERO;
    for (var line : dto.getLines()) {
      ProductVariant v = variantsRepo.findById(line.getVariantId())
          .orElseThrow(() -> new AppException(ErrorCode.VARIANT_NOT_FOUND));
      subtotal = subtotal.add(v.getPrice()
          .multiply(new BigDecimal(line.getQuantity())));
    }
    BigDecimal shipping = pricingRule.shippingFor(subtotal);
    BigDecimal discount = discountAmount(dto.getDiscountCode(), subtotal);
    BigDecimal total = subtotal.add(shipping).subtract(discount);

    Order o = ordersRepo.save(Order.builder()
        .userId(dto.getUserId())
        .status(OrderStatus.pending)
        .subtotal(subtotal)
        .shippingFee(shipping)
        .discountAmount(discount)
        .totalAmount(total)
        .shippingAddress(dto.getShippingAddress())
        .billingAddress(Objects.toString(dto.getBillingAddress(), ""))
        .paymentMethodName(dto.getPaymentMethodName())
        .shippingMethodName(dto.getShippingMethodName())
        .discountCode(dto.getDiscountCode())
        .build());

    for (var line : dto.getLines()) {
      ProductVariant v = variantsRepo.findById(line.getVariantId())
          .orElseThrow(() -> new AppException(ErrorCode.VARIANT_NOT_FOUND));
      orderItemsRepo.save(OrderItem.builder()
          .order(o)
          .variant(v)
          .sku(v.getSku())
          .productName(v.getProduct().getName())
          .quantity(line.getQuantity())
          .price(v.getPrice())
          .build());
    }
    return getDetail(o.getId());
  }

  @Override
  @Transactional(readOnly = true)
  public OrderResponseDto getDetail(String id) {
    Order o = ordersRepo.findById(id)
        .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
    List<OrderItemResponseDto> items = orderItemsRepo
        .listByOrder(id)
        .stream()
        .map(orderMapper::toOrderItemResponseDtoFromOrderItem)
        .toList();
    return OrderResponseDto.builder()
        .id(o.getId())
        .userId(o.getUserId())
        .status(o.getStatus())
        .subtotal(o.getSubtotal())
        .discountAmount(o.getDiscountAmount())
        .shippingFee(o.getShippingFee())
        .totalAmount(o.getTotalAmount())
        .shippingAddress(o.getShippingAddress())
        .billingAddress(o.getBillingAddress())
        .paymentMethodName(o.getPaymentMethodName())
        .shippingMethodName(o.getShippingMethodName())
        .discountCode(o.getDiscountCode())
        .createdAt(o.getCreatedAt())
        .items(items)
        .build();
  }

  @Override
  @Transactional(readOnly = true)
  public Envelope.Page<OrderResponseDto> list(
      String userId,
      OrderStatus status,
      Instant from,
      Instant to,
      int page, int size) {
    Page<Order> p = ordersRepo.filter(
        userId,
        status,
        from, to,
        PageRequest.of(page, size));
    List<OrderResponseDto> docs = p.getContent()
        .stream()
        .map(o -> getDetail(o.getId()))
        .toList();
    return Envelope.okPage(
        p.getNumber(),
        p.getSize(),
        p.getTotalElements(),
        p.getTotalPages(),
        docs)
        .getData();
  }

  @Override
  @Transactional
  public void updateStatus(
      String id,
      OrderStatus toStatus) {
    AuthenticationHelper.requireAdmin();
    Order o = ordersRepo.findById(id)
        .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));

    switch (o.getStatus()) {
      case pending -> {
        if (toStatus != OrderStatus.processing && toStatus != OrderStatus.cancelled)
          throw new AppException(ErrorCode.VALIDATION_FAILED);
      }
      case processing -> {
        if (toStatus != OrderStatus.shipped && toStatus != OrderStatus.cancelled)
          throw new AppException(ErrorCode.VALIDATION_FAILED);
      }
      case shipped -> {
        if (toStatus != OrderStatus.completed)
          throw new AppException(ErrorCode.VALIDATION_FAILED);
      }
      case completed, cancelled ->
          throw new AppException(ErrorCode.VALIDATION_FAILED);
    }
    o.setStatus(toStatus);
    ordersRepo.save(o);
  }

  @Override
  @Transactional
  public void cancel(String id) {
    Order o = ordersRepo.findById(id)
        .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
    if (o.getStatus() != OrderStatus.pending && o.getStatus() != OrderStatus.processing)
      throw new AppException(ErrorCode.VALIDATION_FAILED);
    o.setStatus(OrderStatus.cancelled);
    ordersRepo.save(o);
  }

  @Override @Transactional
  public void patchCharges(
      String id,
      BigDecimal shippingFee,
      String paymentMethodName,
      String shippingMethodName) {
    AuthenticationHelper.requireAdmin();
    Order o = ordersRepo.findById(id)
        .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
    if (shippingFee!=null) {
      o.setShippingFee(shippingFee);
    }
    if (paymentMethodName!=null) {
      o.setPaymentMethodName(paymentMethodName);
    }
    if (shippingMethodName!=null) {
      o.setShippingMethodName(shippingMethodName);
    }

    o.setTotalAmount(o.getSubtotal()
        .add(o.getShippingFee())
        .subtract(o.getDiscountAmount()));
    ordersRepo.save(o);
  }

  @Override
  @Transactional
  public void applyOrSwapCode(String id, String code) {
    Order o = ordersRepo.findById(id)
        .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
    BigDecimal discount = discountAmount(code, o.getSubtotal());
    o.setDiscountCode(code);
    o.setDiscountAmount(discount);
    o.setTotalAmount(o.getSubtotal()
        .add(o.getShippingFee())
        .subtract(discount));
    ordersRepo.save(o);
  }

  record Totals(
      BigDecimal subtotal,
      BigDecimal shipping,
      BigDecimal discount,
      BigDecimal total) {}
  private Totals totalsFromCart(
      List<CartItem> cart,
      String code) {
    BigDecimal subtotal = cart.stream()
        .map(ci -> ci.getVariant()
            .getPrice()
            .multiply(new BigDecimal(ci.getQuantity())))
        .reduce(BigDecimal.ZERO, BigDecimal::add);
    BigDecimal shipping = pricingRule.shippingFor(subtotal);
    BigDecimal discount = discountAmount(code, subtotal);
    BigDecimal total = subtotal.add(shipping).subtract(discount);
    return new Totals(subtotal, shipping, discount, total);
  }
  private BigDecimal discountAmount(
      String code,
      BigDecimal subtotal) {
    if (code == null || code.isBlank()) return BigDecimal.ZERO;
    var v = discountService.validateAndAmount(code, subtotal, Instant.now());
    return v.isValid() ? v.getAmount() : BigDecimal.ZERO;
  }
}
package com.business.service.impl;

import com.business.dto.response.CartItemResponseDto;
import com.business.dto.response.CartResponseDto;
import com.business.entity.Cart;
import com.business.entity.CartItem;
import com.business.entity.ProductVariant;
import com.business.mapper.CartMapper;
import com.business.repository.CartItemsRepository;
import com.business.repository.CartsRepository;
import com.business.repository.ProductVariantsRepository;
import com.business.service.ICartService;
import com.business.service.IDiscountService;
import com.business.service.OrderPricingRule;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import org.common.exception.AppException;
import org.common.exception.ErrorCode;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;
import java.util.Objects;

@Service
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class CartServiceImpl implements ICartService {

  CartsRepository cartsRepository;
  CartItemsRepository cartItemsRepository;
  ProductVariantsRepository productVariantsRepository;
  OrderPricingRule orderPricingRule;           // bean tính shipping fee (simple)
  IDiscountService discountService;
  CartMapper cartMapper;

  @Override
  @Transactional
  public CartResponseDto getOrCreate(
      String userId) {
    cartsRepository.findById(userId).orElseGet(() -> {
      Cart c = Cart.builder().id(null).build();
      c.setDeletedAt(null);
      c.setDeletedBy(null);
      c.setCreatedBy(userId);
      c.setUserId(userId);
      return cartsRepository.save(c);
    });
    return list(userId);
  }

  @Override
  @Transactional
  public void addItem(
      String userId,
      String variantId,
      int quantity) {
    if (quantity <= 0) quantity = 1;
    cartsRepository.findById(userId).orElseGet(() -> cartsRepository.save(Cart.builder()
        .userId(userId)
        .build()));
    ProductVariant v = productVariantsRepository.findById(variantId)
        .orElseThrow(() -> new AppException(ErrorCode.VARIANT_NOT_FOUND));
    CartItem ci = cartItemsRepository.findByUserAndVariant(userId, variantId)
        .orElse(null);
    if (ci == null) {
      ci = CartItem.builder()
          .userId(userId)
          .variant(v)
          .quantity(quantity)
          .build();
    } else {
      ci.setQuantity(ci.getQuantity() + quantity);
    }
    cartItemsRepository.save(ci);
  }

  @Override
  @Transactional
  public void updateQty(
      String cartItemId,
      int quantity) {
    if (quantity <= 0) {
      removeItem(cartItemId); return;
    }
    CartItem ci = cartItemsRepository.findById(cartItemId)
        .orElseThrow(() -> new AppException(ErrorCode.ATTRIBUTE_NOT_FOUND)); // dùng code 404 chung
    ci.setQuantity(quantity);
    cartItemsRepository.save(ci);
  }

  @Override @Transactional
  public void removeItem(String cartItemId) {
    if (!cartItemsRepository.existsById(cartItemId))
      throw new AppException(ErrorCode.ATTRIBUTE_NOT_FOUND);
    cartItemsRepository.deleteById(cartItemId);
  }

  @Override
  @Transactional
  public void clear(String userId) {
    cartItemsRepository.deleteAllByUserId(userId);
  }

  @Override
  @Transactional(readOnly = true)
  public CartResponseDto list(String userId) {
    List<CartItem> rows = cartItemsRepository.listWithSnapshot(userId);
    List<CartItemResponseDto> docs = rows.stream()
        .map(cartMapper::toCartItemResponseDtoFromCartItem)
        .toList();
    BigDecimal subtotal = docs.stream()
        .map(CartItemResponseDto::getLineTotal)
        .reduce(BigDecimal.ZERO, BigDecimal::add);
    BigDecimal shipping = orderPricingRule.shippingFor(subtotal);
    BigDecimal discount = BigDecimal.ZERO;
    BigDecimal total = subtotal.add(shipping).subtract(discount);
    return CartResponseDto.builder()
        .userId(userId)
        .items(docs)
        .subtotal(subtotal)
        .shippingFee(shipping)
        .discountAmount(discount)
        .total(total)
        .build();
  }

  @Override
  @Transactional(readOnly = true)
  public CartResponseDto applyCode(
      String userId,
      String code,
      Instant at) {
    CartResponseDto base = list(userId);
    if (code == null || code.isBlank()) {
      return base;
    }
    var v = discountService.validateAndAmount(
        code,
        base.getSubtotal(),
        at == null ? Instant.now() : at);
    BigDecimal discount = v.isValid()
        ? v.getAmount()
        : BigDecimal.ZERO;
    BigDecimal total = base.getSubtotal()
        .add(base.getShippingFee())
        .subtract(discount);
    base.setDiscountAmount(discount);
    base.setTotal(total);
    return base;
  }

  @Override
  @Transactional
  public void merge(
      String fromUserId,
      String toUserId) {
    if (Objects.equals(fromUserId, toUserId)) return;
    cartsRepository.findById(toUserId)
        .orElseGet(() -> cartsRepository.save(Cart.builder()
            .userId(toUserId)
            .build()));
    List<CartItem> from = cartItemsRepository.listWithSnapshot(fromUserId);
    for (CartItem ci : from) {
      addItem(
          toUserId,
          ci.getVariant().getId(),
          ci.getQuantity());
    }
    cartItemsRepository.deleteAllByUserId(fromUserId);
  }
}
package com.business.repository;

import com.business.constant.OrderStatus;
import com.business.entity.Order;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.time.Instant;

@Repository
public interface OrdersRepository
    extends JpaRepository<Order, String> {

  @Query("""
     select o from Order o
      where o.userId = :uid
        and (:status is null or o.status = :status)
        and (:from is null or o.createdAt >= :from)
        and (:to is null or o.createdAt < :to)
     order by o.createdAt desc
  """)
  Page<Order> filter(
      @Param("uid") String userId,
      @Param("status") OrderStatus status,
      @Param("from") Instant from,
      @Param("to") Instant to,
      Pageable pageable);
}
package com.business.repository;

import com.business.entity.OrderItem;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface OrderItemsRepository
    extends JpaRepository<OrderItem, String> {

  @Query("""
     select oi from OrderItem oi
      join fetch oi.variant v
      join fetch oi.order o
     where oi.order.id = :oid
     order by oi.id asc
  """)
  List<OrderItem> listByOrder(
      @Param("oid") String orderId);
}
package com.business.repository;

import com.business.entity.Cart;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

@Repository
public interface CartsRepository
    extends JpaRepository<Cart, String> {

  @Query(value = "update carts set deleted_at = null, deleted_by = null where user_id = :uid", nativeQuery = true)
  @Modifying
  int nativeRestore(
      @Param("uid") String userId);
}
package com.business.repository;

import com.business.entity.CartItem;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;

@Repository
public interface CartItemsRepository
    extends JpaRepository<CartItem, String> {

  @Query("""
     select ci from CartItem ci
      where ci.userId = :uid and ci.variant.id = :vid
  """)
  Optional<CartItem> findByUserAndVariant(
      @Param("uid") String userId,
      @Param("vid") String variantId);

  @Modifying
  @Query("delete from CartItem ci where ci.userId = :uid")
  int deleteAllByUserId(
      @Param("uid") String userId);

  @Query("""
     select ci from CartItem ci
      join fetch ci.variant v
      join fetch v.product p
     where ci.userId = :uid
     order by ci.id asc
  """)
  List<CartItem> listWithSnapshot(
      @Param("uid") String userId);
}
package com.business.dto.response;

import com.business.constant.OrderStatus;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderResponseDto {
  String id;
  String userId;
  OrderStatus status;
  BigDecimal subtotal;
  BigDecimal discountAmount;
  BigDecimal shippingFee;
  BigDecimal totalAmount;
  String shippingAddress;
  String billingAddress;
  String paymentMethodName;
  String shippingMethodName;
  String discountCode;
  Instant createdAt;
  List<OrderItemResponseDto> items;
}
package com.business.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.math.BigDecimal;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderItemResponseDto {
  String id;
  String variantId;
  String sku;
  String productName;
  BigDecimal price;
  Integer quantity;
  BigDecimal lineTotal;
}
package com.business.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.math.BigDecimal;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CartResponseDto {
  String userId;
  List<CartItemResponseDto> items;
  BigDecimal subtotal;
  BigDecimal discountAmount;
  BigDecimal shippingFee;
  BigDecimal total;
}
package com.business.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.math.BigDecimal;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CartItemResponseDto {
  String id;
  String variantId;
  String sku;
  String productName;
  BigDecimal price;
  Integer quantity;
  BigDecimal lineTotal;
}

package com.business.dto.request;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CreateOrderFromCartRequestDto {
  String userId;
  String shippingAddress;
  String billingAddress;
  String paymentMethodName;
  String shippingMethodName;
  String discountCode;
}
package com.business.dto.request;


import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CreateOrderDirectRequestDto {
  String userId;
  String shippingAddress;
  String billingAddress;
  String paymentMethodName;
  String shippingMethodName;
  String discountCode;
  List<Line> lines;
  @Data @Builder @NoArgsConstructor @AllArgsConstructor
  public static class Line {
    String variantId;
    Integer quantity;
  }
}
package com.business.dto.request;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CartUpdateQtyRequestDto {
  String cartItemId;
  Integer quantity;
}

package com.business.dto.request;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.time.Instant;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CartApplyCodeRequestDto {
  String userId;
  String code;
  Instant at;
}
package com.business.dto.request;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CartAddItemRequestDto {
  String userId;
  String variantId;
  Integer quantity;
}
package com.business.controller;

import com.business.constant.OrderStatus;
import com.business.dto.request.CreateOrderDirectRequestDto;
import com.business.dto.request.CreateOrderFromCartRequestDto;
import com.business.dto.response.OrderItemResponseDto;
import com.business.dto.response.OrderResponseDto;
import com.business.helper.AuthenticationHelper;
import com.business.mapper.OrderMapper;
import com.business.service.IOrderService;
import com.common.grpc.CreateOrderDirectRequest;
import com.common.grpc.CreateOrderFromCartRequest;
import com.common.grpc.OrderApplyOrSwapCodeRequest;
import com.common.grpc.OrderCancelRequest;
import com.common.grpc.OrderIdRequest;
import com.common.grpc.OrderItemView;
import com.common.grpc.OrderListRequest;
import com.common.grpc.OrderPatchChargesRequest;
import com.common.grpc.OrderServiceGrpc;
import com.common.grpc.OrderStatusGrpc;
import com.common.grpc.OrderUpdateStatusRequest;
import com.common.grpc.OrderView;
import com.common.grpc.PageOrder;
import com.google.protobuf.Empty;
import io.grpc.stub.StreamObserver;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import net.devh.boot.grpc.server.service.GrpcService;
import org.common.exception.GrpcStatusMapper;
import java.math.BigDecimal;
import java.time.Instant;
import java.util.Objects;

@GrpcService
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class OrderGrpcServer
    extends OrderServiceGrpc.OrderServiceImplBase {
  IOrderService orderService;
  OrderMapper mapper;

  private OrderItemView map(OrderItemResponseDto d){
    return OrderItemView.newBuilder()
        .setId(Objects.toString(d.getId(),""))
        .setVariantId(Objects.toString(d.getVariantId(),""))
        .setSku(Objects.toString(d.getSku(),""))
        .setProductName(Objects.toString(d.getProductName(),""))
        .setPrice(d.getPrice().toPlainString())
        .setQuantity(d.getQuantity())
        .setLineTotal(d.getLineTotal().toPlainString()).build();
  }
  private OrderView map(OrderResponseDto o){
    var b = OrderView.newBuilder()
        .setId(o.getId()).setUserId(o.getUserId())
        .setStatus(OrderStatusGrpc.valueOf(o.getStatus().name().toUpperCase()))
        .setSubtotal(o.getSubtotal().toPlainString())
        .setDiscountAmount(o.getDiscountAmount().toPlainString())
        .setShippingFee(o.getShippingFee().toPlainString())
        .setTotalAmount(o.getTotalAmount().toPlainString())
        .setShippingAddress(Objects.toString(o.getShippingAddress(),""))
        .setBillingAddress(Objects.toString(o.getBillingAddress(),""))
        .setPaymentMethodName(Objects.toString(o.getPaymentMethodName(),""))
        .setShippingMethodName(Objects.toString(o.getShippingMethodName(),""))
        .setDiscountCode(Objects.toString(o.getDiscountCode(),""))
        .setCreatedAt(Objects.toString(o.getCreatedAt(),""));
    o.getItems().forEach(i -> b.addItems(map(i)));
    return b.build();
  }

  @Override
  public void createFromCart(
      CreateOrderFromCartRequest request,
      StreamObserver<OrderView> responseObserver) {
    var dto = CreateOrderFromCartRequestDto.builder()
        .userId(request.getUserId())
        .shippingAddress(request.getShippingAddress())
        .billingAddress(request.getBillingAddress())
        .paymentMethodName(request.getPaymentMethodName())
        .shippingMethodName(request.getShippingMethodName())
        .discountCode(request.getDiscountCode())
        .build();
    GrpcStatusMapper.ok(responseObserver, map(orderService.createFromCart(dto)));
  }

  @Override
  public void createDirect(
      CreateOrderDirectRequest request,
      StreamObserver<OrderView> responseObserver) {
    var dto = CreateOrderDirectRequestDto.builder()
        .userId(request.getUserId())
        .shippingAddress(request.getShippingAddress())
        .billingAddress(request.getBillingAddress())
        .paymentMethodName(request.getPaymentMethodName())
        .shippingMethodName(request.getShippingMethodName())
        .discountCode(request.getDiscountCode())
        .lines(request.getLinesList().stream()
            .map(l -> new CreateOrderDirectRequestDto
                .Line(l.getVariantId(), l.getQuantity()))
            .toList())
        .build();
    GrpcStatusMapper.ok(responseObserver, map(orderService.createDirect(dto)));
  }

  @Override
  public void getDetail(
      OrderIdRequest req,
      StreamObserver<OrderView> obs) {
    GrpcStatusMapper.ok(obs, map(orderService.getDetail(req.getId())));
  }

  @Override
  public void list(
      OrderListRequest request,
      StreamObserver<PageOrder> responseObserver) {
    OrderStatus status = (request.getStatus().isBlank()
        ? null
        : OrderStatus.valueOf(request.getStatus().toLowerCase()));
    Instant from = request.getDateFrom().isBlank()
        ? null
        : Instant.parse(request.getDateFrom());
    Instant to = request.getDateTo().isBlank()
        ? null
        : Instant.parse(request.getDateTo());
    var page = orderService.list(
        request.getUserId(),
        status,
        from, to,
        request.getPage(),
        request.getSize());
    var b = PageOrder.newBuilder()
        .setPage(page.getPage())
        .setSize(page.getSize())
        .setTotal(page.getTotal())
        .setTotalPages(page.getTotalPages());
    page.getDocs().forEach(d -> b.addDocs(map(d)));
    GrpcStatusMapper.ok(responseObserver, b.build());
  }

  @Override
  public void updateStatus(
      OrderUpdateStatusRequest request,
      StreamObserver<Empty> responseObserver) {
    AuthenticationHelper.requireAdmin();
    orderService.updateStatus(
        request.getId(),
        OrderStatus.valueOf(request.getStatus().name().toLowerCase()));
    GrpcStatusMapper.ok(responseObserver);
  }

  @Override
  public void cancel(
      OrderCancelRequest request,
      StreamObserver<Empty> responseObserver) {
    orderService.cancel(request.getId());
    GrpcStatusMapper.ok(responseObserver);
  }

  @Override public void patchCharges(
      OrderPatchChargesRequest request,
      StreamObserver<Empty> responseObserver) {
    AuthenticationHelper.requireAdmin();
    BigDecimal shipping = request.getShippingFee().isBlank()
        ? null
        : new BigDecimal(request.getShippingFee());
    orderService.patchCharges(
        request.getId(),
        shipping,
        request.getPaymentMethodName(),
        request.getShippingMethodName());
    GrpcStatusMapper.ok(responseObserver);
  }

  @Override
  public void applyOrSwapCode(
      OrderApplyOrSwapCodeRequest request,
      StreamObserver<Empty> responseObserver) {
    orderService.applyOrSwapCode(request.getId(), request.getDiscountCode());
    GrpcStatusMapper.ok(responseObserver);
  }
}
package com.business.controller;

import com.business.dto.response.CartItemResponseDto;
import com.business.dto.response.CartResponseDto;
import com.business.mapper.CartMapper;
import com.business.service.ICartService;
import com.common.grpc.CartAddItemRequest;
import com.common.grpc.CartApplyCodeRequest;
import com.common.grpc.CartClearRequest;
import com.common.grpc.CartGetOrCreateRequest;
import com.common.grpc.CartItemView;
import com.common.grpc.CartListRequest;
import com.common.grpc.CartMergeRequest;
import com.common.grpc.CartRemoveItemRequest;
import com.common.grpc.CartServiceGrpc;
import com.common.grpc.CartUpdateQtyRequest;
import com.common.grpc.CartView;
import com.google.protobuf.Empty;
import io.grpc.stub.StreamObserver;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import net.devh.boot.grpc.server.service.GrpcService;
import org.common.exception.GrpcStatusMapper;
import java.time.Instant;
import java.util.Objects;

@GrpcService
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class CartGrpcServer
    extends CartServiceGrpc.CartServiceImplBase {
  ICartService cartService;
  CartMapper cartMapper;

  private CartItemView map(CartItemResponseDto d) {
    return CartItemView.newBuilder()
        .setId(d.getId()).setVariantId(d.getVariantId())
        .setSku(Objects.toString(d.getSku(),""))
        .setProductName(Objects.toString(d.getProductName(),""))
        .setPrice(d.getPrice().toPlainString())
        .setQuantity(d.getQuantity())
        .setLineTotal(d.getLineTotal().toPlainString())
        .build();
  }
  private CartView map(CartResponseDto r) {
    var b = CartView.newBuilder()
        .setUserId(r.getUserId())
        .setSubtotal(r.getSubtotal().toPlainString())
        .setDiscountAmount(r.getDiscountAmount().toPlainString())
        .setShippingFee(r.getShippingFee().toPlainString())
        .setTotal(r.getTotal().toPlainString());
    r.getItems().forEach(i -> b.addItems(map(i)));
    return b.build();
  }

  @Override
  public void getOrCreate(
      CartGetOrCreateRequest request,
      StreamObserver<CartView> responseObserver) {
    GrpcStatusMapper.ok(responseObserver, map(cartService.getOrCreate(request.getUserId())));
  }
  @Override
  public void addItem(
      CartAddItemRequest request,
      StreamObserver<Empty> responseObserver) {
    cartService.addItem(
        request.getUserId(),
        request.getVariantId(),
        request.getQuantity());
    GrpcStatusMapper.ok(responseObserver);
  }
  @Override
  public void updateQty(
      CartUpdateQtyRequest request,
      StreamObserver<Empty> responseObserver) {
    cartService.updateQty(
        request.getCartItemId(),
        request.getQuantity());
    GrpcStatusMapper.ok(responseObserver);
  }
  @Override
  public void removeItem(
      CartRemoveItemRequest request,
      StreamObserver<Empty> responseObserver) {
    cartService.removeItem(request.getCartItemId());
    GrpcStatusMapper.ok(responseObserver);
  }
  @Override
  public void clear(
      CartClearRequest request,
      StreamObserver<Empty> responseObserver) {
    cartService.clear(request.getUserId());
    GrpcStatusMapper.ok(responseObserver);
  }
  @Override
  public void list(
      CartListRequest request,
      StreamObserver<CartView> responseObserver) {
    GrpcStatusMapper.ok(responseObserver, map(cartService.list(request.getUserId())));
  }
  @Override
  public void applyCode(
      CartApplyCodeRequest request,
      StreamObserver<CartView> responseObserver) {
    Instant at = request.getAt().isBlank()
        ? Instant.now()
        : Instant.parse(request.getAt());
    GrpcStatusMapper.ok(responseObserver, map(cartService.applyCode(
        request.getUserId(), request.getCode(), at)));
  }
  @Override
  public void merge(
      CartMergeRequest request,
      StreamObserver<Empty> responseObserver) {
    cartService.merge(request.getFromUserId(), request.getToUserId());
    GrpcStatusMapper.ok(responseObserver);
  }
}

package com.business.entity;

import com.business.entity.audit.AuditMetadata;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.Table;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;
import org.hibernate.annotations.SQLDelete;
import org.hibernate.annotations.Where;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(
        name = "attributes",
        indexes = {@Index(name = "idx_attr_name", columnList = "name")}
)
@SQLDelete(sql = "UPDATE attributes SET deleted_by = ?, deleted_at = now() WHERE attribute_id = ?")
@Where(clause = "deleted_at IS NULL")
public class Attribute extends AuditMetadata {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "attribute_id", length = 36)
    String id;

    @Column(length = 100, nullable = false, unique = true)
    String name;

    @Column(length = 100, nullable = false)
    String value;
}

package com.business.entity;

import com.business.entity.audit.AuditMetadata;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.Table;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;
import org.hibernate.annotations.SQLDelete;
import org.hibernate.annotations.Where;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(
        name = "brands",
        indexes = {
                @Index(name = "idx_brands_name", columnList = "name"),
                @Index(name = "idx_brands_slug", columnList = "slug")
        })
@SQLDelete(sql = "UPDATE brands SET deleted_by = ?, deleted_at = now() WHERE brand_id = ?")
@Where(clause = "deleted_at IS NULL")
public class Brand extends AuditMetadata {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "brand_id", length = 36)
    String id;

    @Column(length = 100, nullable = false, unique = true)
    String name;

    @Column(length = 110, nullable = false, unique = true)
    String slug;

    @Column(name = "logo_url", length = 255)
    String logoUrl;
}

package com.business.entity;

import com.business.entity.audit.AuditMetadata;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.Table;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;
import org.hibernate.annotations.SQLDelete;
import org.hibernate.annotations.Where;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(
        name = "carts",
        indexes = {@Index(name = "idx_carts_user", columnList = "user_id")}
)
@SQLDelete(sql = "UPDATE carts SET deleted_by = ?, deleted_at = now() WHERE user_id = ?")
@Where(clause = "deleted_at IS NULL")
public class Cart extends AuditMetadata {

    @Id
    @Column(name = "user_id", length = 36)
    String userId; // PK = user_id (1-1)
}


package com.business.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import jakarta.persistence.UniqueConstraint;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(
        name = "cart_items",
        indexes = {
                @Index(name = "idx_cart_items_user", columnList = "user_id"),
                @Index(name = "idx_cart_items_variant", columnList = "variant_id")
        },
        uniqueConstraints = @UniqueConstraint(name = "uk_user_variant", columnNames = {
                "user_id", "variant_id"})
)
public class CartItem {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "cart_item_id", length = 36)
    String id;

    @Column(name = "user_id", length = 36, nullable = false)
    String userId;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "variant_id", nullable = false)
    ProductVariant variant;

    @Column(nullable = false)
    Integer quantity = 1;
}

package com.business.entity;

import com.business.entity.audit.AuditMetadata;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;
import org.hibernate.annotations.SQLDelete;
import org.hibernate.annotations.Where;

import java.util.HashSet;
import java.util.Set;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(
        name = "categories",
        indexes = {
                @Index(name = "idx_categories_name", columnList = "name"),
                @Index(name = "idx_categories_slug", columnList = "slug"),
                @Index(name = "idx_categories_parent", columnList = "parent_id")
        })
@SQLDelete(sql = "UPDATE categories SET deleted_by = ?, deleted_at = now() WHERE category_id = ?")
@Where(clause = "deleted_at IS NULL")
public class Category extends AuditMetadata {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "category_id", length = 36)
    String id;

    @Column(length = 100, nullable = false)
    String name;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "parent_id")
    Category parent;

    @OneToMany(mappedBy = "parent")
    Set<Category> children = new HashSet<>();

    @Column(length = 110, nullable = false, unique = true)
    String slug;
}

package com.business.entity;

import com.business.constant.DiscountType;
import com.business.entity.audit.AuditMetadata;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.Table;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;
import org.hibernate.annotations.SQLDelete;
import org.hibernate.annotations.Where;

import java.math.BigDecimal;
import java.time.Instant;


@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(
        name = "discounts",
        indexes = {
                @Index(name = "idx_discounts_code", columnList = "code"),
                @Index(name = "idx_discounts_active", columnList = "is_active"),
                @Index(name = "idx_discounts_window", columnList = "start_date,end_date")
        })
@SQLDelete(sql = "UPDATE discounts SET deleted_by = ?, deleted_at = now() WHERE discount_id = ?")
@Where(clause = "deleted_at IS NULL")
public class Discount extends AuditMetadata {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "discount_id", length = 36)
    String id;

    @Column(length = 50, nullable = false, unique = true)
    String code;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    DiscountType type;

    @Column(precision = 10, scale = 2, nullable = false)
    BigDecimal value;

    @Column(name = "start_date")
    Instant startDate;

    @Column(name = "end_date")
    Instant endDate;

    @Column(name = "min_order_value", precision = 10, scale = 2)
    BigDecimal minOrderValue = BigDecimal.ZERO;

    @Column(name = "is_active", nullable = false)
    Boolean active = true;
}

package com.business.entity;

import com.business.constant.OrderStatus;
import com.business.entity.audit.AuditMetadata;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.Lob;
import jakarta.persistence.Table;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;
import org.hibernate.annotations.SQLDelete;
import org.hibernate.annotations.Where;

import java.math.BigDecimal;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(
        name = "orders",
        indexes = {
                @Index(name = "idx_orders_user", columnList = "user_id"),
                @Index(name = "idx_orders_status", columnList = "status"),
                @Index(name = "idx_orders_created", columnList = "created_at")
        })
@SQLDelete(sql = "UPDATE orders SET deleted_by = ?, deleted_at = now() WHERE order_id = ?")
@Where(clause = "deleted_at IS NULL")
public class Order extends AuditMetadata {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "order_id", length = 36)
    String id;

    @Column(name = "user_id", length = 36, nullable = false)
    String userId;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    OrderStatus status = OrderStatus.pending;

    @Column(precision = 10, scale = 2, nullable = false)
    BigDecimal subtotal;

    @Column(name = "shipping_fee", precision = 10, scale = 2, nullable = false)
    BigDecimal shippingFee = BigDecimal.ZERO;

    @Column(name = "discount_amount", precision = 10, scale = 2, nullable = false)
    BigDecimal discountAmount = BigDecimal.ZERO;

    @Column(name = "total_amount", precision = 10, scale = 2, nullable = false)
    BigDecimal totalAmount;

    @Lob
    @Column(name = "shipping_address", nullable = false, columnDefinition = "text")
    String shippingAddress;

    @Lob
    @Column(name = "billing_address", columnDefinition = "text")
    String billingAddress;

    @Column(name = "payment_method_name", length = 100)
    String paymentMethodName;

    @Column(name = "shipping_method_name", length = 100)
    String shippingMethodName;

    @Column(name = "discount_code", length = 50)
    String discountCode;
}

package com.business.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;

import java.math.BigDecimal;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(
        name = "order_items",
        indexes = {
                @Index(name = "idx_order_items_order", columnList = "order_id"),
                @Index(name = "idx_order_items_variant", columnList = "variant_id")
        })
public class OrderItem {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "order_item_id", length = 36)
    String id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false)
    Order order;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "variant_id", nullable = false)
    ProductVariant variant;

    @Column(length = 100) // denormalized
    String sku;

    @Column(name = "product_name", length = 255, nullable = false)
    // denormalized
    String productName;

    @Column(nullable = false)
    Integer quantity;

    @Column(precision = 10, scale = 2, nullable = false)
    BigDecimal price; // giá tại thời điểm mua
}

package com.business.entity;

import com.business.constant.ProductStatus;
import com.business.entity.audit.AuditMetadata;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.Lob;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;
import org.hibernate.annotations.SQLDelete;
import org.hibernate.annotations.Where;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(
        name = "products",
        indexes = {
                @Index(name = "idx_products_name", columnList = "name"),
                @Index(name = "idx_products_slug", columnList = "slug"),
                @Index(name = "idx_products_brand", columnList = "brand_id"),
                @Index(name = "idx_products_status", columnList = "status")
        })
@SQLDelete(sql = "UPDATE products SET deleted_by = ?, deleted_at = now() WHERE product_id = ?")
@Where(clause = "deleted_at IS NULL")
public class Product extends AuditMetadata {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "product_id", length = 36)
    String id;

    @Column(length = 255, nullable = false)
    String name;

    @Lob
    @Column(columnDefinition = "text")
    String description;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "brand_id")
    Brand brand;

    @Column(length = 255, nullable = false, unique = true)
    String slug;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    ProductStatus status = ProductStatus.DRAFT;
}

package com.business.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import jakarta.persistence.UniqueConstraint;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(
        name = "product_categories",
        indexes = {
                @Index(name = "idx_pc_product", columnList = "product_id"),
                @Index(name = "idx_pc_category", columnList = "category_id")
        },
        uniqueConstraints = @UniqueConstraint(name = "uk_product_category", columnNames = {
                "product_id", "category_id"})
)
public class ProductCategory {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(length = 36)
    String id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    Product product;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id", nullable = false)
    Category category;
}

package com.business.entity;

import com.business.entity.audit.AuditMetadata;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;
import org.hibernate.annotations.SQLDelete;
import org.hibernate.annotations.Where;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(
        name = "product_images",
        indexes = {
                @Index(name = "idx_images_product", columnList = "product_id"),
                @Index(name = "idx_images_variant", columnList = "variant_id"),
                @Index(name = "idx_images_thumbnail", columnList = "is_thumbnail")
        })
@SQLDelete(sql = "UPDATE product_images SET deleted_by = ?, deleted_at = now() WHERE image_id = ?")
@Where(clause = "deleted_at IS NULL")
public class ProductImage extends AuditMetadata {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "image_id", length = 36)
    String id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id")
    Product product;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "variant_id")
    ProductVariant variant;

    @Column(name = "image_url", length = 255, nullable = false)
    String imageUrl;

    @Column(name = "is_thumbnail", nullable = false)
    Boolean thumbnail = false;
}

package com.business.entity;

import com.business.entity.audit.AuditMetadata;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;
import org.hibernate.annotations.SQLDelete;
import org.hibernate.annotations.Where;

import java.math.BigDecimal;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(
        name = "product_variants",
        indexes = {
                @Index(name = "idx_variants_product", columnList = "product_id"),
                @Index(name = "idx_variants_sku", columnList = "sku"),
                @Index(name = "idx_variants_price", columnList = "price")
        })
@SQLDelete(sql = "UPDATE product_variants SET deleted_by = ?, deleted_at = now() WHERE variant_id = ?")
@Where(clause = "deleted_at IS NULL")
public class ProductVariant extends AuditMetadata {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "variant_id", length = 36)
    String id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    Product product;

    @Column(length = 100, nullable = false, unique = true)
    String sku;

    @Column(precision = 10, scale = 2, nullable = false)
    BigDecimal price;

    @Column(name = "original_price", precision = 10, scale = 2)
    BigDecimal originalPrice;
}

package com.business.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import jakarta.persistence.UniqueConstraint;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(
        name = "variant_attribute_values",
        indexes = {
                @Index(name = "idx_vav_variant", columnList = "variant_id"),
                @Index(name = "idx_vav_attribute", columnList = "attribute_id")
        },
        uniqueConstraints = @UniqueConstraint(name = "uk_variant_attribute", columnNames = {
                "variant_id", "attribute_id"})
)
public class VariantAttributeValue {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(length = 36)
    String id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "variant_id", nullable = false)
    ProductVariant variant;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "attribute_id", nullable = false)
    Attribute attribute;
}

package com.business.entity.audit;

import jakarta.persistence.Column;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;
import lombok.experimental.FieldDefaults;
import org.springframework.data.annotation.CreatedBy;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedBy;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;

@Getter
@Setter
@ToString
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
@FieldDefaults(level = AccessLevel.PROTECTED)
public class AuditMetadata implements SoftDeletable {
    /* ---- create ---- */
    @CreatedBy
    @Column(name = "created_by")
    String createdBy;

    @CreatedDate
    @Column(name = "created_at")
    Instant createdAt;

    /* ---- update ---- */
    @LastModifiedBy
    @Column(name = "updated_by")
    String updatedBy;

    @LastModifiedDate
    @Column(name = "updated_at")
    Instant updatedAt;

    /* ---- soft-delete ---- */
    @Column(name = "deleted_by")
    String deletedBy;

    @Column(name = "deleted_at")
    Instant deletedAt;

    @Override
    public void markDeleted(String by) {
        this.deletedBy = by;
        this.deletedAt = Instant.now();
    }

    @Override
    public boolean isDeleted() {
        return deletedAt != null;
    }
}


package com.business.entity.audit;

public interface SoftDeletable {
    void markDeleted(String by);

    boolean isDeleted();

    String getDeletedBy();
}


package com.business.repository;

import com.business.entity.Attribute;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

@Repository
public interface AttributesRepository
    extends JpaRepository<Attribute, String> {

  @Query(value = "update attributes set deleted_at = null, deleted_by = null where attribute_id = :id", nativeQuery = true)
  @Modifying
  int nativeRestore(@Param("id") String id);

  @Query("""
      select a from Attribute a
       where (:q is null or :q = '' or lower(a.name) like lower(concat('%', :q, '%')) or lower(a.value) like lower(concat('%', :q, '%')))
       order by a.createdAt desc
    """)
  Page<Attribute> search(@Param("q") String q, Pageable pageable);
}

package com.business.repository;

import com.business.entity.Brand; // entity sẵn có
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.*;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface BrandsRepository
        extends JpaRepository<Brand, String> {

    Optional<Brand> findBySlug(String slug);

    @Query(value = """
       update brands
          set deleted_at = null, deleted_by = null
        where id = :id
       """, nativeQuery = true)
    @Modifying
    int nativeRestore(@Param("id") String id);

    @Query(value = """
        select b from Brand b
         where ( :q is null or :q = ''
                 or lower(b.name) like lower(concat('%', :q, '%'))
                 or lower(b.slug) like lower(concat('%', :q, '%')) )
        order by b.createdAt desc
       """)
    Page<Brand> search(@Param("q") String q, Pageable pageable);
}

package com.business.repository;

import com.business.entity.Category;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.*;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface CategoriesRepository
        extends JpaRepository<Category, String> {

    Optional<Category> findBySlug(String slug);

    @Query(value = """
       update categories
          set deleted_at = null, deleted_by = null
        where id = :id
       """, nativeQuery = true)
    @Modifying
    int nativeRestore(@Param("id") String id);

    @Query("""
        select c from Category c
         where (:q is null or :q = ''
               or lower(c.name) like lower(concat('%', :q, '%'))
               or lower(c.slug) like lower(concat('%', :q, '%')) )
         order by c.createdAt desc
    """)
    Page<Category> search(@Param("q") String q, Pageable pageable);


    List<Category> findByParentIdOrderByNameAsc(String parentId);
}

package com.business.repository;

import com.business.entity.Discount;
import java.time.Instant;
import java.util.Optional;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

@Repository
public interface DiscountsRepository extends JpaRepository<Discount, String> {

  Optional<Discount> findByCode(String code);

  @Query(value = "update discounts set deleted_at = null, deleted_by = null where discount_id = :id", nativeQuery = true)
  @Modifying
  int nativeRestore(
      @Param("id") String id);

  @Query("""
      select d from Discount d
       where (:only = false
              or (d.active = true
                  and (d.startDate is null or d.startDate <= :at)
                  and (d.endDate is null or d.endDate >= :at)))
       order by d.createdAt desc
    """)
  Page<Discount> listEffective(
      @Param("only") boolean only,
      @Param("at") Instant at,
      Pageable pageable);
}


package com.business.repository;

import com.business.entity.ProductCategory;
import org.springframework.data.jpa.repository.*;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

@Repository
public interface ProductCategoriesRepository
        extends JpaRepository<ProductCategory, String> {

    @Query("""
      select count(pc) > 0 from ProductCategory pc
       where pc.product.id = :productId and pc.category.id = :categoryId
    """)
    boolean existsLink(
            @Param("productId") String productId,
            @Param("categoryId") String categoryId
    );

    @Modifying
    @Query("""
      delete from ProductCategory pc
       where pc.product.id = :productId and pc.category.id = :categoryId
    """)
    int deleteLink(
            @Param("productId") String productId,
            @Param("categoryId") String categoryId
    );
}


package com.business.repository;

import com.business.entity.ProductImage;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

@Repository
public interface ProductImagesRepository
    extends JpaRepository<ProductImage, String> {

  @Query(value = "update product_images set deleted_at = null, deleted_by = null where image_id = :id", nativeQuery = true)
  @Modifying
  int nativeRestore(
      @Param("id") String id);

  @Query("""
      select i from ProductImage i
       where (:productId is null or i.product.id = :productId)
         and (:variantId is null or i.variant.id = :variantId)
       order by i.createdAt desc
    """)
  Page<ProductImage> search(
      @Param("productId") String productId,
      @Param("variantId") String variantId,
      Pageable pageable);

  @Modifying
  @Query("""
      update ProductImage i set i.thumbnail = false
       where (:productId is null or i.product.id = :productId)
         and (:variantId is null or i.variant.id = :variantId)
         and i.thumbnail = true
    """)
  int unsetAllThumbnail(
      @Param("productId") String productId,
      @Param("variantId") String variantId);
}

package com.business.repository;

import com.business.constant.ProductStatus;
import com.business.entity.Product;
import org.springframework.data.jpa.repository.*;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import org.springframework.data.domain.*;

import java.util.Optional;

@Repository
public interface ProductsRepository
        extends JpaRepository<Product, String> {

    Optional<Product> findBySlug(String slug);

    @Query(value = """
       update products
          set deleted_at = null, deleted_by = null
        where id = :id
       """, nativeQuery = true)
    @Modifying
    int nativeRestore(@Param("id") String id);

    @Query("""
      select p from Product p
       left join ProductCategory pc on pc.product.id = p.id
      where (:q is null or :q = ''
             or lower(p.name) like lower(concat('%', :q, '%'))
             or lower(p.slug) like lower(concat('%', :q, '%'))
             or lower(p.description) like lower(concat('%', :q, '%')))
        and (:brandId is null or :brandId = '' or p.brand.id = :brandId)
        and (:categoryId is null or :categoryId = '' or pc.category.id = :categoryId)
        and (:status is null or p.status = :status)
      group by p
      order by p.createdAt desc
    """)
    Page<Product> filter(
            @Param("q") String q,
            @Param("brandId") String brandId,
            @Param("categoryId") String categoryId,
            @Param("status") ProductStatus status,
            Pageable pageable);
}

package com.business.repository;

import com.business.entity.ProductVariant;
import java.util.Optional;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

@Repository
public interface ProductVariantsRepository
    extends JpaRepository<ProductVariant, String> {

  Optional<ProductVariant> findBySku(String sku);

  @Query(value = "update product_variants set deleted_at = null, deleted_by = null where variant_id = :id", nativeQuery = true)
  @Modifying
  int nativeRestore(@Param("id") String id);

  @Query("""
      select v from ProductVariant v
       where v.product.id = :productId
       order by v.createdAt desc
    """)
  Page<ProductVariant> listByProduct(
      @Param("productId") String productId,
      Pageable pageable);
}

package com.business.repository;

import com.business.entity.Attribute;
import com.business.entity.VariantAttributeValue;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

@Repository
public interface VariantAttributeValuesRepository
    extends JpaRepository<VariantAttributeValue, String> {

  @Query("""
      select (count(vav) > 0) from VariantAttributeValue vav
       where vav.variant.id = :variantId and vav.attribute.id = :attributeId
    """)
  boolean existsLink(
      @Param("variantId") String variantId,
      @Param("attributeId") String attributeId);

  @Modifying
  @Query("""
      delete from VariantAttributeValue vav
       where vav.variant.id = :variantId and vav.attribute.id = :attributeId
    """)
  int deleteLink(@Param("variantId") String variantId, @Param("attributeId") String attributeId);

  @Query("""
      select a from VariantAttributeValue vav join vav.attribute a
       where vav.variant.id = :variantId
       order by a.name asc
    """)
  Page<Attribute> listAttributes(
      @Param("variantId") String variantId,
      Pageable pageable);
}

package com.business.dto.model;

import com.business.dto.response.CategoryResponseDto;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.List;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CategoryTreeNode {
    CategoryResponseDto data;
    List<CategoryTreeNode> children;
}

package com.business.dto.model;

import java.math.BigDecimal;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class DiscountValidation {
  boolean valid;
  String reason;
  BigDecimal amount;
}

package com.business.dto.request;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class AttributeCreateRequestDto {
  String name;
  String value;
}

package com.business.dto.request;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class BrandCreateRequestDto {
    String name;
    String slug;
    String description;
}

package com.business.dto.request;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class BrandUpdateRequestDto {
    String name;
    String slug;
    String description;
}


package com.business.dto.request;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CategoryCreateRequestDto {
    String name;
    String slug;
    String description;
    String parentId;
}

package com.business.dto.request;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CategoryUpdateRequestDto {
    String name;
    String slug;
    String description;
}

package com.business.dto.request;

import com.business.constant.DiscountType;
import java.math.BigDecimal;
import java.time.Instant;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class DiscountCreateRequestDto {
  String code;
  DiscountType type;
  BigDecimal value;
  Instant startDate;
  Instant endDate;
  BigDecimal minOrderValue;
  Boolean active;
}

package com.business.dto.request;

import com.business.constant.DiscountType;
import java.math.BigDecimal;
import java.time.Instant;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class DiscountUpdateRequestDto {
  String code;
  DiscountType type;
  BigDecimal value;
  Instant startDate;
  Instant endDate;
  BigDecimal minOrderValue;
  Boolean active;
}


package com.business.dto.request;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ImageCreateRequestDto {
  String productId;
  String variantId;
  String imageUrl;
}

package com.business.dto.request;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ProductCreateRequestDto {
    String name;
    String slug;
    String description;
    String brandId;
}

package com.business.dto.request;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ProductUpdateRequestDto {
    String name;
    String slug;
    String description;
    String brandId;
}

package com.business.dto.request;

import java.math.BigDecimal;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class VariantCreateRequestDto {
  String productId;
  String sku;
  BigDecimal price;
  BigDecimal originalPrice;
}


package com.business.dto.request;

import java.math.BigDecimal;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class VariantUpdateRequestDto {
  String sku;
  BigDecimal price;
  BigDecimal originalPrice;
}

package com.business.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class AttributeResponseDto {
  String id;
  String name;
  String value;
}

package com.business.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class BrandResponseDto {
    String id;
    String name;
    String slug;
    String description;
}

package com.business.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CategoryResponseDto {
    String id;
    String name;
    String slug;
    String description;
    String parentId;
}

package com.business.dto.response;

import com.business.constant.DiscountType;
import java.math.BigDecimal;
import java.time.Instant;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class DiscountResponseDto {
  String id;
  String code;
  DiscountType type;
  BigDecimal value;
  Instant startDate;
  Instant endDate;
  BigDecimal minOrderValue;
  Boolean active;
}

package com.business.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ImageResponseDto {
  String id;
  String productId;
  String variantId;
  String imageUrl;
  Boolean thumbnail;
}

package com.business.dto.response;

import com.business.constant.ProductStatus;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ProductResponseDto {
    String id;
    String name;
    String slug;
    String description;
    ProductStatus status;
    String brandId;
}

package com.business.dto.response;

import java.math.BigDecimal;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class VariantResponseDto {
  String id;
  String productId;
  String sku;
  BigDecimal price;
  BigDecimal originalPrice;
}


package com.business.mapper;

import com.business.dto.request.AttributeCreateRequestDto;
import com.business.dto.response.AttributeResponseDto;
import com.business.entity.Attribute;
import org.mapstruct.Mapper;
import org.mapstruct.NullValuePropertyMappingStrategy;
import org.mapstruct.ReportingPolicy;

@Mapper(
    componentModel = "spring",
    unmappedTargetPolicy = ReportingPolicy.IGNORE,
    nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public interface AttributeMapper {
  Attribute toAttributeFromAttributeCreateRequestDto(
      AttributeCreateRequestDto dto);
  AttributeResponseDto toAttributeResponseDtoFromAttribute(
      Attribute a);
}

package com.business.mapper;

import com.business.dto.request.BrandCreateRequestDto;
import com.business.dto.request.BrandUpdateRequestDto;
import com.business.dto.response.BrandResponseDto;
import com.business.entity.Brand;
import org.mapstruct.Mapper;
import org.mapstruct.MappingTarget;
import org.mapstruct.NullValuePropertyMappingStrategy;
import org.mapstruct.ReportingPolicy;

@Mapper(componentModel = "spring",
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public interface BrandMapper {
    Brand toBrandFromBrandCreateRequestDto(
            BrandCreateRequestDto brandCreateRequestDto);

    void patchBrandFromBrandUpdateRequestDto(
            @MappingTarget Brand brand,
            BrandUpdateRequestDto brandUpdateRequestDto
    );

    BrandResponseDto toBrandResponseDtoFromBrand(
            Brand brand
    );
}

package com.business.mapper;

import com.business.dto.request.CategoryCreateRequestDto;
import com.business.dto.request.CategoryUpdateRequestDto;
import com.business.dto.response.CategoryResponseDto;
import com.business.entity.Category;
import org.mapstruct.Mapper;
import org.mapstruct.MappingTarget;
import org.mapstruct.NullValuePropertyMappingStrategy;
import org.mapstruct.ReportingPolicy;

@Mapper(componentModel = "spring",
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public interface CategoryMapper {
    Category toCategoryFromCategoryCreateRequestDto(
            CategoryCreateRequestDto categoryCreateRequestDto);
    void patchCategoryFromCategoryUpdateRequestDto(
            @MappingTarget Category category,
            CategoryUpdateRequestDto categoryUpdateRequestDto
    );
    CategoryResponseDto toCategoryResponseDtoFromCategory(
            Category category);
}

package com.business.mapper;

import com.business.dto.request.DiscountCreateRequestDto;
import com.business.dto.request.DiscountUpdateRequestDto;
import com.business.dto.response.DiscountResponseDto;
import com.business.entity.Discount;
import org.mapstruct.Mapper;
import org.mapstruct.MappingTarget;
import org.mapstruct.NullValuePropertyMappingStrategy;
import org.mapstruct.ReportingPolicy;

@Mapper(
    componentModel = "spring",
    unmappedTargetPolicy = ReportingPolicy.IGNORE,
    nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public interface DiscountMapper {
  Discount toDiscountFromDiscountCreateRequestDto(DiscountCreateRequestDto dto);
  void patchDiscountFromDiscountUpdateRequestDto(
      @MappingTarget Discount target,
      DiscountUpdateRequestDto dto);
  DiscountResponseDto toDiscountResponseDtoFromDiscount(
      Discount d);
}

package com.business.mapper;

import com.business.dto.request.ImageCreateRequestDto;
import com.business.dto.response.ImageResponseDto;
import com.business.entity.ProductImage;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.Mappings;
import org.mapstruct.NullValuePropertyMappingStrategy;
import org.mapstruct.ReportingPolicy;

@Mapper(
    componentModel = "spring",
    unmappedTargetPolicy = ReportingPolicy.IGNORE,
    nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public interface ProductImageMapper {
  @Mapping(source = "productId", target = "product.id")
  @Mapping(source = "variantId", target = "variant.id")
  ProductImage toProductImageFromImageCreateRequestDto(ImageCreateRequestDto dto);
  @Mappings({
      @Mapping(source = "product.id", target = "productId"),
      @Mapping(source = "variant.id", target = "variantId"),
      @Mapping(source = "thumbnail", target = "thumbnail")
  })
  ImageResponseDto toImageResponseDtoFromProductImage(ProductImage i);
}


package com.business.mapper;

import com.business.dto.request.ProductCreateRequestDto;
import com.business.dto.request.ProductUpdateRequestDto;
import com.business.dto.response.ProductResponseDto;
import com.business.entity.Product;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.NullValuePropertyMappingStrategy;
import org.mapstruct.ReportingPolicy;

@Mapper(
        componentModel = "spring",
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE
)
public interface ProductMapper {
    Product toProductFromProductCreateRequestDto(
            ProductCreateRequestDto productCreateRequestDto);
    void patchProductFromProductUpdateRequestDto(
            @MappingTarget Product target,
            ProductUpdateRequestDto dto
    );
    @Mapping(source = "brand.id", target = "brandId")
    ProductResponseDto toProductResponseDtoFromProduct(
            Product product);
}

package com.business.mapper;

import com.business.dto.request.VariantCreateRequestDto;
import com.business.dto.request.VariantUpdateRequestDto;
import com.business.dto.response.VariantResponseDto;
import com.business.entity.ProductVariant;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.NullValuePropertyMappingStrategy;
import org.mapstruct.ReportingPolicy;

@Mapper(
    componentModel = "spring",
    unmappedTargetPolicy = ReportingPolicy.IGNORE,
    nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public interface VariantMapper {
  @Mapping(source = "productId", target = "product.id")
  ProductVariant toVariantFromVariantCreateRequestDto(
      VariantCreateRequestDto dto);
  void patchVariantFromVariantUpdateRequestDto(
      @MappingTarget ProductVariant target,
      VariantUpdateRequestDto dto);
  @Mapping(source = "product.id", target = "productId")
  VariantResponseDto toVariantResponseDtoFromVariant(
      ProductVariant v);
}

package com.business.helper;

import lombok.experimental.UtilityClass;
import org.common.exception.AppException;
import org.common.exception.ErrorCode;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;

import java.util.Set;
import java.util.stream.Collectors;

@UtilityClass
public class AuthenticationHelper {
    public String getMyUserId() {
        Authentication a = SecurityContextHolder.getContext().getAuthentication();
        if (a == null || a.getName() == null) throw new AppException(ErrorCode.UNAUTHENTICATED);
        return a.getName();
    }

    public Set<String> getMyRoles() {
        Authentication a = SecurityContextHolder.getContext().getAuthentication();
        if (a == null) throw new AppException(ErrorCode.UNAUTHENTICATED);
        return a.getAuthorities()
                .stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.toSet());
    }

    public void requireAdmin() {
        if (!getMyRoles().contains("ROLE_ADMIN") && !getMyRoles().contains("ADMIN")) {
            throw new AppException(ErrorCode.UNAUTHORIZED);
        }
    }
}

package com.business.exception;

import lombok.extern.slf4j.Slf4j;
import org.common.exception.AppException;
import org.common.exception.ErrorCode;
import org.common.http.Envelope;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

@Slf4j
@ControllerAdvice
@ConditionalOnProperty(
        name = "core.http.error.enabled",
        havingValue = "true",
        matchIfMissing = false
)
public class GlobalExceptionHandler {

    @ExceptionHandler(AppException.class)
    public ResponseEntity<Envelope<Void>> handleAppException(
            AppException appException){
        ErrorCode errorCode = appException.getErrorCode();
        return ResponseEntity.status(errorCode.getStatusCode())
                .body(Envelope.err(
                        errorCode.http(),
                        errorCode.name(),
                        errorCode.getMessage(),
                        null)
                );
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Envelope<Void>> handleAnyException(
            Exception exception){
        ErrorCode errorCode = ErrorCode.UNCATEGORIZED_EXCEPTION;
        return ResponseEntity.status(errorCode.getStatusCode())
                .body(Envelope.err(
                        errorCode.http(),
                        errorCode.name(),
                        errorCode.getMessage(),
                        null)
                );
    }
}

package com.business.service;

import com.business.dto.request.AttributeCreateRequestDto;
import com.business.dto.response.AttributeResponseDto;
import org.common.http.Envelope;

public interface IAttributeService {
  void create(AttributeCreateRequestDto dto);
  void softDelete(String id);
  void restore(String id);
  Envelope.Page<AttributeResponseDto> list(
      String q,
      int page, int size);

  void assignToVariant(
      String variantId,
      String attributeId);
  void unassignFromVariant(
      String variantId,
      String attributeId);
  Envelope.Page<AttributeResponseDto> listByVariant(
      String variantId,
      int page, int size);
}

package com.business.service;

import com.business.dto.request.BrandCreateRequestDto;
import com.business.dto.request.BrandUpdateRequestDto;
import com.business.dto.response.BrandResponseDto;
import org.common.http.Envelope;

public interface IBrandService {
    void create(BrandCreateRequestDto brandCreateRequestDto);

    void update(String id, BrandUpdateRequestDto brandUpdateRequestDto);

    void softDelete(String id);

    void restore(String id);

    BrandResponseDto getById(String id);

    BrandResponseDto getBySlug(String slug);

    Envelope.Page<BrandResponseDto> list(
            String q,
            int page, int size
    );
}

package com.business.service;

import com.business.dto.model.CategoryTreeNode;
import com.business.dto.request.CategoryCreateRequestDto;
import com.business.dto.request.CategoryUpdateRequestDto;
import com.business.dto.response.CategoryResponseDto;
import org.common.http.Envelope;

public interface ICategoryService {
    void create(CategoryCreateRequestDto categoryCreateRequestDto);

    void update(
            String id,
            CategoryUpdateRequestDto categoryUpdateRequestDto
    );

    void softDelete(String id);

    void restore(String id);

    void reparent(String id, String newParentId);

    CategoryResponseDto getById(String id);

    CategoryResponseDto getBySlug(String slug);

    Envelope.Page<CategoryResponseDto> list(
            String q,
            int page, int size
    );

    // tree/children
    CategoryTreeNode tree();

    Envelope.Page<CategoryResponseDto> children(
            String id,
            int page, int size
    );
}

package com.business.service;

import com.business.dto.model.DiscountValidation;
import com.business.dto.request.DiscountCreateRequestDto;
import com.business.dto.request.DiscountUpdateRequestDto;
import com.business.dto.response.DiscountResponseDto;
import java.math.BigDecimal;
import java.time.Instant;
import org.common.http.Envelope;

public interface IDiscountService {
  void create(DiscountCreateRequestDto dto);
  void update(String id, DiscountUpdateRequestDto dto);
  void softDelete(String id);
  void restore(String id);
  void toggleActive(String id, boolean active);

  DiscountResponseDto getByCode(String code);
  DiscountValidation validateAndAmount(
      String code,
      BigDecimal orderValue,
      Instant at
  );
  Envelope.Page<DiscountResponseDto> list(
      boolean onlyEffective,
      Instant at,
      int page, int size
  );
}

package com.business.service;

import com.business.dto.request.ImageCreateRequestDto;
import com.business.dto.response.ImageResponseDto;
import org.common.http.Envelope;

public interface IProductImageService {
  void create(ImageCreateRequestDto dto);
  void softDelete(String id);
  void restore(String id);
  void setThumbnail(String id);
  void unsetThumbnail(String id);
  Envelope.Page<ImageResponseDto> list(
      String productId,
      String variantId,
      int page, int size
  );
}

package com.business.service;

import com.business.constant.ProductStatus;
import com.business.dto.request.ProductCreateRequestDto;
import com.business.dto.request.ProductUpdateRequestDto;
import com.business.dto.response.ProductResponseDto;
import org.common.http.Envelope;

public interface IProductService {
    void create(ProductCreateRequestDto productCreateRequestDto);

    void update(
            String id,
            ProductUpdateRequestDto productUpdateRequestDto
    );

    void softDelete(String id);

    void restore(String id);

    void publish(String id);

    void unpublish(String id);

    void archive(String id);

    ProductResponseDto getById(String id);

    ProductResponseDto getBySlug(String slug);

    Envelope.Page<ProductResponseDto> list(
            String q,
            String brandId,
            String categoryId,
            ProductStatus status,
            int page, int size);

    void assignCategory(String productId, String categoryId);

    void unassignCategory(String productId, String categoryId);
}

package com.business.service;

import com.business.dto.request.VariantCreateRequestDto;
import com.business.dto.request.VariantUpdateRequestDto;
import com.business.dto.response.VariantResponseDto;
import java.math.BigDecimal;
import org.common.http.Envelope;

public interface IVariantService {
  void create(VariantCreateRequestDto dto);
  void update(String id, VariantUpdateRequestDto dto);
  void softDelete(String id);
  void restore(String id);
  VariantResponseDto findBySku(String sku);
  void patchPrice(String id, BigDecimal price, BigDecimal originalPrice);
  Envelope.Page<VariantResponseDto> listByProduct(String productId, int page, int size);
}

package com.business.service.impl;

import com.business.dto.request.AttributeCreateRequestDto;
import com.business.dto.response.AttributeResponseDto;
import com.business.entity.Attribute;
import com.business.entity.ProductVariant;
import com.business.entity.VariantAttributeValue;
import com.business.helper.AuthenticationHelper;
import com.business.mapper.AttributeMapper;
import com.business.repository.AttributesRepository;
import com.business.repository.ProductVariantsRepository;
import com.business.repository.VariantAttributeValuesRepository;
import com.business.service.IAttributeService;
import java.util.List;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import org.common.exception.AppException;
import org.common.exception.ErrorCode;
import org.common.http.Envelope;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class AttributeService implements IAttributeService {
  AttributesRepository attributesRepository;
  ProductVariantsRepository productVariantsRepository;
  VariantAttributeValuesRepository variantAttributeValuesRepository;
  AttributeMapper attributeMapper;

  @Override
  public void create(
      AttributeCreateRequestDto dto) {
    AuthenticationHelper.requireAdmin();
    attributesRepository.save(attributeMapper
        .toAttributeFromAttributeCreateRequestDto(dto));
  }

  @Override
  public void softDelete(String id) {
    AuthenticationHelper.requireAdmin();
    Attribute a = attributesRepository.findById(id)
        .orElseThrow(() -> new AppException(ErrorCode.ATTRIBUTE_NOT_FOUND));
    a.markDeleted(AuthenticationHelper.getMyUserId());
    attributesRepository.save(a);
  }

  @Override
  public void restore(String id) {
    AuthenticationHelper.requireAdmin();
    if (attributesRepository.nativeRestore(id) == 0) {
      throw new AppException(ErrorCode.ATTRIBUTE_NOT_FOUND);
    }
  }

  @Override
  public Envelope.Page<AttributeResponseDto> list(
      String q,
      int page,
      int size) {
    Page<Attribute> p = attributesRepository.search(q,
        PageRequest.of(page,
            size));
    List<AttributeResponseDto>
        docs = p.getContent()
        .stream()
        .map(attributeMapper::toAttributeResponseDtoFromAttribute)
        .toList();
    return Envelope.okPage(
        p.getNumber(),
        p.getSize(),
        p.getTotalElements(),
        p.getTotalPages(),
        docs).getData();
  }

  @Override
  public void assignToVariant(
      String variantId, String attributeId) {
    AuthenticationHelper.requireAdmin();
    productVariantsRepository.findById(variantId)
        .orElseThrow(() -> new AppException(ErrorCode.VARIANT_NOT_FOUND));
    attributesRepository.findById(attributeId)
        .orElseThrow(() -> new AppException(ErrorCode.ATTRIBUTE_NOT_FOUND));
    if (variantAttributeValuesRepository.existsLink(variantId, attributeId)) return;
    VariantAttributeValue vav = VariantAttributeValue.builder()
        .variant(ProductVariant.builder().id(variantId).build())
        .attribute(Attribute.builder().id(attributeId).build())
        .build();
    variantAttributeValuesRepository.save(vav);
  }
  @Override public void unassignFromVariant(
      String variantId, String attributeId) {
    AuthenticationHelper.requireAdmin();
    variantAttributeValuesRepository.deleteLink(variantId, attributeId);
  }
  @Override public Envelope.Page<AttributeResponseDto> listByVariant(
      String variantId, int page, int size) {
    Page<Attribute> p = variantAttributeValuesRepository.listAttributes(
        variantId, PageRequest.of(page, size));
    List<AttributeResponseDto> docs = p.getContent()
        .stream()
        .map(attributeMapper::toAttributeResponseDtoFromAttribute)
        .toList();
    return Envelope.okPage(
        p.getNumber(),
        p.getSize(),
        p.getTotalElements(),
        p.getTotalPages(),
        docs
    ).getData();
  }
}

package com.business.service.impl;

import com.business.dto.request.BrandCreateRequestDto;
import com.business.dto.request.BrandUpdateRequestDto;
import com.business.dto.response.BrandResponseDto;
import com.business.entity.Brand;
import com.business.helper.AuthenticationHelper;
import com.business.mapper.BrandMapper;
import com.business.repository.BrandsRepository;
import com.business.service.IBrandService;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import org.common.exception.AppException;
import org.common.exception.ErrorCode;
import org.common.http.Envelope;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class BrandServiceImpl implements IBrandService {

    BrandsRepository brandsRepository;
    BrandMapper brandMapper;

    @Override @Transactional
    public void create(BrandCreateRequestDto brandCreateRequestDto) {
        Brand b = brandMapper.toBrandFromBrandCreateRequestDto(
                brandCreateRequestDto);
        brandsRepository.save(b);
    }

    @Override @Transactional
    public void update(
            String id,
            BrandUpdateRequestDto brandUpdateRequestDto) {
        Brand b = brandsRepository.findById(id)
                .orElseThrow(() -> new AppException(ErrorCode.BRAND_NOT_FOUND));
        brandMapper.patchBrandFromBrandUpdateRequestDto(b, brandUpdateRequestDto);
        brandsRepository.save(b);
    }

    @Override
    @Transactional
    public void softDelete(String id) {
        Brand b = brandsRepository.findById(id)
                .orElseThrow(() -> new AppException(ErrorCode.BRAND_NOT_FOUND));
        b.markDeleted(AuthenticationHelper.getMyUserId());
        brandsRepository.save(b);
    }

    @Override
    @Transactional
    public void restore(String id) {
        brandsRepository.findById(id)
                .orElseThrow(() -> new AppException(ErrorCode.BRAND_NOT_FOUND));
        int n = brandsRepository.nativeRestore(id);
        if (n == 0) {
            throw new AppException(ErrorCode.BRAND_NOT_FOUND);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public BrandResponseDto getById(String id) {
        return brandsRepository.findById(id)
                .map(brandMapper::toBrandResponseDtoFromBrand)
                .orElseThrow(() -> new AppException(ErrorCode.BRAND_NOT_FOUND));
    }

    @Override
    @Transactional(readOnly = true)
    public BrandResponseDto getBySlug(String slug) {
        return brandsRepository.findBySlug(slug)
                .map(brandMapper::toBrandResponseDtoFromBrand)
                .orElseThrow(() -> new AppException(ErrorCode.BRAND_NOT_FOUND));
    }

    @Override @Transactional(readOnly = true)
    public Envelope.Page<BrandResponseDto> list(
            String q,
            int page, int size) {
        Page<Brand> p = brandsRepository.search(q, PageRequest.of(page, size));
        return Envelope.Page.<BrandResponseDto>builder()
                .page(page)
                .size(size)
                .total(p.getTotalElements())
                .totalPages(Math.max(1, p.getTotalPages()))
                .docs(p.map(brandMapper::toBrandResponseDtoFromBrand).getContent())
                .build();
    }
}


package com.business.service.impl;

import com.business.dto.request.CategoryCreateRequestDto;
import com.business.dto.request.CategoryUpdateRequestDto;
import com.business.dto.response.CategoryResponseDto;
import com.business.entity.Category;
import com.business.helper.AuthenticationHelper;
import com.business.mapper.CategoryMapper;
import com.business.repository.CategoriesRepository;
import com.business.service.ICategoryService;
import com.business.dto.model.CategoryTreeNode;
import lombok.*;
import lombok.experimental.FieldDefaults;
import org.common.exception.AppException;
import org.common.exception.ErrorCode;
import org.common.http.Envelope;
import org.springframework.data.domain.*;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class CategoryServiceImpl implements ICategoryService {

    CategoriesRepository categoriesRepository;
    CategoryMapper categoryMapper;

    @Override
    @Transactional
    public void create(CategoryCreateRequestDto categoryCreateRequestDto) {
        Category c = categoryMapper.toCategoryFromCategoryCreateRequestDto(
                categoryCreateRequestDto);
        if (categoryCreateRequestDto.getParentId() != null
                && !categoryCreateRequestDto.getParentId().isBlank()) {
            categoriesRepository.findById(categoryCreateRequestDto.getParentId())
                    .orElseThrow(() -> new AppException(ErrorCode.CATEGORY_NOT_FOUND));
            c.getParent().setId(categoryCreateRequestDto.getParentId());
        } else {
            c.getParent().setId(null);
        }
        categoriesRepository.save(c);
    }

    @Override
    @Transactional
    public void update(
            String id,
            CategoryUpdateRequestDto categoryUpdateRequestDto) {
        Category c = categoriesRepository.findById(id)
                .orElseThrow(() -> new AppException(ErrorCode.CATEGORY_NOT_FOUND));
        categoryMapper.patchCategoryFromCategoryUpdateRequestDto(c,
                categoryUpdateRequestDto);
        categoriesRepository.save(c);
    }

    @Override
    @Transactional
    public void softDelete(String id) {
        Category c = categoriesRepository.findById(id)
                .orElseThrow(() -> new AppException(ErrorCode.CATEGORY_NOT_FOUND));
        c.markDeleted(AuthenticationHelper.getMyUserId());
        categoriesRepository.save(c);
    }

    @Override
    @Transactional
    public void restore(String id) {
        categoriesRepository.findById(id)
                .orElseThrow(() -> new AppException(ErrorCode.CATEGORY_NOT_FOUND));
        int n = categoriesRepository.nativeRestore(id);
        if (n == 0) {
            throw new AppException(ErrorCode.CATEGORY_NOT_FOUND);
        }
    }

    @Override
    @Transactional
    public void reparent(String id, String newParentId) {
        Category c = categoriesRepository.findById(id)
                .orElseThrow(() -> new AppException(ErrorCode.CATEGORY_NOT_FOUND));
        if (newParentId == null || newParentId.isBlank()) {
            c.getParent().setId(null);
        } else {
            categoriesRepository.findById(newParentId)
                    .orElseThrow(() -> new AppException(ErrorCode.CATEGORY_NOT_FOUND));
            c.getParent().setId(newParentId);
        }
        categoriesRepository.save(c);
    }

    @Override
    @Transactional(readOnly = true)
    public CategoryResponseDto getById(String id) {
        return categoriesRepository.findById(id)
                .map(categoryMapper::toCategoryResponseDtoFromCategory)
                .orElseThrow(() -> new AppException(ErrorCode.CATEGORY_NOT_FOUND));
    }

    @Override
    @Transactional(readOnly = true)
    public CategoryResponseDto getBySlug(String slug) {
        return categoriesRepository.findBySlug(slug)
                .map(categoryMapper::toCategoryResponseDtoFromCategory)
                .orElseThrow(() -> new AppException(ErrorCode.CATEGORY_NOT_FOUND));
    }

    @Override
    @Transactional(readOnly = true)
    public Envelope.Page<CategoryResponseDto> list(
            String q,
            int page, int size) {
        Page<Category> p = categoriesRepository.search(q, PageRequest.of(page, size));
        return Envelope.Page.<CategoryResponseDto>builder()
                .page(page)
                .size(size)
                .total(p.getTotalElements())
                .totalPages(Math.max(1, p.getTotalPages()))
                .docs(p.map(categoryMapper::toCategoryResponseDtoFromCategory).getContent())
                .build();
    }

    @Override
    @Transactional(readOnly = true)
    public CategoryTreeNode tree() {
        List<Category> all = categoriesRepository.findAll(Sort.by("name")
                .ascending());
        Map<String, List<Category>> byParent = all.stream()
                .collect(Collectors.groupingBy(c -> Optional.ofNullable(c.getParent().getId())
                        .orElse("ROOT")));

        return CategoryTreeNode.builder()
                .data(null)
                .children(buildChildren("ROOT", byParent))
                .build();
    }

    private List<CategoryTreeNode> buildChildren(
            String parentKey,
            Map<String,List<Category>> byParent){
        return byParent.getOrDefault(parentKey, List.of())
                .stream()
                .map(c -> CategoryTreeNode.builder()
                        .data(categoryMapper.toCategoryResponseDtoFromCategory(c))
                        .children(buildChildren(c.getId(), byParent))
                        .build())
                .toList();
    }

    @Override
    @Transactional(readOnly = true)
    public Envelope.Page<CategoryResponseDto> children(
            String id,
            int page, int size) {
        String parent = (id == null || id.isBlank())
                ? null
                : id;
        List<CategoryResponseDto> docs = categoriesRepository
                .findByParentIdOrderByNameAsc(parent)
                .stream()
                .map(categoryMapper::toCategoryResponseDtoFromCategory)
                .toList();
        int total = docs.size();
        int from = Math.min(page*size, total);
        int to = Math.min(from+size, total);
        return Envelope.Page.<CategoryResponseDto>builder()
                .page(page)
                .size(size)
                .total(total)
                .totalPages((int)Math.max(1, Math.ceil(total/(double)size)))
                .docs(docs.subList(from, to))
                .build();
    }
}


package com.business.service.impl;

import com.business.dto.model.DiscountValidation;
import com.business.dto.request.DiscountCreateRequestDto;
import com.business.dto.request.DiscountUpdateRequestDto;
import com.business.dto.response.DiscountResponseDto;
import com.business.entity.Discount;
import com.business.helper.AuthenticationHelper;
import com.business.mapper.DiscountMapper;
import com.business.repository.DiscountsRepository;
import com.business.service.IDiscountService;
import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import org.common.exception.AppException;
import org.common.exception.ErrorCode;
import org.common.http.Envelope;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class DiscountService implements IDiscountService {
  DiscountsRepository repo;
  DiscountMapper mapper;

  @Override
  public void create(DiscountCreateRequestDto dto) {
    AuthenticationHelper.requireAdmin();
    repo.save(mapper.toDiscountFromDiscountCreateRequestDto(dto));
  }

  @Override public void update(
      String id,
      DiscountUpdateRequestDto dto) {
    AuthenticationHelper.requireAdmin();
    Discount d = repo.findById(id)
        .orElseThrow(() -> new AppException(ErrorCode.DISCOUNT_NOT_FOUND));
    mapper.patchDiscountFromDiscountUpdateRequestDto(d, dto);
    repo.save(d);
  }

  @Override public void softDelete(String id) {
    AuthenticationHelper.requireAdmin();
    Discount d = repo.findById(id)
        .orElseThrow(() -> new AppException(ErrorCode.IMAGE_NOT_FOUND));
    d.markDeleted(AuthenticationHelper.getMyUserId());
    repo.save(d);
  }

  @Override public void restore(String id) {
    AuthenticationHelper.requireAdmin();
    if (repo.nativeRestore(id)==0) {
      throw new AppException(ErrorCode.IMAGE_NOT_FOUND);
    }
  }
  @Override
  public void toggleActive(
      String id,
      boolean active) {
    AuthenticationHelper.requireAdmin();
    Discount d = repo.findById(id)
        .orElseThrow(() -> new AppException(ErrorCode.IMAGE_NOT_FOUND));
    d.setActive(active);
    repo.save(d);
  }
  @Override
  public DiscountResponseDto getByCode(String code) {
    Discount d = repo.findByCode(code)
        .orElseThrow(() -> new AppException(ErrorCode.IMAGE_NOT_FOUND));
    return mapper.toDiscountResponseDtoFromDiscount(d);
  }
  @Override public DiscountValidation validateAndAmount(
      String code, BigDecimal orderValue, Instant at) {
    Discount d = repo.findByCode(code).orElse(null);
    if (d == null) {
      return DiscountValidation.builder()
          .valid(false)
          .reason("NOT_FOUND")
          .amount(BigDecimal.ZERO)
          .build();
    }

    if (Boolean.FALSE.equals(d.getActive())) {
      return DiscountValidation.builder()
          .valid(false)
          .reason("INACTIVE")
          .amount(BigDecimal.ZERO)
          .build();
    }

    if (d.getStartDate() != null && at.isBefore(d.getStartDate())) {
      return DiscountValidation.builder()
          .valid(false)
          .reason("NOT_STARTED")
          .amount(BigDecimal.ZERO)
          .build();
    }

    if (d.getEndDate() != null && at.isAfter(d.getEndDate())) {
      return DiscountValidation.builder()
          .valid(false)
          .reason("EXPIRED")
          .amount(BigDecimal.ZERO)
          .build();
    }
    if (d.getMinOrderValue() != null && orderValue.compareTo(d.getMinOrderValue()) < 0) {
      return DiscountValidation.builder()
          .valid(false)
          .reason("MIN_ORDER_NOT_MET")
          .amount(BigDecimal.ZERO)
          .build();
    }

    BigDecimal amt = switch (d.getType()) {
      case percentage     -> orderValue.multiply(d.getValue()).movePointLeft(2);
      case fixed_amount   -> d.getValue();
    };
    if (amt.signum() < 0) {
      amt = BigDecimal.ZERO;
    }
    if (amt.compareTo(orderValue) > 0) {
      amt = orderValue;
    }
    return DiscountValidation.builder()
        .valid(true)
        .reason("OK")
        .amount(amt)
        .build();
  }
  @Override public Envelope.Page<DiscountResponseDto> list(
      boolean only,
      Instant at, int page, int size) {
    Page<Discount> p = repo.listEffective(only, at, PageRequest.of(page, size));
    List<DiscountResponseDto> docs = p.getContent()
        .stream()
        .map(mapper::toDiscountResponseDtoFromDiscount)
        .toList();

    return Envelope.okPage(
        p.getNumber(),
        p.getSize(),
        p.getTotalElements(),
        p.getTotalPages(),
        docs
    ).getData();
  }
}

package com.business.service.impl;

import com.business.dto.request.ImageCreateRequestDto;
import com.business.dto.response.ImageResponseDto;
import com.business.entity.ProductImage;
import com.business.helper.AuthenticationHelper;
import com.business.mapper.ProductImageMapper;
import com.business.repository.ProductImagesRepository;
import com.business.repository.ProductVariantsRepository;
import com.business.repository.ProductsRepository;
import com.business.service.IProductImageService;
import java.util.List;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import org.common.exception.AppException;
import org.common.exception.ErrorCode;
import org.common.http.Envelope;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class ProductImageService implements IProductImageService {
  ProductImagesRepository imagesRepo;
  ProductsRepository productsRepo;
  ProductVariantsRepository variantsRepo;
  ProductImageMapper mapper;

  @Override
  public void create(ImageCreateRequestDto dto) {
    AuthenticationHelper.requireAdmin();
    ProductImage i = mapper.toProductImageFromImageCreateRequestDto(dto);
    if (dto.getProductId()!=null) productsRepo.findById(dto.getProductId())
        .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
    if (dto.getVariantId()!=null) variantsRepo.findById(dto.getVariantId())
        .orElseThrow(() -> new AppException(ErrorCode.VARIANT_NOT_FOUND));
    imagesRepo.save(i);
  }
  @Override public void softDelete(String id) {
    AuthenticationHelper.requireAdmin();
    ProductImage i = imagesRepo.findById(id)
        .orElseThrow(() -> new AppException(ErrorCode.IMAGE_NOT_FOUND));
    i.markDeleted(AuthenticationHelper.getMyUserId());
    imagesRepo.save(i);
  }
  @Override public void restore(String id) {
    AuthenticationHelper.requireAdmin();
    if (imagesRepo.nativeRestore(id)==0) {
      throw new AppException(ErrorCode.IMAGE_NOT_FOUND);
    }
  }
  @Override public void setThumbnail(String id) {
    AuthenticationHelper.requireAdmin();
    ProductImage i = imagesRepo.findById(id)
        .orElseThrow(() -> new AppException(ErrorCode.IMAGE_NOT_FOUND));
    String productId = i.getProduct() != null
        ? i.getProduct().getId()
        : null;
    String variantId = i.getVariant() != null
        ? i.getVariant().getId()
        : null;
    imagesRepo.unsetAllThumbnail(productId, variantId);
    i.setThumbnail(true);
    imagesRepo.save(i);
  }
  @Override public void unsetThumbnail(String id) {
    AuthenticationHelper.requireAdmin();
    ProductImage i = imagesRepo.findById(id)
        .orElseThrow(() -> new AppException(ErrorCode.IMAGE_NOT_FOUND));
    i.setThumbnail(false);
    imagesRepo.save(i);
  }
  @Override public Envelope.Page<ImageResponseDto> list(
      String productId,
      String variantId,
      int page, int size) {
    Page<ProductImage> p = imagesRepo.search(
        productId,
        variantId,
        PageRequest.of(page, size)
    );
    List<ImageResponseDto>
        docs = p.getContent()
        .stream()
        .map(mapper::toImageResponseDtoFromProductImage)
        .toList();
    return Envelope.okPage(
        p.getNumber(),
        p.getSize(),
        p.getTotalElements(),
        p.getTotalPages(),
        docs
    ).getData();
  }
}

package com.business.service.impl;

import com.business.constant.ProductStatus;
import com.business.dto.request.ProductCreateRequestDto;
import com.business.dto.request.ProductUpdateRequestDto;
import com.business.dto.response.ProductResponseDto;
import com.business.entity.*;
import com.business.helper.AuthenticationHelper;
import com.business.mapper.ProductMapper;
import com.business.repository.*;
import com.business.service.IProductService;
import lombok.*;
import lombok.experimental.FieldDefaults;
import org.common.exception.AppException;
import org.common.exception.ErrorCode;
import org.common.http.Envelope;
import org.springframework.data.domain.*;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class ProductServiceImpl implements IProductService {

    ProductsRepository productsRepository;
    BrandsRepository brandsRepository;
    CategoriesRepository categoriesRepository;
    ProductCategoriesRepository productCategoriesRepository;
    ProductMapper productMapper;

    @Override
    @Transactional
    public void create(ProductCreateRequestDto productCreateRequestDto) {
        Product p = productMapper.toProductFromProductCreateRequestDto(
                productCreateRequestDto);
        if (productCreateRequestDto.getBrandId() != null
                && !productCreateRequestDto.getBrandId().isBlank()) {
            Brand b = brandsRepository.findById(productCreateRequestDto.getBrandId())
                    .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
            p.setBrand(b);
        } else p.setBrand(null);
        p.setStatus(ProductStatus.DRAFT);
        productsRepository.save(p);
    }

    @Override
    @Transactional
    public void update(
            String id,
            ProductUpdateRequestDto productUpdateRequestDto) {
        Product p = productsRepository.findById(id)
                .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
        productMapper.patchProductFromProductUpdateRequestDto(p,
                productUpdateRequestDto);
        if (productUpdateRequestDto.getBrandId()!=null) {
            if (productUpdateRequestDto.getBrandId().isBlank()) {
                p.setBrand(null);
            } else {
                Brand b = brandsRepository.findById(productUpdateRequestDto.getBrandId())
                        .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
                p.setBrand(b);
            }
        }
        productsRepository.save(p);
    }

    @Override
    @Transactional
    public void softDelete(String id) {
        Product p = productsRepository.findById(id)
                .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
        p.markDeleted(AuthenticationHelper.getMyUserId());
        productsRepository.save(p);
    }

    @Override
    @Transactional
    public void restore(String id) {
        productsRepository.findById(id)
                .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
        int n = productsRepository.nativeRestore(id);
        if (n == 0) {
            throw new AppException(ErrorCode.PRODUCT_NOT_FOUND);
        }
    }

    @Override
    @Transactional
    public void publish(String id) {
        Product p = productsRepository.findById(id)
                .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
        p.setStatus(ProductStatus.PUBLISHED);
        productsRepository.save(p);
    }

    @Override
    @Transactional
    public void unpublish(String id) {
        Product p = productsRepository.findById(id)
                .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
        p.setStatus(ProductStatus.UNPUBLISHED);
        productsRepository.save(p);
    }

    @Override
    @Transactional
    public void archive(String id) {
        Product p = productsRepository.findById(id)
                .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
        p.setStatus(ProductStatus.ARCHIVED);
        productsRepository.save(p);
    }

    @Override
    @Transactional(readOnly = true)
    public ProductResponseDto getById(String id) {
        return productsRepository.findById(id)
                .map(productMapper::toProductResponseDtoFromProduct)
                .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
    }

    @Override
    @Transactional(readOnly = true)
    public ProductResponseDto getBySlug(String slug) {
        return productsRepository.findBySlug(slug)
                .map(productMapper::toProductResponseDtoFromProduct)
                .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
    }

    @Override
    @Transactional(readOnly = true)
    public Envelope.Page<ProductResponseDto> list(
            String q,
            String brandId, String categoryId,
            ProductStatus status, int page, int size) {
        Page<Product> p = productsRepository.filter(
                q,
                brandId,
                categoryId,
                status,
                PageRequest.of(page, size)
        );
        return Envelope.Page.<ProductResponseDto>builder()
                .page(page)
                .size(size)
                .total(p.getTotalElements())
                .totalPages(Math.max(1, p.getTotalPages()))
                .docs(p.map(productMapper::toProductResponseDtoFromProduct).getContent())
                .build();
    }

    @Override
    @Transactional
    public void assignCategory(String productId, String categoryId) {
        Product p = productsRepository.findById(productId)
                .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
        Category c = categoriesRepository.findById(categoryId)
                .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));

        if (!productCategoriesRepository.existsLink(productId, categoryId)) {
            ProductCategory link = new ProductCategory();
            link.setProduct(p);
            link.setCategory(c);
            productCategoriesRepository.save(link);
        }
    }

    @Override
    @Transactional
    public void unassignCategory(String productId, String categoryId) {
        productsRepository.findById(productId)
                .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
        categoriesRepository.findById(categoryId)
                .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
        productCategoriesRepository.deleteLink(productId, categoryId);
    }
}


package com.business.service.impl;

import com.business.dto.request.VariantCreateRequestDto;
import com.business.dto.request.VariantUpdateRequestDto;
import com.business.dto.response.VariantResponseDto;
import com.business.entity.Product;
import com.business.entity.ProductVariant;
import com.business.helper.AuthenticationHelper;
import com.business.mapper.VariantMapper;
import com.business.repository.ProductVariantsRepository;
import com.business.repository.ProductsRepository;
import com.business.service.IVariantService;
import java.math.BigDecimal;
import java.util.List;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import org.common.exception.AppException;
import org.common.exception.ErrorCode;
import org.common.http.Envelope;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class VariantService implements IVariantService {
  ProductVariantsRepository productVariantsRepository;
  ProductsRepository productsRepository;
  VariantMapper variantMapper;

  @Override
  public void create(VariantCreateRequestDto dto) {
    AuthenticationHelper.requireAdmin();
    if (productVariantsRepository.findBySku(dto.getSku()).isPresent())
      throw new AppException(ErrorCode.SKU_CONFLICT);
    Product p = productsRepository.findById(dto.getProductId())
        .orElseThrow(() -> new AppException(ErrorCode.PRODUCT_NOT_FOUND));
    ProductVariant v = variantMapper.toVariantFromVariantCreateRequestDto(dto);
    v.setProduct(p);
    productVariantsRepository.save(v);
  }

  @Override
  public void update(String id, VariantUpdateRequestDto dto) {
    AuthenticationHelper.requireAdmin();
    ProductVariant v = productVariantsRepository.findById(id)
        .orElseThrow(() -> new AppException(ErrorCode.VARIANT_NOT_FOUND));
    if (dto.getSku()!=null && !dto.getSku().isBlank()) {
      productVariantsRepository.findBySku(dto.getSku())
          .filter(x -> !x.getId().equals(id))
          .ifPresent(x -> { throw new AppException(ErrorCode.SKU_CONFLICT); });
    }
    variantMapper.patchVariantFromVariantUpdateRequestDto(v, dto);
    productVariantsRepository.save(v);
  }

  @Override
  public void softDelete(String id) {
    AuthenticationHelper.requireAdmin();
    ProductVariant v = productVariantsRepository.findById(id)
        .orElseThrow(() -> new AppException(ErrorCode.VARIANT_NOT_FOUND));
    v.markDeleted(AuthenticationHelper.getMyUserId());
    productVariantsRepository.save(v);
  }

  @Override
  public void restore(String id) {
    AuthenticationHelper.requireAdmin();
    if (productVariantsRepository.nativeRestore(id)==0)
      throw new AppException(ErrorCode.VARIANT_NOT_FOUND);
  }

  @Override
  public VariantResponseDto findBySku(String sku) {
    ProductVariant v = productVariantsRepository.findBySku(sku)
        .orElseThrow(() -> new AppException(ErrorCode.VARIANT_NOT_FOUND));
    return variantMapper.toVariantResponseDtoFromVariant(v);
  }

  @Override
  public void patchPrice(
      String id,
      BigDecimal price,
      BigDecimal originalPrice) {
    AuthenticationHelper.requireAdmin();
    ProductVariant v = productVariantsRepository.findById(id)
        .orElseThrow(() -> new AppException(ErrorCode.VARIANT_NOT_FOUND));
    if (price!=null) v.setPrice(price);
    if (originalPrice!=null) v.setOriginalPrice(originalPrice);
    productVariantsRepository.save(v);
  }

  @Override
  public Envelope.Page<VariantResponseDto> listByProduct(
      String productId,
      int page, int size) {
    Page<ProductVariant> p = productVariantsRepository
        .listByProduct(productId, PageRequest.of(page, size));
    List<VariantResponseDto> docs = p.getContent().stream()
        .map(variantMapper::toVariantResponseDtoFromVariant).toList();
    return Envelope.okPage(
        p.getNumber(),
        p.getSize(),
        p.getTotalElements(),
        p.getTotalPages(),
        docs
    ).getData();
  }
}

package com.business.controller;

import com.business.dto.request.AttributeCreateRequestDto;
import com.business.dto.response.AttributeResponseDto;
import com.business.service.IAttributeService;
import com.common.grpc.AttributeListRequest;
import com.common.grpc.AttributeServiceGrpc;
import com.common.grpc.AttributeView;
import com.common.grpc.IdRequest;
import com.common.grpc.PageAttribute;
import com.common.grpc.VariantAttributeAssignRequest;
import com.common.grpc.VariantIdRequest;
import com.google.protobuf.Empty;
import io.grpc.stub.StreamObserver;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import net.devh.boot.grpc.server.service.GrpcService;
import org.common.exception.GrpcStatusMapper;
import org.common.http.Envelope;

@GrpcService
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class AttributeGrpcServer
    extends AttributeServiceGrpc.AttributeServiceImplBase {

  IAttributeService attributeService;

  private AttributeView map(AttributeResponseDto d) {
    return AttributeView.newBuilder()
        .setId(d.getId())
        .setName(d.getName())
        .setValue(d.getValue())
        .build();
  }

  @Override
  public void create(
      com.common.grpc.AttributeCreateRequest request,
      StreamObserver<Empty> responseObserver) {
    attributeService.create(AttributeCreateRequestDto.builder()
        .name(request.getName())
        .value(request.getValue())
        .build());
    GrpcStatusMapper.ok(responseObserver);
  }

  @Override
  public void softDelete(
      IdRequest request,
      StreamObserver<Empty> responseObserver) {
    attributeService.softDelete(request.getId());
    GrpcStatusMapper.ok(responseObserver);
  }

  @Override
  public void restore(
      IdRequest request,
      StreamObserver<Empty> responseObserver) {
    attributeService.restore(request.getId());
    GrpcStatusMapper.ok(responseObserver);
  }

  @Override
  public void list(
      AttributeListRequest request,
      StreamObserver<PageAttribute> responseObserver) {
    Envelope.Page<AttributeResponseDto> page = attributeService.list(
        request.getQ(), request.getPage(), request.getSize());

    PageAttribute.Builder b = PageAttribute.newBuilder()
        .setPage(page.getPage())
        .setSize(page.getSize())
        .setTotal(page.getTotal())
        .setTotalPages(page.getTotalPages());
    page.getDocs().forEach(d -> b.addDocs(map(d)));
    GrpcStatusMapper.ok(responseObserver, b.build());
  }

  @Override
  public void assignToVariant(
      VariantAttributeAssignRequest request,
      StreamObserver<Empty> responseObserver) {
    attributeService.assignToVariant(request.getVariantId(), request.getAttributeId());
    GrpcStatusMapper.ok(responseObserver);
  }

  @Override
  public void unassignFromVariant(
      VariantAttributeAssignRequest request,
      StreamObserver<Empty> responseObserver) {
    attributeService.unassignFromVariant(request.getVariantId(), request.getAttributeId());
    GrpcStatusMapper.ok(responseObserver);
  }

  @Override
  public void listByVariant(
      VariantIdRequest request,
      StreamObserver<PageAttribute> responseObserver) {
    Envelope.Page<AttributeResponseDto> page = attributeService.listByVariant(
        request.getVariantId(), request.getPage(), request.getSize());

    PageAttribute.Builder b = PageAttribute.newBuilder()
        .setPage(page.getPage())
        .setSize(page.getSize())
        .setTotal(page.getTotal())
        .setTotalPages(page.getTotalPages());
    page.getDocs().forEach(d -> b.addDocs(map(d)));
    GrpcStatusMapper.ok(responseObserver, b.build());
  }
}

package com.business.controller;

import com.business.dto.request.BrandCreateRequestDto;
import com.business.dto.request.BrandUpdateRequestDto;
import com.business.dto.response.BrandResponseDto;
import com.business.service.IBrandService;
import com.common.grpc.BrandCreateRequest;
import com.common.grpc.BrandListRequest;
import com.common.grpc.BrandServiceGrpc;
import com.common.grpc.BrandUpdateRequest;
import com.common.grpc.BrandView;
import com.common.grpc.IdRequest;
import com.common.grpc.PageBrand;
import com.common.grpc.SlugRequest;
import com.google.protobuf.Empty;
import io.grpc.stub.StreamObserver;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.AccessLevel;
import net.devh.boot.grpc.server.service.GrpcService;
import org.common.exception.GrpcStatusMapper;
import org.common.http.Envelope;

@GrpcService
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class BrandGrpcServer
        extends BrandServiceGrpc.BrandServiceImplBase {
    IBrandService brandService;

    @Override
    public void create(
            BrandCreateRequest request,
            StreamObserver<Empty> responseObserver) {
        brandService.create(BrandCreateRequestDto.builder()
                .name(request.getName())
                .slug(request.getSlug())
                .description(request.getDescription())
                .build());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void update(
            BrandUpdateRequest brandUpdateRequest,
            StreamObserver<Empty> responseObserver) {
        brandService.update(
                brandUpdateRequest.getId(),
                BrandUpdateRequestDto.builder()
                        .name(brandUpdateRequest.getName())
                        .slug(brandUpdateRequest.getSlug())
                        .description(brandUpdateRequest.getDescription())
                        .build()
        );
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void softDelete(
            IdRequest request,
            StreamObserver<Empty> responseObserver) {
        brandService.softDelete(request.getId());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void restore(
            IdRequest request,
            StreamObserver<Empty> responseObserver) {
        brandService.restore(request.getId());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void getById(
            IdRequest request,
            StreamObserver<BrandView> responseObserver) {
        BrandResponseDto d = brandService.getById(request.getId());
        GrpcStatusMapper.ok(
                responseObserver,
                BrandView.newBuilder()
                        .setId(d.getId())
                        .setName(d.getName()).setSlug(d.getSlug())
                        .setDescription(d.getDescription() == null
                                ? ""
                                : d.getDescription())
                .build());
    }

    @Override
    public void getBySlug(
            SlugRequest request,
            StreamObserver<BrandView> responseObserver) {
        BrandResponseDto d = brandService.getBySlug(request.getSlug());
        GrpcStatusMapper.ok(
                responseObserver,
                BrandView.newBuilder()
                        .setId(d.getId())
                        .setName(d.getName())
                        .setSlug(d.getSlug())
                        .setDescription(d.getDescription() == null
                                ? ""
                                : d.getDescription())
                        .build());
    }

    @Override
    public void list(
            BrandListRequest request,
            StreamObserver<PageBrand> responseObserver) {
        Envelope.Page<BrandResponseDto> page = brandService.list(
                request.getQ(),
                request.getPage(),
                request.getSize()
        );
        PageBrand.Builder b = PageBrand.newBuilder()
                .setPage(page.getPage())
                .setSize(page.getSize())
                .setTotal(page.getTotal())
                .setTotalPages(page.getTotalPages());
        page.getDocs().forEach(d -> b.addDocs(BrandView.newBuilder()
                .setId(d.getId())
                .setName(d.getName())
                .setSlug(d.getSlug())
                .setDescription(d.getDescription() == null
                        ? ""
                        : d.getDescription())
                .build()));
        GrpcStatusMapper.ok(responseObserver, b.build());
    }
}

package com.business.controller;

import com.business.dto.request.CategoryCreateRequestDto;
import com.business.dto.request.CategoryUpdateRequestDto;
import com.business.dto.response.CategoryResponseDto;
import com.business.service.ICategoryService;
import com.common.grpc.CategoryChildrenRequest;
import com.common.grpc.CategoryCreateRequest;
import com.common.grpc.CategoryListRequest;
import com.common.grpc.CategoryReparentRequest;
import com.common.grpc.CategoryServiceGrpc;
import com.common.grpc.CategoryTreeNode;
import com.common.grpc.CategoryUpdateRequest;
import com.common.grpc.CategoryView;
import com.common.grpc.IdRequest;
import com.common.grpc.PageCategory;
import com.common.grpc.SlugRequest;
import com.google.protobuf.Empty;
import io.grpc.stub.StreamObserver;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import net.devh.boot.grpc.server.service.GrpcService;
import org.common.exception.GrpcStatusMapper;
import org.common.http.Envelope;

@GrpcService
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class CategoryGrpcServer extends CategoryServiceGrpc.CategoryServiceImplBase {

    ICategoryService categoryService;

    @Override
    public void create(
            CategoryCreateRequest request,
            StreamObserver<Empty> responseObserver) {
        categoryService.create(CategoryCreateRequestDto.builder()
                .name(request.getName())
                .slug(request.getSlug())
                .description(request.getDescription())
                .parentId(request.getParentId().isBlank()
                        ? null
                        : request.getParentId())
                .build());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void update(
            CategoryUpdateRequest request,
            StreamObserver<Empty> responseObserver) {
        categoryService.update(
                request.getId(),
                CategoryUpdateRequestDto.builder()
                    .name(request.getName())
                    .slug(request.getSlug())
                    .description(request.getDescription())
                    .build());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void softDelete(
            IdRequest request,
            StreamObserver<Empty> responseObserver) {
        categoryService.softDelete(request.getId());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void restore(IdRequest request, StreamObserver<Empty> responseObserver) {
        categoryService.restore(request.getId());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void reparent(
            CategoryReparentRequest request,
            StreamObserver<Empty> responseObserver) {
        categoryService.reparent(request.getId(),
                request.getNewParentId().isBlank()
                        ? null
                        : request.getNewParentId());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void getById(
            IdRequest request,
            StreamObserver<CategoryView> responseObserver) {
        CategoryResponseDto d = categoryService.getById(request.getId());
        GrpcStatusMapper.ok(responseObserver, CategoryView.newBuilder()
                .setId(d.getId())
                .setName(d.getName())
                .setSlug(d.getSlug())
                .setDescription(d.getDescription() == null
                        ? ""
                        : d.getDescription())
                .setParentId(d.getParentId() == null
                        ? ""
                        : d.getParentId())
                .build());
    }

    @Override
    public void getBySlug(
            SlugRequest request,
            StreamObserver<CategoryView> responseObserver) {
        CategoryResponseDto d = categoryService.getBySlug(request.getSlug());
        GrpcStatusMapper.ok(
                responseObserver,
                CategoryView.newBuilder()
                    .setId(d.getId())
                    .setName(d.getName())
                    .setSlug(d.getSlug())
                    .setDescription(d.getDescription()==null
                            ? ""
                            : d.getDescription())
                    .setParentId(d.getParentId() == null
                            ? ""
                            : d.getParentId())
                    .build());
    }

    @Override
    public void list(
            CategoryListRequest request,
            StreamObserver<PageCategory> responseObserver) {
        Envelope.Page<CategoryResponseDto> page = categoryService.list(
                request.getQ(),
                request.getPage(),
                request.getSize()
        );
        PageCategory.Builder b = PageCategory.newBuilder()
                .setPage(page.getPage())
                .setSize(page.getSize())
                .setTotal(page.getTotal())
                .setTotalPages(page.getTotalPages());
        page.getDocs().forEach(d -> b.addDocs(CategoryView.newBuilder()
                .setId(d.getId())
                .setName(d.getName())
                .setSlug(d.getSlug())
                .setDescription(d.getDescription() == null
                        ? ""
                        : d.getDescription())
                .setParentId(d.getParentId() == null
                        ? ""
                        : d.getParentId())
                .build()));
        GrpcStatusMapper.ok(responseObserver, b.build());
    }

    // full tree
    @Override
    public void tree(
            Empty request,
            StreamObserver<CategoryTreeNode> responseObserver) {
        com.business.dto.model.CategoryTreeNode root = categoryService.tree();
        GrpcStatusMapper.ok(responseObserver, toGrpc(root));
    }

    private CategoryTreeNode toGrpc(com.business.dto.model.CategoryTreeNode n){
        CategoryTreeNode.Builder builder = CategoryTreeNode.newBuilder();
        if (n.getData()!=null){
            var d = n.getData();
            builder.setData(CategoryView.newBuilder()
                    .setId(d.getId())
                    .setName(d.getName())
                    .setSlug(d.getSlug())
                    .setDescription(d.getDescription() == null
                            ? ""
                            : d.getDescription())
                    .setParentId(d.getParentId() == null
                            ? ""
                            : d.getParentId())
                    .build());
        }
        n.getChildren().forEach(c -> builder.addChildren(toGrpc(c)));
        return builder.build();
    }

    @Override
    public void children(
            CategoryChildrenRequest request,
            StreamObserver<PageCategory> responseObserver) {
        Envelope.Page<CategoryResponseDto> page = categoryService.children(
                request.getId().isBlank()
                        ? null
                        : request.getId(),
                0, Integer.MAX_VALUE);
        PageCategory.Builder b = PageCategory.newBuilder()
                .setPage(page.getPage())
                .setSize(page.getSize())
                .setTotal(page.getTotal())
                .setTotalPages(page.getTotalPages());
        page.getDocs().forEach(d -> b.addDocs(CategoryView.newBuilder()
                .setId(d.getId())
                .setName(d.getName())
                .setSlug(d.getSlug())
                .setDescription(d.getDescription() == null
                        ? ""
                        : d.getDescription())
                .setParentId(d.getParentId() == null
                        ? ""
                        : d.getParentId())
                .build()));
        GrpcStatusMapper.ok(responseObserver, b.build());
    }
}

package com.business.controller;

import com.business.constant.DiscountType;
import com.business.dto.model.DiscountValidation;
import com.business.dto.request.DiscountCreateRequestDto;
import com.business.dto.request.DiscountUpdateRequestDto;
import com.business.dto.response.DiscountResponseDto;
import com.business.service.IDiscountService;
import com.common.grpc.DiscountCodeRequest;
import com.common.grpc.DiscountCreateRequest;
import com.common.grpc.DiscountListRequest;
import com.common.grpc.DiscountServiceGrpc;
import com.common.grpc.DiscountToggleActiveRequest;
import com.common.grpc.DiscountTypeGrpc;
import com.common.grpc.DiscountUpdateRequest;
import com.common.grpc.DiscountValidationView;
import com.common.grpc.DiscountView;
import com.common.grpc.IdRequest;
import com.common.grpc.PageDiscount;
import com.google.protobuf.Empty;
import io.grpc.stub.StreamObserver;
import java.math.BigDecimal;
import java.time.Instant;
import java.util.Objects;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import net.devh.boot.grpc.server.service.GrpcService;
import org.common.exception.GrpcStatusMapper;
import org.common.http.Envelope;

@GrpcService
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class DiscountGrpcServer
    extends DiscountServiceGrpc.DiscountServiceImplBase {

  IDiscountService discountService;

  /* ===== Helpers ===== */

  private static BigDecimal parseDecimal(String s) {
    return (s == null || s.isBlank()) ? null : new BigDecimal(s);
    // ném NumberFormatException sẽ được GrpcAdvice chuyển INVALID_ARGUMENT
  }

  private static Instant parseInstant(String s) {
    return (s == null || s.isBlank()) ? null : Instant.parse(s);
  }

  private DiscountType toDomain(DiscountTypeGrpc t) {
    if (t == null) return DiscountType.fixed_amount; // default an toàn
    return switch (t) {
      case PERCENTAGE -> DiscountType.percentage;
      case FIXED_AMOUNT, UNRECOGNIZED -> DiscountType.fixed_amount;
    };
  }

  private DiscountTypeGrpc toGrpc(DiscountType t) {
    if (t == null) return DiscountTypeGrpc.FIXED_AMOUNT;
    return switch (t) {
      case percentage -> DiscountTypeGrpc.PERCENTAGE;
      case fixed_amount -> DiscountTypeGrpc.FIXED_AMOUNT;
    };
  }

  private DiscountView map(DiscountResponseDto d) {
    return DiscountView.newBuilder()
        .setId(d.getId())
        .setCode(d.getCode())
        .setType(toGrpc(d.getType()))
        .setValue(Objects.toString(d.getValue(), "0"))
        .setStartDate(Objects.toString(d.getStartDate(), ""))
        .setEndDate(Objects.toString(d.getEndDate(), ""))
        .setMinOrderValue(Objects.toString(d.getMinOrderValue(), "0"))
        .setIsActive(Boolean.TRUE.equals(d.getActive()))
        .build();
  }

  private DiscountValidationView mapValidation(
      DiscountValidation v) {
    return DiscountValidationView.newBuilder()
        .setValid(v.isValid())
        .setReason(Objects.toString(v.getReason(), ""))
        .setDiscountAmount(Objects.toString(v.getAmount(), "0"))
        .build();
  }


  @Override
  public void create(
      DiscountCreateRequest request,
      StreamObserver<Empty> responseObserver) {
    discountService.create(DiscountCreateRequestDto.builder()
        .code(request.getCode())
        .type(toDomain(request.getType()))
        .value(parseDecimal(request.getValue()))
        .startDate(parseInstant(request.getStartDate()))
        .endDate(parseInstant(request.getEndDate()))
        .minOrderValue(parseDecimal(request.getMinOrderValue()))
        .active(request.getIsActive())
        .build());
    GrpcStatusMapper.ok(responseObserver);
  }

  @Override
  public void update(
      DiscountUpdateRequest request,
      StreamObserver<Empty> responseObserver) {
    discountService.update(request.getId(), DiscountUpdateRequestDto.builder()
        .code(request.getCode().isBlank()
            ? null
            : request.getCode())
        .type(request.getType() == DiscountTypeGrpc.UNRECOGNIZED
            ? null
            : toDomain(request.getType()))
        .value(parseDecimal(request.getValue()))
        .startDate(parseInstant(request.getStartDate()))
        .endDate(parseInstant(request.getEndDate()))
        .minOrderValue(parseDecimal(request.getMinOrderValue()))
        .active(request.getIsActive())
        .build());
    GrpcStatusMapper.ok(responseObserver);
  }

  @Override
  public void softDelete(
      IdRequest request,
      StreamObserver<Empty> responseObserver) {
    discountService.softDelete(request.getId());
    GrpcStatusMapper.ok(responseObserver);
  }

  @Override
  public void restore(
      IdRequest request,
      StreamObserver<Empty> responseObserver) {
    discountService.restore(request.getId());
    GrpcStatusMapper.ok(responseObserver);
  }

  @Override
  public void toggleActive(
      DiscountToggleActiveRequest request,
      StreamObserver<Empty> responseObserver) {
    discountService.toggleActive(request.getId(), request.getIsActive());
    GrpcStatusMapper.ok(responseObserver);
  }

  @Override
  public void getByCode(
      DiscountCodeRequest request,
      StreamObserver<DiscountView> responseObserver) {
    var d = discountService.getByCode(request.getCode());
    GrpcStatusMapper.ok(responseObserver, map(d));
  }

  @Override
  public void validate(
      DiscountCodeRequest request,
      StreamObserver<DiscountValidationView> responseObserver) {
    var v = discountService.validateAndAmount(
        request.getCode(),
        parseDecimal(request.getOrderValue()) == null
            ? BigDecimal.ZERO
            : parseDecimal(request.getOrderValue()),
        parseInstant(request.getAt()) == null
            ? Instant.now()
            : parseInstant(request.getAt())
    );
    GrpcStatusMapper.ok(responseObserver, mapValidation(v));
  }

  @Override
  public void list(
      DiscountListRequest request,
      StreamObserver<PageDiscount> responseObserver) {
    var at = parseInstant(request.getAt());
    Envelope.Page<DiscountResponseDto> page = discountService.list(
        request.getOnlyEffective(),
        at == null ? Instant.now() : at,
        request.getPage(),
        request.getSize()
    );

    PageDiscount.Builder b = PageDiscount.newBuilder()
        .setPage(page.getPage())
        .setSize(page.getSize())
        .setTotal(page.getTotal())
        .setTotalPages(page.getTotalPages());
    page.getDocs().forEach(d -> b.addDocs(map(d)));
    GrpcStatusMapper.ok(responseObserver, b.build());
  }
}

package com.business.controller;

import com.business.dto.request.ProductCreateRequestDto;
import com.business.dto.request.ProductUpdateRequestDto;
import com.business.dto.response.ProductResponseDto;
import com.business.service.IProductService;
import com.common.grpc.ArchiveRequest;
import com.common.grpc.AssignCategoryRequest;
import com.common.grpc.IdRequest;
import com.common.grpc.PageProduct;
import com.common.grpc.ProductCreateRequest;
import com.common.grpc.ProductListRequest;
import com.common.grpc.ProductServiceGrpc;
import com.common.grpc.ProductStatus;
import com.common.grpc.ProductUpdateRequest;
import com.common.grpc.ProductView;
import com.common.grpc.PublishRequest;
import com.common.grpc.SlugRequest;
import com.common.grpc.UnassignCategoryRequest;
import com.common.grpc.UnpublishRequest;
import com.google.protobuf.Empty;
import io.grpc.stub.StreamObserver;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import net.devh.boot.grpc.server.service.GrpcService;
import org.common.exception.GrpcStatusMapper;
import org.common.http.Envelope;

import static com.business.constant.ProductStatus.ARCHIVED;
import static com.business.constant.ProductStatus.DRAFT;
import static com.business.constant.ProductStatus.PUBLISHED;
import static com.business.constant.ProductStatus.UNPUBLISHED;

@GrpcService
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class ProductGrpcServer extends ProductServiceGrpc.ProductServiceImplBase {
    IProductService productService;

    private ProductView map(ProductResponseDto d){
        return ProductView.newBuilder()
                .setId(d.getId())
                .setName(d.getName())
                .setSlug(d.getSlug())
                .setDescription(d.getDescription()==null?"":d.getDescription())
                .setStatus(ProductStatus.valueOf(d.getStatus().name()))
                .setBrandId(d.getBrandId()==null?"":d.getBrandId())
                .build();
    }

    private ProductStatus toGrpc(com.business.constant.ProductStatus s) {
        switch (s) {
            case PUBLISHED: return ProductStatus.PUBLISHED;
            case ARCHIVED:  return ProductStatus.ARCHIVED;
            case UNPUBLISHED: return ProductStatus.UNPUBLISHED;
            default: return ProductStatus.DRAFT;
        }
    }

    private com.business.constant.ProductStatus toDomain(ProductStatus s) {
        switch (s) {
            case ProductStatus.PUBLISHED:     return PUBLISHED;
            case ProductStatus.ARCHIVED: return ARCHIVED;
            case ProductStatus.UNPUBLISHED:  return UNPUBLISHED;
            default: return DRAFT;
        }
    }


    @Override
    public void create(
            ProductCreateRequest request,
            StreamObserver<Empty> responseObserver) {
        productService.create(ProductCreateRequestDto.builder()
                .name(request.getName())
                .slug(request.getSlug())
                .description(request.getDescription())
                .brandId(request.getBrandId().isBlank()
                        ? null
                        : request.getBrandId())
                .build());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void update(
            ProductUpdateRequest request,
            StreamObserver<Empty> responseObserver) {
        productService.update(
                request.getId(),
                ProductUpdateRequestDto.builder()
                    .name(request.getName())
                    .slug(request.getSlug())
                    .description(request.getDescription())
                    .brandId(request.getBrandId().isBlank()?null:request.getBrandId())
                    .build());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override public void softDelete(
            IdRequest request,
            StreamObserver<Empty> responseObserver){
        productService.softDelete(request.getId());
        GrpcStatusMapper.ok(responseObserver);
    }
    @Override public void restore(
            IdRequest request,
            StreamObserver<Empty> responseObserver){
        productService.restore(request.getId());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override public void publish(
            PublishRequest request,
            StreamObserver<Empty> responseObserver){
        productService.publish(request.getId());
        GrpcStatusMapper.ok(responseObserver);
    }
    @Override public void unpublish(
            UnpublishRequest request,
            StreamObserver<Empty> responseObserver){
        productService.unpublish(request.getId());
        GrpcStatusMapper.ok(responseObserver);
    }
    @Override public void archive(
            ArchiveRequest request,
            StreamObserver<Empty> responseObserver){
        productService.archive(request.getId());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void getById(
            IdRequest request,
            StreamObserver<ProductView> responseObserver) {
        GrpcStatusMapper.ok(responseObserver, map(productService.getById(request.getId())));
    }
    @Override
    public void getBySlug(
            SlugRequest request,
            StreamObserver<ProductView> responseObserver) {
        GrpcStatusMapper.ok(responseObserver, map(productService.getBySlug(request.getSlug())));
    }

    @Override
    public void list(
            ProductListRequest request,
            StreamObserver<PageProduct> responseObserver) {
        ProductStatus status = request.hasStatus()
                ? ProductStatus.valueOf(request.getStatus().name())
                : null;
        Envelope.Page<ProductResponseDto> page = productService.list(
                request.getQ(),
                request.getBrandId().isBlank()
                        ? null
                        : request.getBrandId(),
                request.getCategoryId().isBlank()
                        ? null
                        : request.getCategoryId(),
                toDomain(status), request.getPage(), request.getSize());

        PageProduct.Builder b = PageProduct.newBuilder()
                .setPage(page.getPage())
                .setSize(page.getSize())
                .setTotal(page.getTotal())
                .setTotalPages(page.getTotalPages());
        page.getDocs().forEach(d -> b.addDocs(map(d)));
        GrpcStatusMapper.ok(responseObserver, b.build());
    }

    @Override
    public void assignCategory(
            AssignCategoryRequest request,
            StreamObserver<Empty> responseObserver) {
        productService.assignCategory(request.getProductId(), request.getCategoryId());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void unassignCategory(
            UnassignCategoryRequest request,
            StreamObserver<Empty> responseObserver) {
        productService.unassignCategory(request.getProductId(), request.getCategoryId());
        GrpcStatusMapper.ok(responseObserver);
    }
}

package com.business.controller;

import com.business.dto.request.ImageCreateRequestDto;
import com.business.dto.response.ImageResponseDto;
import com.business.service.IProductImageService;
import com.common.grpc.IdRequest;
import com.common.grpc.ImageListRequest;
import com.common.grpc.ImageView;
import com.common.grpc.PageImage;
import com.common.grpc.ProductImageServiceGrpc;
import com.google.protobuf.Empty;
import io.grpc.stub.StreamObserver;
import java.util.Objects;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import net.devh.boot.grpc.server.service.GrpcService;
import org.common.exception.GrpcStatusMapper;
import org.common.http.Envelope;

@GrpcService
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class ProductImageGrpcServer
    extends ProductImageServiceGrpc.ProductImageServiceImplBase {

  IProductImageService imageService;

  private ImageView map(ImageResponseDto d) {
    return ImageView.newBuilder()
        .setId(d.getId())
        .setProductId(Objects.toString(d.getProductId(), ""))
        .setVariantId(Objects.toString(d.getVariantId(), ""))
        .setImageUrl(d.getImageUrl())
        .setIsThumbnail(Boolean.TRUE.equals(d.getThumbnail()))
        .build();
  }

  @Override
  public void create(
      com.common.grpc.ImageCreateRequest request,
      StreamObserver<Empty> responseObserver) {
    imageService.create(ImageCreateRequestDto.builder()
        .productId(request.getProductId().isBlank()
            ? null
            : request.getProductId())
        .variantId(request.getVariantId().isBlank()
            ? null
            : request.getVariantId())
        .imageUrl(request.getImageUrl())
        .build());
    GrpcStatusMapper.ok(responseObserver);
  }

  @Override
  public void softDelete(
      IdRequest request,
      StreamObserver<Empty> responseObserver) {
    imageService.softDelete(request.getId());
    GrpcStatusMapper.ok(responseObserver);
  }

  @Override
  public void restore(
      IdRequest request,
      StreamObserver<Empty> responseObserver) {
    imageService.restore(request.getId());
    GrpcStatusMapper.ok(responseObserver);
  }

  @Override
  public void setThumbnail(
      IdRequest request,
      StreamObserver<Empty> responseObserver) {
    imageService.setThumbnail(request.getId());
    GrpcStatusMapper.ok(responseObserver);
  }

  @Override
  public void unsetThumbnail(
      IdRequest request,
      StreamObserver<Empty> responseObserver) {
    imageService.unsetThumbnail(request.getId());
    GrpcStatusMapper.ok(responseObserver);
  }

  @Override
  public void list(
      ImageListRequest request,
      StreamObserver<PageImage> responseObserver) {
    String productId = request.getProductId().isBlank()
        ? null
        : request.getProductId();
    String variantId = request.getVariantId().isBlank()
        ? null
        : request.getVariantId();

    Envelope.Page<ImageResponseDto> page = imageService
        .list(productId, variantId, request.getPage(), request.getSize());

    PageImage.Builder b = PageImage.newBuilder()
        .setPage(page.getPage())
        .setSize(page.getSize())
        .setTotal(page.getTotal())
        .setTotalPages(page.getTotalPages());
    page.getDocs().forEach(d -> b.addDocs(map(d)));
    GrpcStatusMapper.ok(responseObserver, b.build());
  }
}

package com.business.controller;

import com.business.dto.request.VariantCreateRequestDto;
import com.business.dto.request.VariantUpdateRequestDto;
import com.business.dto.response.VariantResponseDto;
import com.business.service.IVariantService;
import com.common.grpc.IdRequest;
import com.common.grpc.PageVariant;
import com.common.grpc.VariantByProductRequest;
import com.common.grpc.VariantBySkuRequest;
import com.common.grpc.VariantCreateRequest;
import com.common.grpc.VariantPricePatchRequest;
import com.common.grpc.VariantServiceGrpc;
import com.common.grpc.VariantUpdateRequest;
import com.common.grpc.VariantView;
import com.google.protobuf.Empty;
import io.grpc.stub.StreamObserver;
import java.math.BigDecimal;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import net.devh.boot.grpc.server.service.GrpcService;
import org.common.exception.GrpcStatusMapper;
import org.common.http.Envelope;

@GrpcService
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class VariantGrpcServer extends VariantServiceGrpc.VariantServiceImplBase {
  IVariantService variantService;

  private VariantView mapVariantResponseDtoToVariantView(
      VariantResponseDto d) {
    return VariantView.newBuilder()
        .setId(d.getId()).setProductId(d.getProductId() == null
            ? ""
            : d.getProductId())
        .setSku(d.getSku())
        .setPrice(d.getPrice().toPlainString())
        .setOriginalPrice(d.getOriginalPrice() == null
            ? ""
            : d.getOriginalPrice().toPlainString())
        .build();
  }

  @Override
  public void create(
      VariantCreateRequest request,
      StreamObserver<Empty> responseObserver) {
    variantService.create(VariantCreateRequestDto.builder()
        .productId(request.getProductId())
        .sku(request.getSku())
        .price(new BigDecimal(request.getPrice()))
        .originalPrice(request.getOriginalPrice().isBlank()
            ? null
            : new BigDecimal(request.getOriginalPrice()))
        .build());
    GrpcStatusMapper.ok(responseObserver);
  }

  @Override
  public void update(
      VariantUpdateRequest request,
      StreamObserver<Empty> responseObserver) {
    variantService.update(request.getId(), VariantUpdateRequestDto.builder()
        .sku(request.getSku().isBlank()
            ? null
            : request.getSku())
        .price(request.getPrice().isBlank()
            ? null
            : new BigDecimal(request.getPrice()))
        .originalPrice(request.getOriginalPrice().isBlank()
            ? null
            : new BigDecimal(request.getOriginalPrice()))
        .build()); GrpcStatusMapper.ok(responseObserver);
  }

  @Override
  public void softDelete(
      IdRequest request,
      StreamObserver<Empty> responseObserver){
    variantService.softDelete(request.getId());
    GrpcStatusMapper.ok(responseObserver);
  }

  @Override
  public void restore(
      IdRequest request,
      StreamObserver<Empty> responseObserver){
    variantService.restore(request.getId());
    GrpcStatusMapper.ok(responseObserver);
  }

  @Override
  public void findBySku(
      VariantBySkuRequest request,
      StreamObserver<VariantView> responseObserver){
    GrpcStatusMapper.ok(
        responseObserver,
        mapVariantResponseDtoToVariantView(variantService.findBySku(request.getSku()))
    );
  }

  @Override public void patchPrice(
      VariantPricePatchRequest req,
      StreamObserver<Empty> obs){
    variantService.patchPrice(req.getId(),
        req.getPrice().isBlank()
            ? null
            : new BigDecimal(req.getPrice()),
        req.getOriginalPrice().isBlank()
            ? null
            : new BigDecimal(req.getOriginalPrice()));
    GrpcStatusMapper.ok(obs);
  }

  @Override
  public void listByProduct(
      VariantByProductRequest req,
      StreamObserver<PageVariant> obs){
    Envelope.Page<VariantResponseDto> page = variantService.listByProduct(
        req.getProductId(),
        req.getPage(),
        req.getSize()
    );
    PageVariant.Builder b = PageVariant.newBuilder()
        .setPage(page.getPage())
        .setSize(page.getSize())
        .setTotal(page.getTotal())
        .setTotalPages(page.getTotalPages());
    page.getDocs().forEach(d -> b.addDocs(mapVariantResponseDtoToVariantView(d)));
    GrpcStatusMapper.ok(obs, b.build());
  }
}

package com.business.constant;

public enum DiscountType {
    percentage,
    fixed_amount
}

package com.business.constant;

public enum OrderStatus {
    pending,
    processing,
    shipped,
    completed,
    cancelled
}

package com.business.constant;

public enum ProductStatus {
    PUBLISHED,
    UNPUBLISHED,
    DRAFT,
    ARCHIVED
}

package com.business.configuration.security;


import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.oauth2.jose.jws.MacAlgorithm;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.stereotype.Component;

import javax.crypto.spec.SecretKeySpec;
import java.util.Objects;


@Component
public class CustomJwtDecoder implements JwtDecoder {

    @Value("${app.jwt.signerKey}")
    private String signerKey;

    private NimbusJwtDecoder nimbusJwtDecoder;

    @Override
    public Jwt decode(String token) throws JwtException {

        if (Objects.isNull(nimbusJwtDecoder)) {
            SecretKeySpec secretKeySpec =
                    new SecretKeySpec(signerKey.getBytes(), "HS512");

            nimbusJwtDecoder = NimbusJwtDecoder.withSecretKey(secretKeySpec)
                    .macAlgorithm(MacAlgorithm.HS512)
                    .build();
        }

        return nimbusJwtDecoder.decode(token);
    }
}

package com.business.configuration.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.ProviderManager;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationProvider;

@Configuration
public class GrpcJwtAuthManagerConfig {

    @Bean
    public JwtAuthenticationConverter grpcJwtAuthenticationConverter() {
        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
        return jwtAuthenticationConverter;
    }

    @Bean
    public AuthenticationManager grpcAuthenticationManager(
            JwtDecoder jwtDecoder,
            JwtAuthenticationConverter grpcJwtAuthenticationConverter) {

        JwtAuthenticationProvider provider = new JwtAuthenticationProvider(jwtDecoder);
        provider.setJwtAuthenticationConverter(grpcJwtAuthenticationConverter);
        return new ProviderManager(provider);
    }
}

package com.business.configuration.security;

import io.grpc.CallOptions;
import io.grpc.Channel;
import io.grpc.ClientCall;
import io.grpc.ClientInterceptor;
import io.grpc.ForwardingClientCall;
import io.grpc.Metadata;
import io.grpc.MethodDescriptor;
import net.devh.boot.grpc.client.interceptor.GlobalClientInterceptorConfigurer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.oauth2.server.resource.authentication.BearerTokenAuthentication;

@Configuration
public class GrpcJwtClientPropagationConfig {

    static class JwtPropagatingClientInterceptor implements ClientInterceptor {
        private static final Metadata.Key<String> AUTH =
                Metadata.Key.of("Authorization", Metadata.ASCII_STRING_MARSHALLER);

        @Override
        public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(
                MethodDescriptor<ReqT, RespT> method,
                CallOptions callOptions,
                Channel next) {

            return new ForwardingClientCall.SimpleForwardingClientCall<>(next.newCall(method, callOptions)) {
                @Override
                public void start(Listener<RespT> responseListener, Metadata headers) {
                    String token = resolveToken();
                    if (token != null && !token.isBlank()) {
                        headers.put(AUTH, "Bearer " + token);
                    }
                    super.start(responseListener, headers);
                }
            };
        }

        private String resolveToken() {
            var ctx = SecurityContextHolder.getContext();
            if (ctx == null || ctx.getAuthentication() == null) return null;
            if (ctx.getAuthentication() instanceof BearerTokenAuthentication b) {
                return b.getToken().getTokenValue();
            }
            return null;
        }
    }

    @Bean
    public GlobalClientInterceptorConfigurer jwtPropagationConfigurer() {
        return interceptors -> interceptors.add(
                new JwtPropagatingClientInterceptor());
    }
}

package com.business.configuration.security;

import net.devh.boot.grpc.server.security.authentication.BearerAuthenticationReader;
import net.devh.boot.grpc.server.security.authentication.GrpcAuthenticationReader;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.oauth2.server.resource.authentication.BearerTokenAuthenticationToken;

@Configuration
public class GrpcServerSecurityConfig {
    @Bean
    public GrpcAuthenticationReader grpcAuthenticationReader() {
        return new BearerAuthenticationReader(token ->
                new BearerTokenAuthenticationToken(token));
    }
}

package com.business.configuration.security;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.common.exception.ErrorCode;
import org.common.http.Envelope;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;

import java.io.IOException;

public class JwtAuthenticationEntryPoint
        implements AuthenticationEntryPoint {
    @Override
    public void commence(
            HttpServletRequest request,
            HttpServletResponse response,
            AuthenticationException authException)
            throws IOException {
        ErrorCode errorCode = ErrorCode.UNAUTHENTICATED;
        Envelope<Void> envelope = Envelope.err(
                        errorCode.http(),
                        errorCode.name(),
                        errorCode.getMessage(),
                        null);

        response.setStatus(errorCode.http());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        new ObjectMapper().writeValue(response.getWriter(), envelope);
        response.flushBuffer();
    }
}

package com.business.configuration.security;

import lombok.NoArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.access.hierarchicalroles.RoleHierarchy;
import org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
@NoArgsConstructor
public class SecurityBeanConfig {


    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }


    @Bean
    public RoleHierarchy roleHierarchy() {
        return RoleHierarchyImpl.fromHierarchy("ROLE_ADMIN > ROLE_USER");
    }
}


package com.business.configuration.security;

import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.List;

import static org.common.constant.SecurityConstants.ACCEPT_HEADER;
import static org.common.constant.SecurityConstants.AUTHORIZATION_HEADER;
import static org.common.constant.SecurityConstants.CONTENT_TYPE_HEADER;
import static org.common.constant.SecurityConstants.FRONTEND_ENDPOINT;
import static org.common.constant.SecurityConstants.PUBLIC_ENDPOINTS;
import static org.common.constant.SecurityConstants.URL_PATTERN_ALL;
import static org.springdoc.core.utils.Constants.DELETE_METHOD;
import static org.springdoc.core.utils.Constants.GET_METHOD;
import static org.springdoc.core.utils.Constants.OPTIONS_METHOD;
import static org.springdoc.core.utils.Constants.PATCH_METHOD;
import static org.springdoc.core.utils.Constants.POST_METHOD;
import static org.springdoc.core.utils.Constants.PUT_METHOD;


@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfiguration {

    @Autowired
    private CustomJwtDecoder customJwtDecoder;


    @Bean
    public SecurityFilterChain securityFilterChain(
            HttpSecurity httpSecurity) throws Exception {
        httpSecurity
                .headers(headers -> headers.frameOptions(
                        frame -> frame.sameOrigin()))
                .authorizeHttpRequests(request -> request
                        .requestMatchers(PUBLIC_ENDPOINTS)
                        .permitAll()
                        .anyRequest()
                        .authenticated());

        httpSecurity.oauth2ResourceServer(
                oauth2 -> oauth2.jwt(jwtConfigurer -> jwtConfigurer
                                .decoder(customJwtDecoder)
                                .jwtAuthenticationConverter(
                                        jwtAuthenticationConverter()))
                        .authenticationEntryPoint(
                                new JwtAuthenticationEntryPoint()));
        httpSecurity.csrf(AbstractHttpConfigurer::disable);

        return httpSecurity.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();

        configuration.setAllowedOriginPatterns(List.of(
                FRONTEND_ENDPOINT
        ));

        configuration.setAllowedMethods(
                List.of(GET_METHOD, POST_METHOD, PUT_METHOD, DELETE_METHOD,
                        PATCH_METHOD, OPTIONS_METHOD));

        configuration.setAllowedHeaders(
                List.of(AUTHORIZATION_HEADER, CONTENT_TYPE_HEADER,
                        ACCEPT_HEADER));

        // Cho phép gửi credentials (cookie, header, v.v.)
        configuration.setAllowCredentials(true);

        // Expose header "Authorization"
        configuration.setExposedHeaders(List.of(AUTHORIZATION_HEADER));

        // Thời gian cache preflight request
        configuration.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source =
                new UrlBasedCorsConfigurationSource();

        // Áp dụng cấu hình cho tất cả các endpoint
        source.registerCorsConfiguration(URL_PATTERN_ALL, configuration);
        return source;
    }


    @Bean
    JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter authConverter =
                new JwtGrantedAuthoritiesConverter();
        authConverter.setAuthorityPrefix("");

        JwtAuthenticationConverter converter = new JwtAuthenticationConverter();
        converter.setJwtGrantedAuthoritiesConverter(authConverter);

        converter.setPrincipalClaimName("userId");

        return converter;
    }
}

gateway-server
package com.gatewayserver.dto.request.attribute;

public record AssignAttributeRequestBody(
    String variantId,
    String attributeId) {}


package com.gatewayserver.dto.request.attribute;

public record AttributeCreateRequestBody(
    String name,
    String value) {}


package com.gatewayserver.dto.request.attribute;

public record AttributeListByVariantBody(
    String variantId,
    Integer page,
    Integer size) {}

package com.gatewayserver.dto.request.attribute;

public record AttributeListRequestBody(
    String q,
    Integer page,
    Integer size) {}

package com.gatewayserver.dto.request.authentication;

public record IntrospectRequestBody(String token) {
}

package com.gatewayserver.dto.request.authentication;

public record LoginRequestBody(
        String username,
        String email,
        String password) {
}

package com.gatewayserver.dto.request.authentication;

public record LogoutRequestBody(String token) {
}

package com.gatewayserver.dto.request.authentication;

public record RefreshRequestBody(String token) {
}

package com.gatewayserver.dto.request.authentication;

public record RegisterRequestBody(
        String username,
        String email,
        String password) {
}


package com.gatewayserver.dto.request.brand;

public record BrandCreateRequestBody(
        String name,
        String slug,
        String description) {}

package com.gatewayserver.dto.request.brand;

public record BrandUpdateRequestBody(
        String name,
        String slug,
        String description) {}

package com.gatewayserver.dto.request.category;

public record CategoryCreateRequestBody(
        String name,
        String slug,
        String description,
        String parentId) {}

package com.gatewayserver.dto.request.category;

public record CategoryReparentRequestBody(
        String newParentId) {}

package com.gatewayserver.dto.request.category;

public record CategoryUpdateRequestBody(
        String name,
        String slug,
        String description) {}
package com.gatewayserver.dto.request.discount;

public record DiscountCodeRequestBody(
    String code,
    String orderValue,
    String at) {}

package com.gatewayserver.dto.request.discount;

public record DiscountCreateRequestBody(
    String code,
    String type,
    String value,
    String startDate,
    String endDate,
    String minOrderValue,
    Boolean isActive) {}

package com.gatewayserver.dto.request.discount;

public record DiscountListRequestBody(
    Boolean onlyEffective,
    String at,
    Integer page,
    Integer size) {}

package com.gatewayserver.dto.request.discount;

public record DiscountToggleActiveBody(
    Boolean isActive) {}

package com.gatewayserver.dto.request.discount;

public record DiscountUpdateRequestBody(
    String code,
    String type,
    String value,
    String startDate,
    String endDate,
    String minOrderValue,
    Boolean isActive) {}

package com.gatewayserver.dto.request.image;

public record ImageCreateRequestBody(
    String productId,
    String variantId,
    String imageUrl) {}

package com.gatewayserver.dto.request.image;

public record ImageListRequestBody(
    String productId,
    String variantId,
    Integer page,
    Integer size) {}

package com.gatewayserver.dto.request.otp;

public record OtpVerificationRequestBody(
        String email,
        String otpCode) {
}

package com.gatewayserver.dto.request.otp;

public record ResetPasswordRequestBody(
        String email,
        String otp,
        String newPassword) {
}
package com.gatewayserver.dto.request.otp;

public record UserOtpRequestBody(String email) {
}
package com.gatewayserver.dto.request.product;
public record AssignCategoryRequestBody(
        String productId,
        String categoryId) {}

package com.gatewayserver.dto.request.product;

public record ProductCreateRequestBody(
        String name,
        String slug,
        String description,
        String brandId) {}

package com.gatewayserver.dto.request.product;

public record ProductUpdateRequestBody(
        String name,
        String slug,
        String description,
        String brandId) {}

package com.gatewayserver.dto.request.user;


public record AddressCreateRequestBody (
    String contactName,
    String contactPhone,
    String addressLine1,
    String addressLine2,
    String district,
    String city,
    String country,
    String postalCode)
{}
package com.gatewayserver.dto.request.user;

public record AddressUpdateRequestBody (
    String contactName,
    String contactPhone,
    String addressLine1,
    String addressLine2,
    String district,
    String city,
    String country,
    String postalCode){
}

package com.gatewayserver.dto.request.user;

public record AssignRoleRequestBody (
    String userId,
    String roleName){
}


package com.gatewayserver.dto.request.user;

public record CreateRoleRequestBody (
    String name){
}

package com.gatewayserver.dto.request.user;

public record UpdateProfileRequestBody (
    String fullName,
    String phoneNumber){
}

package com.gatewayserver.dto.request.variant;

public record VariantCreateRequestBody(
    String productId,
    String sku,
    String price,
    String originalPrice) {}
package com.gatewayserver.dto.request.variant;

public record VariantListByProductBody(
    String productId,
    Integer page,
    Integer size) {}
package com.gatewayserver.dto.request.variant;

public record VariantPricePatchBody(
    String price,
    String originalPrice) {}
package com.gatewayserver.dto.request.variant;

public record VariantSkuLookupBody(
    String sku) {}
package com.gatewayserver.dto.request.variant;

public record VariantUpdateRequestBody(
    String sku,
    String price,
    String originalPrice) {}
package com.gatewayserver.dto.response.attribute;

public record AttributeView(
    String id,
    String name,
    String value) {}
package com.gatewayserver.dto.response.authentication;

public record IntrospectView(
        boolean valid,
        String userId) {
}
package com.gatewayserver.dto.response.authentication;

public record LoginView(
        String accessToken,
        String refreshToken,
        String accessExpiry,
        String refreshExpiry) {
}
package com.gatewayserver.dto.response.authentication;

public record RefreshView(
        String accessToken,
        String refreshToken,
        String accessExpiry,
        String refreshExpiry) {
}
package com.gatewayserver.dto.response.brand;

public record BrandView(
        String id,
        String name,
        String slug,
        String description) {}

package com.gatewayserver.dto.response.category;

public record CategoryView(
        String id,
        String name,
        String slug,
        String description,
        String parentId) {}
package com.gatewayserver.dto.response.discount;

public record DiscountValidationView(
    Boolean valid,
    String reason,
    String discountAmount) {}
package com.gatewayserver.dto.response.discount;

public record DiscountView(
    String id,
    String code,
    String type,
    String value,
    String startDate,
    String endDate,
    String minOrderValue,
    Boolean isActive) {}
package com.gatewayserver.dto.response.image;

public record ImageView(
    String id,
    String productId,
    String variantId,
    String imageUrl,
    Boolean isThumbnail) {}
package com.gatewayserver.dto.response.otp;

public record OtpResponseView(
        String email,
        String message
) {
}
package com.gatewayserver.dto.response.product;

public record ProductView(
        String id,
        String name,
        String slug,
        String description,
        String status,
        String brandId) {}

package com.gatewayserver.dto.response.user;


public record AddressResponseView (
    String id,
    String contactName,
    String contactPhone,
    String addressLine1,
    String addressLine2,
    String district,
    String city,
    String country,
    String postalCode,
    Boolean isDefaultShipping,
    Boolean isDefaultBilling){
}
package com.gatewayserver.dto.response.user;


public record MeResponseView (
    String id,
    String username,
    String email,
    String fullName,
    String phoneNumber,
    Boolean isActive,
    Boolean isVerified){
}
package com.gatewayserver.dto.response.user;

public record RoleResponseView (
    String name){
}

package com.gatewayserver.dto.response.variant;

public record VariantView(
    String id,
    String productId,
    String sku,
    String price,
    String originalPrice) {}

package com.gatewayserver.exception;

import io.grpc.StatusRuntimeException;
import org.common.http.Envelope;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
public class GlobalErrorHandler {

    @ExceptionHandler(StatusRuntimeException.class)
    public ResponseEntity<Envelope<Void>> handleGrpcException(
            StatusRuntimeException statusRuntimeException){
        Envelope<Void> envelope = GrpcErrorMapper.toEnvelope(statusRuntimeException);
        return ResponseEntity.status(envelope.getStatus())
                .body(envelope);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Envelope<Void>> handleAnyException(
            Exception exception){
        Envelope<Void> envelope = Envelope.err(
                500,
                "UNCATEGORIZED_EXCEPTION",
                exception.getMessage(),
                null
        );
        return ResponseEntity.status(500)
                .body(envelope);
    }
}
package com.gatewayserver.exception;

import io.grpc.Status;
import io.grpc.StatusRuntimeException;
import lombok.NoArgsConstructor;
import org.common.exception.ErrorCode;
import org.common.http.Envelope;

import java.util.EnumMap;
import java.util.Map;
import java.util.Optional;

@NoArgsConstructor
public final class GrpcErrorMapper {
    private static final Map<Status.Code, ErrorCode> FALLBACK_BY_GRPC =
            new EnumMap<>(Status.Code.class);
    static {
        FALLBACK_BY_GRPC.put(Status.Code.UNAUTHENTICATED, ErrorCode.UNAUTHENTICATED);
        FALLBACK_BY_GRPC.put(Status.Code.PERMISSION_DENIED, ErrorCode.UNAUTHORIZED);
        FALLBACK_BY_GRPC.put(Status.Code.NOT_FOUND, ErrorCode.USER_NOT_FOUND);
        FALLBACK_BY_GRPC.put(Status.Code.ALREADY_EXISTS, ErrorCode.USER_ALREADY_EXISTS);
        FALLBACK_BY_GRPC.put(Status.Code.INVALID_ARGUMENT, ErrorCode.FAILED_VALIDATE_TOKEN);
        FALLBACK_BY_GRPC.put(Status.Code.FAILED_PRECONDITION, ErrorCode.FAILED_VALIDATE_TOKEN);
    }

    private static Optional<ErrorCode> fromName(
            String name){
        if (name == null || name.isBlank()) {
            return Optional.empty();
        }
        try {
            return Optional.of(ErrorCode.valueOf(name));
        } catch (IllegalArgumentException ex) {
            return Optional.empty();
        }
    }

    public static <T> Envelope<T> toEnvelope(
            StatusRuntimeException exception){
        String description = exception.getStatus().getDescription();
        Status.Code grpc = exception.getStatus().getCode();

        ErrorCode errorCode = fromName(description)
                .orElse(FALLBACK_BY_GRPC.getOrDefault(grpc, ErrorCode.UNCATEGORIZED_EXCEPTION));

        return Envelope.err(
                errorCode.http(),
                errorCode.name(),
                errorCode.getMessage(),
                null
        );
    }
}
package com.gatewayserver.helper;

import com.gatewayserver.configuration.grpc.ClientBearerInterceptor;
import com.gatewayserver.configuration.helper.ReactiveTokenHelper;
import com.gatewayserver.exception.GrpcErrorMapper;
import io.grpc.Channel;
import io.grpc.StatusRuntimeException;
import lombok.experimental.UtilityClass;
import org.common.http.Envelope;
import org.springframework.http.ResponseEntity;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

import java.util.function.Function;
import java.util.function.Supplier;

@UtilityClass
public class GrpcHelper {

    // ===== Helper chung cho tất cả endpoint =====
    public <R, V> Mono<ResponseEntity<Envelope<V>>> callGrpc(
            Supplier<R> supplier,
            Function<R, V> mapper) {
        return Mono.fromCallable(supplier::get)
                .map(mapper)
                .map(Envelope::ok)
                .map(ResponseEntity::ok)
                .onErrorResume(StatusRuntimeException.class, ex ->
                        Mono.just(GrpcErrorMapper.<V>toEnvelope(ex))
                                .map(env -> ResponseEntity
                                        .status(env.getStatus())
                                        .body(env)))
                .subscribeOn(Schedulers.boundedElastic());
    }

    public Mono<ResponseEntity<Envelope<Void>>> callGrpcVoid(
            Runnable runnable) {
        return Mono.fromRunnable(runnable)
                .thenReturn(Envelope.<Void>ok(null))
                .map(ResponseEntity::ok)
                .onErrorResume(io.grpc.StatusRuntimeException.class, ex ->
                        Mono.just(GrpcErrorMapper.<Void>toEnvelope(ex))
                                .map(env -> ResponseEntity
                                        .status(env.getStatus())
                                        .body(env)))
                .subscribeOn(Schedulers.boundedElastic());
    }

    /**
     * Tạo STUB theo từng request + gắn Bearer token vào Metadata
     * @param channel   Channel đã @GrpcClient(...)
     * @param stubMaker Hàm nhận Channel => trả về Stub (BlockingStub)
     * @param caller    Gọi gRPC bằng stub đã gắn token
     * @param mapper    Map response ra view
     */
    public <StubT, RespT, ViewT> Mono<ResponseEntity<Envelope<ViewT>>> callGrpc(
            Channel channel,
            Function<Channel, StubT> stubMaker,
            Function<StubT, RespT> caller,
            Function<RespT, ViewT> mapper
    ) {
        return ReactiveTokenHelper.currentBearerToken()
                .switchIfEmpty(Mono.error(new RuntimeException("UNAUTHENTICATED")))
                .flatMap(token -> Mono.fromCallable(() -> {
                                    Channel authed = ClientBearerInterceptor.withToken(channel, token);
                                    StubT stub = stubMaker.apply(authed);
                                    return caller.apply(stub);
                                })
                                .map(mapper)
                                .map(Envelope::ok)
                                .map(ResponseEntity::ok)
                                .onErrorResume(io.grpc.StatusRuntimeException.class, ex ->
                                        Mono.just(com.gatewayserver.exception.GrpcErrorMapper.<ViewT>toEnvelope(ex))
                                                .map(env -> ResponseEntity.status(env.getStatus()).body(env)))
                                .subscribeOn(Schedulers.boundedElastic())
                );
    }

    public <StubT> Mono<ResponseEntity<Envelope<Void>>> callGrpcVoid(
            Channel channel,
            Function<Channel, StubT> stubMaker,
            java.util.function.Consumer<StubT> caller
    ) {
        return ReactiveTokenHelper.currentBearerToken()
                .switchIfEmpty(Mono.error(new RuntimeException("UNAUTHENTICATED")))
                .flatMap(token -> Mono.fromRunnable(() -> {
                                    Channel authed = ClientBearerInterceptor.withToken(channel, token);
                                    StubT stub = stubMaker.apply(authed);
                                    caller.accept(stub);
                                })
                                .thenReturn(Envelope.<Void>ok(null))
                                .map(ResponseEntity::ok)
                                .onErrorResume(io.grpc.StatusRuntimeException.class, ex ->
                                        Mono.just(com.gatewayserver.exception.GrpcErrorMapper.<Void>toEnvelope(ex))
                                                .map(env -> ResponseEntity.status(env.getStatus()).body(env)))
                                .subscribeOn(Schedulers.boundedElastic())
                );
    }
}

