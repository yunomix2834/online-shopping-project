Hệ thống tôi có các service giao tiếp với nhau thông qua grpc, và tập trung lại ở gateway để trả response cho người
- Sửa để fix việc map lỗi đúng. Khi lỗi ở service throw ra có code cụ thể nhưng ở response gateway lại trả ra lỗi không xác định



common
common.proto
syntax = "proto3";

package onlineshopping.v1;
option java_package = "com.common.grpc";

option java_multiple_files = true;

message IdRequest {
  string id = 1;
}

message SlugRequest {
  string slug = 1;
}

role.proto
syntax = "proto3";
package onlineshopping.v1;
option java_multiple_files = true;
option java_package = "com.common.grpc";
option java_outer_classname = "RoleProto";
import "google/protobuf/empty.proto";

message CreateRoleRequest {
  string name = 1;
}
message RoleName {
  string name = 1;
}
message AssignRoleRequest {
  string user_id = 1;
  string role_name = 2;
}
message RoleResponse {
  string name = 1;
}

message PageRequest {
  int32 page = 1;
  int32 size = 2;
}
message PageRole {
  int32 page = 1;
  int32 size = 2;
  int64 total = 3;
  int32 total_pages = 4;
  repeated RoleResponse docs = 5;
}
message MeLite {
  string id = 1;
  string username = 2;
  string email = 3;
  string full_name = 4;
}
message PageUser {
  int32 page = 1;
  int32 size = 2;
  int64 total = 3;
  int32 total_pages = 4;
  repeated MeLite docs = 5;
}

package org.common.http;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;

import java.time.Instant;
import java.util.List;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = lombok.AccessLevel.PRIVATE)
public class Envelope<T> {

    @Builder.Default
    int status = 200;

    String error;

    @Builder.Default
    String msg = "OK";

    @Builder.Default
    Instant currentTime = Instant.now();

    T data;

    /* Helpers */
    public static <T> Envelope<T> ok(T data){
        return Envelope.<T>builder()
                .status(200)
                .error(null)
                .msg("OK")
                .currentTime(Instant.now())
                .data(data)
                .build();
    }
    public static <T> Envelope<T> err(
            int status,
            String code,
            String message,
            T data){
        return Envelope.<T>builder()
                .status(status)
                .error(code)
                .msg(message)
                .currentTime(Instant.now())
                .data(data)
                .build();
    }

    public static <TDoc> Envelope<Page<TDoc>> okPage(
            int page, int size,
            long total, int totalPages,
            List<TDoc> docs){
        return Envelope.ok(Page.<TDoc>builder()
                .page(page)
                .size(size)
                .total(total)
                .totalPages(totalPages)
                .docs(docs)
                .build()
        );
    }

    @Getter @Setter @Builder
    @NoArgsConstructor @AllArgsConstructor
    @FieldDefaults(level = lombok.AccessLevel.PRIVATE)
    public static class Page<TDoc>{
        int page;
        int size;
        long total;
        int totalPages;

        @Builder.Default
        List<TDoc> docs = List.of();
    }
}
package org.common.exception;


import lombok.Getter;

@Getter
public class AppException extends RuntimeException {
    private final ErrorCode errorCode;
    public AppException(ErrorCode errorCode) {
        super(errorCode.getMessage());
        this.errorCode = errorCode;
    }
}
package org.common.exception;

import lombok.Getter;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;

import static org.common.constant.ErrorCodeConstant.BAD_REQUEST_STATUS;
import static org.common.constant.ErrorCodeConstant.CONFLICT_STATUS;
import static org.common.constant.ErrorCodeConstant.FORBIDDEN_STATUS;
import static org.common.constant.ErrorCodeConstant.INTERNAL_SERVER_STATUS;
import static org.common.constant.ErrorCodeConstant.NOT_FOUND_STATUS;
import static org.common.constant.ErrorCodeConstant.UNAUTHORIZED_STATUS;
import static org.springframework.http.HttpStatus.BAD_REQUEST;

@Getter
public enum ErrorCode {
    // 500
    UNCATEGORIZED_EXCEPTION(999, INTERNAL_SERVER_STATUS, "Lỗi chưa phân loại", HttpStatus.INTERNAL_SERVER_ERROR),

    // 400
    VALIDATION_FAILED(400, BAD_REQUEST_STATUS, "Dữ liệu không hợp lệ!", org.springframework.http.HttpStatus.BAD_REQUEST),
    INVALID_OTP(400, BAD_REQUEST_STATUS, "OTP không hợp lệ!", BAD_REQUEST),
    OTP_EXPIRED(400, BAD_REQUEST_STATUS, "OTP đã hết hạn!", BAD_REQUEST),
    EMAIL_SEND_FAILED(4008003, BAD_REQUEST_STATUS, "Gửi email thất bại!", BAD_REQUEST),
    PARENT_CYCLE(400, BAD_REQUEST_STATUS, "Chu kỳ danh mục (parent) không hợp lệ", BAD_REQUEST),
    THUMBNAIL_ALREADY_SET(400, BAD_REQUEST_STATUS, "Đã có thumbnail cho thực thể này", BAD_REQUEST),

    // 401
    UNAUTHENTICATED(401, UNAUTHORIZED_STATUS, "Chưa xác thực!", HttpStatus.UNAUTHORIZED),
    INVALID_CREDENTIALS(401, UNAUTHORIZED_STATUS, "Thông tin đăng nhập không hợp lệ!", HttpStatus.UNAUTHORIZED),
    INVALID_TOKEN(401, UNAUTHORIZED_STATUS, "Token không hợp lệ!", HttpStatus.UNAUTHORIZED),
    TOKEN_REVOKED(401, UNAUTHORIZED_STATUS, "Token đã bị thu hồi!", HttpStatus.UNAUTHORIZED),

    // 403
    UNAUTHORIZED(403, FORBIDDEN_STATUS, "Bạn không có quyền truy cập!", HttpStatus.FORBIDDEN),

    // 404
    USER_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy user", HttpStatus.NOT_FOUND),
    ROLE_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy vai trò", HttpStatus.NOT_FOUND),
    ADDRESS_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy địa chỉ", HttpStatus.NOT_FOUND),
    EMAIL_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy email", HttpStatus.NOT_FOUND),
    BRAND_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy thương hiệu", HttpStatus.NOT_FOUND),
    CATEGORY_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy danh mục", HttpStatus.NOT_FOUND),
    PRODUCT_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy sản phẩm", HttpStatus.NOT_FOUND),
    VARIANT_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy biến thể", HttpStatus.NOT_FOUND),
    ATTRIBUTE_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy thuộc tính", HttpStatus.NOT_FOUND),
    IMAGE_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy ảnh", HttpStatus.NOT_FOUND),
    DISCOUNT_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy mã giảm giá", HttpStatus.NOT_FOUND),

    // 409
    USER_ALREADY_EXISTS(409, CONFLICT_STATUS, "Người dùng đã tồn tại!", HttpStatus.CONFLICT),
    EMAIL_ALREADY_EXISTS(409, CONFLICT_STATUS, "Email đã tồn tại!", HttpStatus.CONFLICT),
    PASSWORD_ALREADY_EXISTS(409, CONFLICT_STATUS, "Mật khẩu đã tồn tại!", HttpStatus.CONFLICT),
    ROLE_ALREADY_EXISTS(409, CONFLICT_STATUS, "Vai trò đã tồn tại!", HttpStatus.CONFLICT),
    SLUG_CONFLICT(409, CONFLICT_STATUS, "Slug đã tồn tại", HttpStatus.CONFLICT),
    SKU_CONFLICT(409, CONFLICT_STATUS, "SKU đã tồn tại", HttpStatus.CONFLICT),

    // 500
    FAILED_GENERATE_TOKEN(500, INTERNAL_SERVER_STATUS, "Lỗi tạo JWT token!", HttpStatus.INTERNAL_SERVER_ERROR),
    FAILED_VALIDATE_TOKEN(500, INTERNAL_SERVER_STATUS, "Lỗi xác thực token!", HttpStatus.INTERNAL_SERVER_ERROR),
    MAIL_DELIVERY_FAILED(500, INTERNAL_SERVER_STATUS, "Gửi email thất bại!", HttpStatus.INTERNAL_SERVER_ERROR);

    private final int code;
    private final String status;
    private final String message;
    private final HttpStatusCode statusCode;

    ErrorCode(int code, String status, String message, HttpStatusCode statusCode) {
        this.code = code;
        this.status = status;
        this.message = message;
        this.statusCode = statusCode;
    }

    public int http() { return statusCode.value(); }
}



service RoleService {
  rpc Create(CreateRoleRequest) returns (google.protobuf.Empty);
  rpc SoftDelete(RoleName) returns (google.protobuf.Empty);
  rpc Restore(RoleName) returns (google.protobuf.Empty);
  rpc Assign(AssignRoleRequest) returns (google.protobuf.Empty);
  rpc Remove(AssignRoleRequest) returns (google.protobuf.Empty);
  rpc ListUserRoles(AssignRoleRequest) returns (PageRole); // use user_id, ignore role_name
  rpc ListUsersByRole(RoleName) returns (PageUser);
  rpc ListAll(PageRequest) returns (PageRole);
}
package org.common.exception;

import io.grpc.Status;
import io.grpc.StatusRuntimeException;
import jakarta.validation.ConstraintViolationException;
import lombok.extern.slf4j.Slf4j;
import net.devh.boot.grpc.server.advice.GrpcAdvice;
import net.devh.boot.grpc.server.advice.GrpcExceptionHandler;
import org.springframework.security.access.AccessDeniedException;

@Slf4j
@GrpcAdvice
public class GrpcServerExceptionAdvice {

    @GrpcExceptionHandler(AppException.class)
    public StatusRuntimeException handleAppException(AppException appException) {
        return GrpcStatusMapper.ex(appException.getErrorCode());
    }

    @GrpcExceptionHandler(AccessDeniedException.class)
    public StatusRuntimeException handleDeniedException(
            AccessDeniedException accessDeniedException) {
        return GrpcStatusMapper.ex(ErrorCode.UNAUTHORIZED);
    }

    @GrpcExceptionHandler(ConstraintViolationException.class)
    public StatusRuntimeException handleBadException(
            ConstraintViolationException constraintViolationException) {
        return GrpcStatusMapper.ex(ErrorCode.VALIDATION_FAILED);
    }

    @GrpcExceptionHandler(Throwable.class)
    public StatusRuntimeException handleAnyException(
            Throwable throwable) {
        return Status.INTERNAL.withDescription(ErrorCode.UNCATEGORIZED_EXCEPTION.name())
                .asRuntimeException();
    }
}
package org.common.exception;

import com.google.protobuf.Empty;
import io.grpc.Status;
import io.grpc.StatusRuntimeException;
import io.grpc.stub.StreamObserver;
import lombok.experimental.UtilityClass;

@UtilityClass
public class GrpcStatusMapper {

  public Status statusFor(ErrorCode errorCode) {
    return switch (errorCode) {
      // 400
      case VALIDATION_FAILED,
           INVALID_OTP,
           OTP_EXPIRED,
           EMAIL_SEND_FAILED,
           FAILED_VALIDATE_TOKEN
          -> Status.INVALID_ARGUMENT;

      // 401
      case UNAUTHENTICATED,
           INVALID_CREDENTIALS,
           INVALID_TOKEN,
           TOKEN_REVOKED
          -> Status.UNAUTHENTICATED;

      // 403
      case UNAUTHORIZED
          -> Status.PERMISSION_DENIED;

      // 404 – gom tất cả *_NOT_FOUND vào NOT_FOUND
      case USER_NOT_FOUND,
           ROLE_NOT_FOUND,
           ADDRESS_NOT_FOUND,
           EMAIL_NOT_FOUND,
           BRAND_NOT_FOUND,
           CATEGORY_NOT_FOUND,
           PRODUCT_NOT_FOUND,
           VARIANT_NOT_FOUND,
           ATTRIBUTE_NOT_FOUND,
           IMAGE_NOT_FOUND,
           DISCOUNT_NOT_FOUND
          -> Status.NOT_FOUND;

      // 409
      case USER_ALREADY_EXISTS,
           EMAIL_ALREADY_EXISTS,
           PASSWORD_ALREADY_EXISTS,
           ROLE_ALREADY_EXISTS,
           SLUG_CONFLICT,
           SKU_CONFLICT
          -> Status.ALREADY_EXISTS;

      // 500 & các lỗi khác
      default -> Status.INTERNAL;
    };
  }

    public StatusRuntimeException ex(
            ErrorCode errorCode) {
        return statusFor(errorCode).withDescription(errorCode.name())
                .asRuntimeException();
    }

    public <T> void fail(
            StreamObserver<T> streamObserver,
            ErrorCode errorCode) {
        streamObserver.onError(ex(errorCode));
    }

    public void ok(
            StreamObserver<Empty> streamObserver) {
        streamObserver.onNext(Empty.getDefaultInstance());
        streamObserver.onCompleted();
    }

    public static <T> void ok(StreamObserver<? super T> streamObserver, T payload) {
        streamObserver.onNext(payload);
        streamObserver.onCompleted();
    }
}
package org.common.constant;

import lombok.NoArgsConstructor;
import org.springframework.http.HttpStatus;

@NoArgsConstructor
public final class ErrorCodeConstant {
    public static final String INTERNAL_SERVER_STATUS = HttpStatus.INTERNAL_SERVER_ERROR.toString();
    public static final String BAD_REQUEST_STATUS    = HttpStatus.BAD_REQUEST.toString();
    public static final String UNAUTHORIZED_STATUS   = HttpStatus.UNAUTHORIZED.toString();
    public static final String FORBIDDEN_STATUS      = HttpStatus.FORBIDDEN.toString();
    public static final String NOT_FOUND_STATUS      = HttpStatus.NOT_FOUND.toString();
    public static final String CONFLICT_STATUS       = HttpStatus.CONFLICT.toString();
}
package org.common.constant;

import lombok.NoArgsConstructor;

@NoArgsConstructor
public class RoleConstant {
  public static final String ADMIN_ROLE = "ADMIN";
  public static final String USER_ROLE = "USER";
}
package org.common.constant;

public final class SecurityConstants {
    // Headers
    public static final String AUTHORIZATION_HEADER = "Authorization";
    public static final String CONTENT_TYPE_HEADER  = "Content-Type";
    public static final String ACCEPT_HEADER        = "Accept";

    // CORS mặc định
    public static final String FRONTEND_ENDPOINT = "http://localhost:4200";

    // Public endpoints chuẩn
    public static final String[] PUBLIC_ENDPOINTS = {
            "/health", "/actuator/**", "/auth/**", "/h2-console/**"
    };

    // Methods
    public static final String GET="GET", POST="POST", PUT="PUT", DELETE="DELETE", PATCH="PATCH", OPTIONS="OPTIONS";

    // Path
    public static final String URL_PATTERN_ALL = "/**";

    private SecurityConstants(){}
}



gatewayserver

package com.gatewayserver.configuration.security;

import com.common.grpc.AuthServiceGrpc;
import com.common.grpc.IntrospectRequest;
import com.common.grpc.IntrospectResponse;
import com.nimbusds.jwt.SignedJWT;
import lombok.RequiredArgsConstructor;
import net.devh.boot.grpc.client.inject.GrpcClient;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.security.oauth2.jwt.ReactiveJwtDecoder;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

import java.text.ParseException;
import java.time.Instant;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

@Component
@RequiredArgsConstructor
public class GrpcReactiveJwtDecoder implements ReactiveJwtDecoder {

    @GrpcClient("core")
    private AuthServiceGrpc.AuthServiceBlockingStub authServiceBlockingStub;

    @Override
    public Mono<Jwt> decode(String token) throws JwtException {
        return Mono.fromCallable(() -> {
                    IntrospectResponse introspectResponse = authServiceBlockingStub
                            .introspect(IntrospectRequest.newBuilder()
                                        .setToken(token)
                                        .build());

                    if (!introspectResponse.getValid()) {
                        throw new JwtException("INVALID_TOKEN");
                    }

                    SignedJWT signedJWT;
                    try {
                        signedJWT = SignedJWT.parse(token);
                    } catch (ParseException e) {
                        throw new JwtException("JWT_PARSE_ERROR", e);
                    }

                    Map<String, Object> headers =
                            new HashMap<>(signedJWT.getHeader().toJSONObject());

                    Map<String, Object> claims =
                            new HashMap<>(signedJWT.getJWTClaimsSet().getClaims());

                    Date iat = signedJWT.getJWTClaimsSet().getIssueTime();
                    Date exp = signedJWT.getJWTClaimsSet().getExpirationTime();

                    Instant issuedAt = (iat == null) ? null : iat.toInstant();
                    Instant expiresAt = (exp == null) ? null : exp.toInstant();

                    return new Jwt(token, issuedAt, expiresAt, headers, claims);
                })
                .onErrorMap(e -> (e instanceof JwtException)
                        ? e
                        : new JwtException("AUTH_INTROSPECT_UNAVAILABLE", e));
    }
}

package com.gatewayserver.configuration.security;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.common.exception.ErrorCode;
import org.common.http.Envelope;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.server.ServerAuthenticationEntryPoint;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

@Component
public class ReactiveJwtEntryPoint implements ServerAuthenticationEntryPoint {

  private final ObjectMapper mapper = new ObjectMapper();

  @Override
  public Mono<Void> commence(
      ServerWebExchange exchange,
      AuthenticationException authenticationException) {
    ErrorCode code = ErrorCode.UNAUTHENTICATED;
    Envelope<Void> envelope = Envelope.err(
        code.http(),
        code.name(),
        code.getMessage(),
        null
    );

    ServerHttpResponse response = exchange.getResponse();
    response.setStatusCode(HttpStatus.valueOf(code.http()));
    response.getHeaders().setContentType(MediaType.APPLICATION_JSON);
    return response.writeWith(Mono.fromSupplier(() -> {
      try {
        byte[] bytes = mapper.writeValueAsBytes(envelope);
        return response.bufferFactory().wrap(bytes);
      } catch (Exception e) {
        return response.bufferFactory().wrap(new byte[0]);
      }
    }));
  }
}


package com.gatewayserver.configuration.security;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.oauth2.server.resource.authentication.ReactiveJwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.ReactiveJwtGrantedAuthoritiesConverterAdapter;
import org.springframework.security.web.server.SecurityWebFilterChain;

import static org.common.constant.SecurityConstants.PUBLIC_ENDPOINTS;

@Configuration
@RequiredArgsConstructor
public class SecurityConfiguration {

    private final GrpcReactiveJwtDecoder jwtDecoder;
    private final ReactiveJwtEntryPoint entryPoint;

    @Bean
    public SecurityWebFilterChain springSecurityFilterChain(
            ServerHttpSecurity http) {
        return http.csrf(ServerHttpSecurity.CsrfSpec::disable)
                .authorizeExchange(ex -> ex
                        .pathMatchers(PUBLIC_ENDPOINTS).permitAll()
                        .anyExchange().authenticated())
                .oauth2ResourceServer(oauth -> oauth.jwt(j -> j
                                .jwtDecoder(jwtDecoder)
                                .jwtAuthenticationConverter(reactiveJwtConverter())
                    )
                        .authenticationEntryPoint(entryPoint))
                .build();
    }

  @Bean
  public ReactiveJwtAuthenticationConverter reactiveJwtConverter() {
    JwtGrantedAuthoritiesConverter authoritiesConverter = new JwtGrantedAuthoritiesConverter();
    authoritiesConverter.setAuthoritiesClaimName("roles");
    authoritiesConverter.setAuthorityPrefix("");

    ReactiveJwtAuthenticationConverter converter = new ReactiveJwtAuthenticationConverter();
    converter.setJwtGrantedAuthoritiesConverter(
        new ReactiveJwtGrantedAuthoritiesConverterAdapter(authoritiesConverter)
    );
    converter.setPrincipalClaimName("userId");
    return converter;
  }
}
package com.gatewayserver.configuration.helper;

import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.security.oauth2.server.resource.authentication.AbstractOAuth2TokenAuthenticationToken;
import org.springframework.security.oauth2.server.resource.authentication.BearerTokenAuthentication;
import reactor.core.publisher.Mono;

public final class ReactiveTokenHelper {
    private ReactiveTokenHelper() {}

    public static Mono<String> currentBearerToken() {
        return ReactiveSecurityContextHolder.getContext()
                .flatMap(ctx -> Mono.justOrEmpty(ctx.getAuthentication()))
                .filter(Authentication::isAuthenticated)
                .ofType(AbstractOAuth2TokenAuthenticationToken.class)
                .map(b -> b.getToken().getTokenValue())
                .filter(t -> t != null && !t.isBlank());
    }

}

package com.gatewayserver.configuration.grpc;

import io.grpc.CallOptions;
import io.grpc.Channel;
import io.grpc.ClientCall;
import io.grpc.ClientInterceptor;
import io.grpc.ClientInterceptors;
import io.grpc.ForwardingClientCall;
import io.grpc.Metadata;
import io.grpc.MethodDescriptor;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class ClientBearerInterceptor
        implements ClientInterceptor {

    private final String token;
    public static final Metadata.Key<String> AUTH =
            Metadata.Key.of("Authorization", Metadata.ASCII_STRING_MARSHALLER);

    @Override
    public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(
            MethodDescriptor<ReqT, RespT> methodDescriptor,
            CallOptions callOptions,
            Channel channel) {

        return new ForwardingClientCall.SimpleForwardingClientCall<ReqT, RespT>(channel.newCall(methodDescriptor, callOptions)) {
            @Override
            public void start(Listener<RespT> responseListener,
                              Metadata headers) {
                headers.put(AUTH, "Bearer " + token);
                super.start(responseListener, headers);
            }
        };
    }

    public static Channel withToken(
            Channel channel,
            String token) {
        return ClientInterceptors.intercept(channel, new ClientBearerInterceptor(token));
    }
}

package com.gatewayserver.controller;

import com.common.grpc.AssignRoleRequest;
import com.common.grpc.CreateRoleRequest;
import com.common.grpc.PageRequest;
import com.common.grpc.RoleName;
import com.common.grpc.RoleServiceGrpc;
import com.gatewayserver.dto.request.user.AssignRoleRequestBody;
import com.gatewayserver.dto.request.user.CreateRoleRequestBody;
import com.gatewayserver.dto.response.user.RoleResponseView;
import com.gatewayserver.helper.GrpcHelper;
import io.grpc.Channel;
import lombok.RequiredArgsConstructor;
import net.devh.boot.grpc.client.inject.GrpcClient;
import org.common.http.Envelope;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("/roles")
@RequiredArgsConstructor
public class RoleController {

    @GrpcClient("core")
    private Channel coreChannel;

    @PostMapping
    public Mono<ResponseEntity<Envelope<Void>>> create(
            @RequestBody CreateRoleRequestBody body){
        return GrpcHelper.callGrpcVoid(
                coreChannel,
                RoleServiceGrpc::newBlockingStub,
                stub -> stub.create(CreateRoleRequest.newBuilder()
                        .setName(body.name())
                        .build()));
    }

    @DeleteMapping("/{name}")
    public Mono<ResponseEntity<Envelope<Void>>> softDelete(
            @PathVariable String name){
        return GrpcHelper.callGrpcVoid(
                coreChannel,
                RoleServiceGrpc::newBlockingStub,
                stub -> stub.softDelete(RoleName.newBuilder()
                        .setName(name)
                        .build()));
    }

    @PostMapping("/{name}/restore")
    public Mono<ResponseEntity<Envelope<Void>>> restore(
            @PathVariable String name){
        return GrpcHelper.callGrpcVoid(
                coreChannel,
                RoleServiceGrpc::newBlockingStub,
                stub -> stub.restore(RoleName.newBuilder()
                        .setName(name)
                        .build()));
    }

    @PostMapping("/assign")
    public Mono<ResponseEntity<Envelope<Void>>> assign(
            @RequestBody AssignRoleRequestBody body){
        return GrpcHelper.callGrpcVoid(
                coreChannel,
                RoleServiceGrpc::newBlockingStub,
                stub -> stub.assign(AssignRoleRequest.newBuilder()
                        .setUserId(body.userId())
                        .setRoleName(body.roleName())
                        .build()));
    }

    @PostMapping("/remove")
    public Mono<ResponseEntity<Envelope<Void>>> remove(
            @RequestBody AssignRoleRequestBody body){
        return GrpcHelper.callGrpcVoid(
                coreChannel,
                RoleServiceGrpc::newBlockingStub,
                stub -> stub.remove(AssignRoleRequest.newBuilder()
                        .setUserId(body.userId())
                        .setRoleName(body.roleName())
                        .build()));
    }

    @GetMapping("/user/{userId}")
    public Mono<ResponseEntity<Envelope<Envelope.Page<RoleResponseView>>>> listUserRoles(
            @PathVariable String userId){
        return GrpcHelper.callGrpc(
                coreChannel,
                RoleServiceGrpc::newBlockingStub,
                stub -> stub.listUserRoles(AssignRoleRequest.newBuilder()
                        .setUserId(userId)
                        .build()),
                p -> Envelope.Page.<RoleResponseView>builder()
                        .page(p.getPage())
                        .size(p.getSize())
                        .total(p.getTotal())
                        .totalPages(p.getTotalPages())
                        .docs(p.getDocsList().stream()
                                .map(d -> new RoleResponseView(d.getName()))
                                .toList())
                        .build());
    }

    @GetMapping
    public Mono<ResponseEntity<Envelope<Envelope.Page<RoleResponseView>>>> listAll(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size){
        return GrpcHelper.callGrpc(
                coreChannel,
                RoleServiceGrpc::newBlockingStub,
                stub -> stub.listAll(PageRequest.newBuilder()
                        .setPage(page)
                        .setSize(size)
                        .build()),
                p -> Envelope.Page.<RoleResponseView>builder()
                        .page(p.getPage())
                        .size(p.getSize())
                        .total(p.getTotal())
                        .totalPages(p.getTotalPages())
                        .docs(p.getDocsList().stream()
                                .map(d -> new RoleResponseView(d.getName()))
                                .toList())
                        .build());
    }
}
package com.gatewayserver.exception;

import io.grpc.StatusRuntimeException;
import org.common.http.Envelope;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
public class GlobalErrorHandler {

    @ExceptionHandler(StatusRuntimeException.class)
    public ResponseEntity<Envelope<Void>> handleGrpcException(
            StatusRuntimeException statusRuntimeException){
        Envelope<Void> envelope = GrpcErrorMapper.toEnvelope(statusRuntimeException);
        return ResponseEntity.status(envelope.getStatus())
                .body(envelope);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Envelope<Void>> handleAnyException(
            Exception exception){
        Envelope<Void> envelope = Envelope.err(
                500,
                "UNCATEGORIZED_EXCEPTION",
                exception.getMessage(),
                null
        );
        return ResponseEntity.status(500)
                .body(envelope);
    }
}
package com.gatewayserver.exception;

import io.grpc.Status;
import io.grpc.StatusRuntimeException;
import lombok.NoArgsConstructor;
import org.common.exception.ErrorCode;
import org.common.http.Envelope;

@NoArgsConstructor
public final class GrpcErrorMapper {

    public static <T> Envelope<T> toEnvelope(
            StatusRuntimeException ex){
      Status status = ex.getStatus();
      String desc = status.getDescription();

      ErrorCode errorCode = resolveErrorCode(status, desc);

        return Envelope.err(
                errorCode.http(),
                errorCode.name(),
                errorCode.getMessage(),
                null
        );
    }


  public static ErrorCode resolveErrorCode(Status status, String desc) {
    if (desc != null) {
      try {
        return ErrorCode.valueOf(desc);
      } catch (IllegalArgumentException ignored) {
      }
    }

    return switch (status.getCode()) {
      case UNAUTHENTICATED ->
          ErrorCode.UNAUTHENTICATED;

      case PERMISSION_DENIED ->
          ErrorCode.UNAUTHORIZED;

      case INVALID_ARGUMENT, FAILED_PRECONDITION, OUT_OF_RANGE ->
          ErrorCode.VALIDATION_FAILED;

      case NOT_FOUND ->
          ErrorCode.USER_NOT_FOUND;

      case ALREADY_EXISTS ->
          ErrorCode.USER_ALREADY_EXISTS;

      default ->
          ErrorCode.UNCATEGORIZED_EXCEPTION;
    };
  }
}

package com.gatewayserver.helper;

import com.gatewayserver.configuration.grpc.ClientBearerInterceptor;
import com.gatewayserver.configuration.helper.ReactiveTokenHelper;
import com.gatewayserver.exception.GrpcErrorMapper;
import io.grpc.Channel;
import io.grpc.StatusRuntimeException;
import lombok.experimental.UtilityClass;
import org.common.http.Envelope;
import org.springframework.http.ResponseEntity;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

import java.util.function.Function;
import java.util.function.Supplier;

@UtilityClass
public class GrpcHelper {

    // ===== Helper chung cho tất cả endpoint =====
    public <R, V> Mono<ResponseEntity<Envelope<V>>> callGrpc(
            Supplier<R> supplier,
            Function<R, V> mapper) {
        return Mono.fromCallable(supplier::get)
                .map(mapper)
                .map(Envelope::ok)
                .map(ResponseEntity::ok)
                .onErrorResume(StatusRuntimeException.class, ex ->
                        Mono.just(GrpcErrorMapper.<V>toEnvelope(ex))
                                .map(env -> ResponseEntity
                                        .status(env.getStatus())
                                        .body(env)))
                .subscribeOn(Schedulers.boundedElastic());
    }

    public Mono<ResponseEntity<Envelope<Void>>> callGrpcVoid(
            Runnable runnable) {
        return Mono.fromRunnable(runnable)
                .thenReturn(Envelope.<Void>ok(null))
                .map(ResponseEntity::ok)
                .onErrorResume(io.grpc.StatusRuntimeException.class, ex ->
                        Mono.just(GrpcErrorMapper.<Void>toEnvelope(ex))
                                .map(env -> ResponseEntity
                                        .status(env.getStatus())
                                        .body(env)))
                .subscribeOn(Schedulers.boundedElastic());
    }

    /**
     * Tạo STUB theo từng request + gắn Bearer token vào Metadata
     * @param channel   Channel đã @GrpcClient(...)
     * @param stubMaker Hàm nhận Channel => trả về Stub (BlockingStub)
     * @param caller    Gọi gRPC bằng stub đã gắn token
     * @param mapper    Map response ra view
     */
    public <StubT, RespT, ViewT> Mono<ResponseEntity<Envelope<ViewT>>> callGrpc(
            Channel channel,
            Function<Channel, StubT> stubMaker,
            Function<StubT, RespT> caller,
            Function<RespT, ViewT> mapper
    ) {
        return ReactiveTokenHelper.currentBearerToken()
                .switchIfEmpty(Mono.error(new RuntimeException("UNAUTHENTICATED")))
                .flatMap(token -> Mono.fromCallable(() -> {
                                    Channel authed = ClientBearerInterceptor.withToken(channel, token);
                                    StubT stub = stubMaker.apply(authed);
                                    return caller.apply(stub);
                                })
                                .map(mapper)
                                .map(Envelope::ok)
                                .map(ResponseEntity::ok)
                                .onErrorResume(io.grpc.StatusRuntimeException.class, ex ->
                                        Mono.just(com.gatewayserver.exception.GrpcErrorMapper.<ViewT>toEnvelope(ex))
                                                .map(env -> ResponseEntity.status(env.getStatus()).body(env)))
                                .subscribeOn(Schedulers.boundedElastic())
                );
    }

    public <StubT> Mono<ResponseEntity<Envelope<Void>>> callGrpcVoid(
            Channel channel,
            Function<Channel, StubT> stubMaker,
            java.util.function.Consumer<StubT> caller
    ) {
        return ReactiveTokenHelper.currentBearerToken()
                .switchIfEmpty(Mono.error(new RuntimeException("UNAUTHENTICATED")))
                .flatMap(token -> Mono.fromRunnable(() -> {
                                    Channel authed = ClientBearerInterceptor.withToken(channel, token);
                                    StubT stub = stubMaker.apply(authed);
                                    caller.accept(stub);
                                })
                                .thenReturn(Envelope.<Void>ok(null))
                                .map(ResponseEntity::ok)
                                .onErrorResume(io.grpc.StatusRuntimeException.class, ex ->
                                        Mono.just(com.gatewayserver.exception.GrpcErrorMapper.<Void>toEnvelope(ex))
                                                .map(env -> ResponseEntity.status(env.getStatus()).body(env)))
                                .subscribeOn(Schedulers.boundedElastic())
                );
    }
}

core-service
package com.core.configuration.security;

import com.core.dto.request.authentication.IntrospectRequestDto;
import com.core.dto.response.authentication.IntrospectResponseDto;
import com.core.service.IAuthenticationService;
import com.nimbusds.jose.JOSEException;
import org.common.exception.AppException;
import org.common.exception.ErrorCode;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.oauth2.jose.jws.MacAlgorithm;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.stereotype.Component;

import javax.crypto.spec.SecretKeySpec;
import java.text.ParseException;
import java.util.Objects;


@Component
public class CustomJwtDecoder implements JwtDecoder {

    @Value("${app.jwt.signerKey}")
    private String signerKey;

    @Autowired
    private IAuthenticationService authenticationService;

    private NimbusJwtDecoder nimbusJwtDecoder;

    @Override
    public Jwt decode(String token) throws JwtException {
        try {
            IntrospectResponseDto response = authenticationService.introspect(
                    IntrospectRequestDto.builder()
                            .token(token)
                            .build());

            if (!response.isValid()) {
                throw new AppException(ErrorCode.INVALID_TOKEN);
            }
        } catch (JOSEException | ParseException e) {
            throw new AppException(ErrorCode.INVALID_TOKEN);
        }

        if (Objects.isNull(nimbusJwtDecoder)) {
            SecretKeySpec secretKeySpec =
                    new SecretKeySpec(signerKey.getBytes(), "HS512");

            nimbusJwtDecoder = NimbusJwtDecoder.withSecretKey(secretKeySpec)
                    .macAlgorithm(MacAlgorithm.HS512)
                    .build();
        }

        return nimbusJwtDecoder.decode(token);
    }
}
package com.core.configuration.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.ProviderManager;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationProvider;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;

@Configuration
public class GrpcJwtAuthManagerConfig {

  @Bean
  public JwtAuthenticationConverter grpcJwtAuthenticationConverter() {
    JwtGrantedAuthoritiesConverter authConverter = new JwtGrantedAuthoritiesConverter();
    authConverter.setAuthoritiesClaimName("roles");
    authConverter.setAuthorityPrefix("");

    JwtAuthenticationConverter converter = new JwtAuthenticationConverter();
    converter.setJwtGrantedAuthoritiesConverter(authConverter);
    converter.setPrincipalClaimName("userId");
    return converter;
  }

  @Bean
  public AuthenticationManager grpcAuthenticationManager(
      JwtDecoder jwtDecoder,
      JwtAuthenticationConverter grpcJwtAuthenticationConverter) {

    JwtAuthenticationProvider provider = new JwtAuthenticationProvider(jwtDecoder);
    provider.setJwtAuthenticationConverter(grpcJwtAuthenticationConverter);
    return new ProviderManager(provider);
  }
}

package com.core.configuration.security;

import io.grpc.CallOptions;
import io.grpc.Channel;
import io.grpc.ClientCall;
import io.grpc.ClientInterceptor;
import io.grpc.ForwardingClientCall;
import io.grpc.Metadata;
import io.grpc.MethodDescriptor;
import net.devh.boot.grpc.client.interceptor.GlobalClientInterceptorConfigurer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.oauth2.server.resource.authentication.BearerTokenAuthentication;

@Configuration
public class GrpcJwtClientPropagationConfig {

    static class JwtPropagatingClientInterceptor implements ClientInterceptor {
        private static final Metadata.Key<String> AUTH =
                Metadata.Key.of("Authorization", Metadata.ASCII_STRING_MARSHALLER);

        @Override
        public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(
                MethodDescriptor<ReqT, RespT> method,
                CallOptions callOptions,
                Channel next) {

            return new ForwardingClientCall.SimpleForwardingClientCall<>(next.newCall(method, callOptions)) {
                @Override
                public void start(Listener<RespT> responseListener, Metadata headers) {
                    String token = resolveToken();
                    if (token != null && !token.isBlank()) {
                        headers.put(AUTH, "Bearer " + token);
                    }
                    super.start(responseListener, headers);
                }
            };
        }

        private String resolveToken() {
            var ctx = SecurityContextHolder.getContext();
            if (ctx == null || ctx.getAuthentication() == null) return null;
            if (ctx.getAuthentication() instanceof BearerTokenAuthentication b) {
                return b.getToken().getTokenValue();
            }
            return null;
        }
    }

    @Bean
    public GlobalClientInterceptorConfigurer jwtPropagationConfigurer() {
        return interceptors -> interceptors.add(
                new JwtPropagatingClientInterceptor());
    }
}
package com.core.configuration.security;

import net.devh.boot.grpc.server.security.authentication.BearerAuthenticationReader;
import net.devh.boot.grpc.server.security.authentication.GrpcAuthenticationReader;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.oauth2.server.resource.authentication.BearerTokenAuthenticationToken;

@Configuration
public class GrpcServerSecurityConfig {
    @Bean
    public GrpcAuthenticationReader grpcAuthenticationReader() {
        return new BearerAuthenticationReader(token ->
                new BearerTokenAuthenticationToken(token));
    }
}
package com.core.configuration.security;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.common.exception.ErrorCode;
import org.common.http.Envelope;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;

import java.io.IOException;

public class JwtAuthenticationEntryPoint
        implements AuthenticationEntryPoint {
    @Override
    public void commence(
            HttpServletRequest request,
            HttpServletResponse response,
            AuthenticationException authException)
            throws IOException {
        ErrorCode errorCode = ErrorCode.UNAUTHENTICATED;
        Envelope<Void> envelope = Envelope.err(
                        errorCode.http(),
                        errorCode.name(),
                        errorCode.getMessage(),
                        null);

        response.setStatus(errorCode.http());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        new ObjectMapper().writeValue(response.getWriter(), envelope);
        response.flushBuffer();
    }
}
package com.core.configuration.security;

import lombok.NoArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.access.hierarchicalroles.RoleHierarchy;
import org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
@NoArgsConstructor
public class SecurityBeanConfig {


    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }


    @Bean
    public RoleHierarchy roleHierarchy() {
        return RoleHierarchyImpl.fromHierarchy("ROLE_ADMIN > ROLE_USER");
    }
}
package com.core.configuration.security;

import java.util.List;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import static org.common.constant.SecurityConstants.ACCEPT_HEADER;
import static org.common.constant.SecurityConstants.AUTHORIZATION_HEADER;
import static org.common.constant.SecurityConstants.CONTENT_TYPE_HEADER;
import static org.common.constant.SecurityConstants.FRONTEND_ENDPOINT;
import static org.common.constant.SecurityConstants.PUBLIC_ENDPOINTS;
import static org.common.constant.SecurityConstants.URL_PATTERN_ALL;
import static org.springdoc.core.utils.Constants.DELETE_METHOD;
import static org.springdoc.core.utils.Constants.GET_METHOD;
import static org.springdoc.core.utils.Constants.OPTIONS_METHOD;
import static org.springdoc.core.utils.Constants.PATCH_METHOD;
import static org.springdoc.core.utils.Constants.POST_METHOD;
import static org.springdoc.core.utils.Constants.PUT_METHOD;


@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfiguration {

    @Autowired
    private CustomJwtDecoder customJwtDecoder;


    @Bean
    public SecurityFilterChain securityFilterChain(
            HttpSecurity httpSecurity) throws Exception {
        httpSecurity
                .headers(headers -> headers.frameOptions(
                        frame -> frame.sameOrigin()))
                .authorizeHttpRequests(request -> request
                        .requestMatchers(PUBLIC_ENDPOINTS)
                        .permitAll()
                        .anyRequest()
                        .authenticated());

        httpSecurity.oauth2ResourceServer(
                oauth2 -> oauth2.jwt(jwtConfigurer -> jwtConfigurer
                                .decoder(customJwtDecoder)
                                .jwtAuthenticationConverter(
                                        jwtAuthenticationConverter()))
                        .authenticationEntryPoint(
                                new JwtAuthenticationEntryPoint()));
        httpSecurity.csrf(AbstractHttpConfigurer::disable);

        return httpSecurity.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();

        configuration.setAllowedOriginPatterns(List.of(
                FRONTEND_ENDPOINT
        ));

        configuration.setAllowedMethods(
                List.of(GET_METHOD, POST_METHOD, PUT_METHOD, DELETE_METHOD,
                        PATCH_METHOD, OPTIONS_METHOD));

        configuration.setAllowedHeaders(
                List.of(AUTHORIZATION_HEADER, CONTENT_TYPE_HEADER,
                        ACCEPT_HEADER));

        // Cho phép gửi credentials (cookie, header, v.v.)
        configuration.setAllowCredentials(true);

        // Expose header "Authorization"
        configuration.setExposedHeaders(List.of(AUTHORIZATION_HEADER));

        // Thời gian cache preflight request
        configuration.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source =
                new UrlBasedCorsConfigurationSource();

        // Áp dụng cấu hình cho tất cả các endpoint
        source.registerCorsConfiguration(URL_PATTERN_ALL, configuration);
        return source;
    }


    @Bean
    JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter authConverter =
                new JwtGrantedAuthoritiesConverter();
        authConverter.setAuthoritiesClaimName("roles");
        authConverter.setAuthorityPrefix("");

        JwtAuthenticationConverter converter = new JwtAuthenticationConverter();
        converter.setJwtGrantedAuthoritiesConverter(authConverter);

        converter.setPrincipalClaimName("userId");

        return converter;
    }
}
package com.core.configuration.exception;

import io.grpc.StatusRuntimeException;
import jakarta.validation.ConstraintViolationException;
import lombok.extern.slf4j.Slf4j;
import net.devh.boot.grpc.server.advice.GrpcExceptionHandler;
import org.common.exception.AppException;
import org.common.exception.ErrorCode;
import org.common.exception.GrpcStatusMapper;
import org.common.http.Envelope;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

@Slf4j
@ControllerAdvice
@ConditionalOnProperty(
        name = "core.http.error.enabled",
        havingValue = "true",
        matchIfMissing = false
)
public class GlobalExceptionHandler {

    @ExceptionHandler(AppException.class)
    public ResponseEntity<Envelope<Void>> handleAppException(
            AppException appException){
        ErrorCode errorCode = appException.getErrorCode();
        return ResponseEntity.status(errorCode.getStatusCode())
                .body(Envelope.err(
                        errorCode.http(),
                        errorCode.name(),
                        errorCode.getMessage(),
                        null)
                );
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Envelope<Void>> handleAnyException(
            Exception exception){
        ErrorCode errorCode = ErrorCode.UNCATEGORIZED_EXCEPTION;
        return ResponseEntity.status(errorCode.getStatusCode())
                .body(Envelope.err(
                        errorCode.http(),
                        errorCode.name(),
                        errorCode.getMessage(),
                        null)
                );
    }
}
package com.core.controller;

import com.common.grpc.AssignRoleRequest;
import com.common.grpc.CreateRoleRequest;
import com.common.grpc.MeLite;
import com.common.grpc.PageRequest;
import com.common.grpc.PageRole;
import com.common.grpc.PageUser;
import com.common.grpc.RoleName;
import com.common.grpc.RoleResponse;
import com.common.grpc.RoleServiceGrpc;
import com.core.dto.request.user.AssignRoleRequestDto;
import com.core.dto.request.user.CreateRoleRequestDto;
import com.core.dto.response.user.MeResponseDto;
import com.core.dto.response.user.RoleResponseDto;
import com.core.service.IRoleService;
import com.google.protobuf.Empty;
import io.grpc.stub.StreamObserver;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.extern.slf4j.Slf4j;
import net.devh.boot.grpc.server.service.GrpcService;
import org.common.exception.GrpcStatusMapper;
import org.common.http.Envelope;

@GrpcService
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@Slf4j
public class RoleGrpcServer extends RoleServiceGrpc.RoleServiceImplBase {
    private final IRoleService roleService;

    @Override
    public void create(
            CreateRoleRequest r,
            StreamObserver<Empty> responseObserver){
        roleService.create(CreateRoleRequestDto.builder()
                .name(r.getName())
                .build());
        GrpcStatusMapper.ok(responseObserver);
    }
    @Override
    public void softDelete(
            RoleName r,
            StreamObserver<Empty> responseObserver){
        roleService.softDelete(r.getName());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override public void restore(
            RoleName r,
            StreamObserver<Empty> responseObserver){
        roleService.restore(r.getName());
        GrpcStatusMapper.ok(responseObserver);
    }
    @Override
    public void assign(
            AssignRoleRequest r,
            StreamObserver<Empty> responseObserver){
        AssignRoleRequestDto dto = AssignRoleRequestDto.builder()
                .userId(r.getUserId())
                .roleName(r.getRoleName())
                .build();
        roleService.assign(dto);
        GrpcStatusMapper.ok(responseObserver);
    }
    @Override
    public void remove(
            AssignRoleRequest r,
            StreamObserver<Empty> responseObserver){
        AssignRoleRequestDto dto = AssignRoleRequestDto.builder()
                .userId(r.getUserId())
                .roleName(r.getRoleName())
                .build();
        roleService.remove(dto);
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void listUserRoles(
            AssignRoleRequest r,
            StreamObserver<PageRole> responseObserver) {
        Envelope.Page<RoleResponseDto> page = roleService.listUserRoles(
                r.getUserId(), 0, Integer.MAX_VALUE);
        PageRole.Builder builder = PageRole.newBuilder()
                .setPage(page.getPage())
                .setSize(page.getSize())
                .setTotal(page.getTotal())
                .setTotalPages(page.getTotalPages());

        page.getDocs().forEach(rr -> builder.addDocs(
                RoleResponse.newBuilder()
                        .setName(rr.getName())
                        .build()));

        GrpcStatusMapper.ok(responseObserver, builder.build());
    }

    @Override
    public void listUsersByRole(
            RoleName r,
            StreamObserver<PageUser> responseObserver) {
        Envelope.Page<MeResponseDto> page = roleService.listUsersByRole(
                r.getName(),0, Integer.MAX_VALUE);
        PageUser.Builder b = PageUser.newBuilder()
                .setPage(page.getPage())
                .setSize(page.getSize())
                .setTotal(page.getTotal())
                .setTotalPages(page.getTotalPages());
        page.getDocs().forEach(m -> b.addDocs(
                MeLite.newBuilder().setId(m.getId())
                        .setUsername(m.getUsername())
                        .setEmail(m.getEmail())
                        .setFullName(m.getFullName() == null
                                ? ""
                                : m.getFullName())
                        .build()));

        GrpcStatusMapper.ok(responseObserver, b.build());
    }

    @Override
    public void listAll(
            PageRequest r,
            StreamObserver<PageRole> responseObserver) {
        Envelope.Page<RoleResponseDto> page = roleService.listAllRoles(
                r.getPage(), r.getSize());
        PageRole.Builder b = PageRole.newBuilder()
                .setPage(page.getPage())
                .setSize(page.getSize())
                .setTotal(page.getTotal())
                .setTotalPages(page.getTotalPages());
        page.getDocs().forEach(rr -> b.addDocs(RoleResponse.newBuilder()
                .setName(rr.getName())
                .build()));

        GrpcStatusMapper.ok(responseObserver, b.build());
    }
}
package com.core.service.impl;

import com.core.dto.request.user.AssignRoleRequestDto;
import com.core.dto.request.user.CreateRoleRequestDto;
import com.core.dto.response.user.MeResponseDto;
import com.core.dto.response.user.RoleResponseDto;
import com.core.entity.Role;
import com.core.entity.User;
import com.core.helper.AuthenticationHelper;
import com.core.helper.UserHelper;
import com.core.mapper.user.UserProfileMapper;
import com.core.repository.UserRepository;
import com.core.repository.user.RoleRepository;
import com.core.service.IRoleService;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.extern.slf4j.Slf4j;
import org.common.exception.AppException;
import org.common.exception.ErrorCode;
import org.common.http.Envelope;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@Slf4j
public class RoleServiceImpl implements IRoleService {
    RoleRepository roleRepository;
    UserRepository userRepository;
    UserHelper userHelper;
    UserProfileMapper userProfileMapper;

    @Override
    @Transactional
    public void create(CreateRoleRequestDto request) {
        AuthenticationHelper.requireAdmin();
        if (roleRepository.existsById(request.getName())){
            throw new AppException(ErrorCode.ROLE_ALREADY_EXISTS);
        }
        Role r = Role.builder()
                .name(request.getName())
                .build();
        roleRepository.save(r);
    }

    @Override
    @Transactional
    public void softDelete(
            String roleName) {
        AuthenticationHelper.requireAdmin();
        Role r = roleRepository.findById(roleName)
                .orElseThrow(() -> new AppException(ErrorCode.ROLE_NOT_FOUND));
        r.markDeleted(AuthenticationHelper.getMyUserId());
        roleRepository.save(r);
    }

    @Override
    @Transactional
    public void restore(String roleName) {
        AuthenticationHelper.requireAdmin();
        roleRepository.findById(roleName)
                .orElseThrow(() -> new AppException(ErrorCode.ROLE_NOT_FOUND));
        int n = roleRepository.nativeRestore(roleName);
        if (n == 0) {
            throw new AppException(ErrorCode.ROLE_NOT_FOUND);
        }
    }

    @Override @Transactional
    public void assign(AssignRoleRequestDto request) {
        AuthenticationHelper.requireAdmin();
        User u = userHelper.getUserById(request.getUserId());
        Role r = roleRepository.findById(request.getRoleName())
                .orElseThrow(() -> new AppException(ErrorCode.ROLE_NOT_FOUND));
        u.getRoles().add(r);
        userRepository.save(u);
    }

    @Override
    @Transactional
    public void remove(AssignRoleRequestDto request) {
        AuthenticationHelper.requireAdmin();
        User u = userHelper.getUserById(request.getUserId());
        u.getRoles().removeIf(role -> role.getName()
                .equals(request.getRoleName()));
        userRepository.save(u);
    }

    @Override
    @Transactional(readOnly = true)
    public Envelope.Page<RoleResponseDto> listUserRoles(
            String userId,
            int page, int size) {
        User u = userHelper.getUserById(userId);
        List<RoleResponseDto> docs = u.getRoles().stream()
                .map(r -> RoleResponseDto.builder()
                        .name(r.getName())
                        .build())
                .toList();
        return Envelope.Page.<RoleResponseDto>builder()
                .page(page)
                .size(size)
                .total(docs.size())
                .totalPages(1)
                .docs(docs)
                .build();
    }

    @Override
    @Transactional(readOnly = true)
    public Envelope.Page<MeResponseDto> listUsersByRole(
            String roleName,
            int page, int size) {
        Pageable pageable = PageRequest.of(
                page,
                size,
                Sort.by("createdAt").descending()
        );
        Page<User> p = userRepository.findAll(pageable)
                .map(u -> u.getRoles()
                        .stream()
                        .anyMatch(r -> r.getName().equals(roleName))
                        ? u
                        : null);
        List<MeResponseDto> docs = p.getContent()
                .stream()
                .filter(u -> u != null)
                .map(userProfileMapper::toMeResponseDtoFromUser)
                .toList();
        return Envelope.Page.<MeResponseDto>builder()
                .page(page)
                .size(size)
                .total(docs.size())
                .totalPages(p.getTotalPages() == 0
                        ? 1
                        : p.getTotalPages())
                .docs(docs)
                .build();
    }

    @Override
    @Transactional(readOnly = true)
    public Envelope.Page<RoleResponseDto> listAllRoles(
            int page, int size) {
        Pageable pageable = PageRequest.of(page, size);
        Page<Role> p = roleRepository.findAll(pageable);
        List<RoleResponseDto> docs = p.stream()
                .map(r -> RoleResponseDto.builder()
                        .name(r.getName())
                        .build())
                .toList();
        return Envelope.Page.<RoleResponseDto>builder()
                .page(page)
                .size(size)
                .total(p.getTotalElements())
                .totalPages(p.getTotalPages())
                .docs(docs)
                .build();
    }
}

