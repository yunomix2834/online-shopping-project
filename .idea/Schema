Ban có thể code để thực hiện các chức năng sau đây được không
- restore dùng native query
- xác thực jwt token giữa các service và có phương thức để lưu khi truyền trong grpc để xác thực khi gọi api gateway forward sang các service nội bộ truyền với nhau bằng gRPC

**Tài khoản & xác thực**

* Khóa/Mở khóa tài khoản (`is_active`) → `Users`
* Lấy hồ sơ cá nhân (me) → `Users`
* Cập nhật hồ sơ (full_name, phone_number…) → `Users`

**Vai trò & phân quyền**

* Tạo vai trò mới → `Roles`
* Xóa/khôi phục vai trò (soft delete) → `Roles`
* Gán vai trò cho người dùng → `UserRoles` (→ `Users`, `Roles`)
* Gỡ vai trò khỏi người dùng → `UserRoles`
* Liệt kê vai trò của 1 user → `UserRoles`
* Liệt kê người dùng theo vai trò → `UserRoles` → `Users`
* Liệt kê tất cả vai trò → `Roles`

**Địa chỉ người dùng**

* Tạo địa chỉ → `Addresses` (→ `Users`)
* Sửa / Xóa (soft) địa chỉ → `Addresses`
* Đặt mặc định giao hàng (`is_default_shipping`) → `Addresses` (ensure 1-true/others-false cho user)
* Đặt mặc định thanh toán (`is_default_billing`) → `Addresses`
* Danh sách địa chỉ theo user → `Addresses`

common
syntax = "proto3";
package core.v1;
option java_multiple_files = true;
option java_package = "com.common.grpc";
option java_outer_classname = "AddressProto";
import "google/protobuf/empty.proto";

message AddressCreateRequest {
  string contact_name = 1;
  string contact_phone = 2;
  string address_line1 = 3;
  string address_line2 = 4;
  string district = 5;
  string city = 6;
  string country = 7;
  string postal_code = 8;
}
message AddressUpdateRequest {
  string id = 1;
  string contact_name = 2;
  string contact_phone = 3;
  string address_line1 = 4;
  string address_line2 = 5;
  string district = 6;
  string city = 7;
  string country = 8;
  string postal_code = 9;
}
message IdRequest {
  string id = 1;
}
message UserIdRequest {
  string user_id = 1;
  int32 page = 2;
  int32 size = 3;
}

message AddressView {
  string id = 1;
  string contact_name = 2;
  string contact_phone = 3;
  string address_line1 = 4;
  string address_line2 = 5;
  string district = 6;
  string city = 7;
  string country = 8;
  string postal_code = 9;
  bool is_default_shipping = 10;
  bool is_default_billing = 11;
}
message PageAddress {
  int32 page = 1;
  int32 size = 2;
  int64 total = 3;
  int32 total_pages = 4;
  repeated AddressView docs = 5;
}

service AddressService {
  rpc Create(AddressCreateRequest) returns (google.protobuf.Empty);
  rpc Update(AddressUpdateRequest) returns (google.protobuf.Empty);
  rpc SoftDelete(IdRequest) returns (google.protobuf.Empty);
  rpc SetDefaultShipping(IdRequest) returns (google.protobuf.Empty);
  rpc SetDefaultBilling(IdRequest) returns (google.protobuf.Empty);
  rpc ListByUser(UserIdRequest) returns (PageAddress);
}

syntax = "proto3";
package core.v1;
option java_multiple_files = true;
option java_package = "com.common.grpc";
option java_outer_classname = "RoleProto";
import "google/protobuf/empty.proto";

message CreateRoleRequest {
  string name = 1;
}
message RoleName {
  string name = 1;
}
message AssignRoleRequest {
  string user_id = 1;
  string role_name = 2;
}
message RoleResponse {
  string name = 1;
}

message PageRequest {
  int32 page = 1;
  int32 size = 2;
}
message PageRole {
  int32 page = 1;
  int32 size = 2;
  int64 total = 3;
  int32 total_pages = 4;
  repeated RoleResponse docs = 5;
}
message MeLite {
  string id = 1;
  string username = 2;
  string email = 3;
  string full_name = 4;
}
message PageUser {
  int32 page = 1;
  int32 size = 2;
  int64 total = 3;
  int32 total_pages = 4;
  repeated MeLite docs = 5;
}

service RoleService {
  rpc Create(CreateRoleRequest) returns (google.protobuf.Empty);
  rpc SoftDelete(RoleName) returns (google.protobuf.Empty);
  rpc Restore(RoleName) returns (google.protobuf.Empty);
  rpc Assign(AssignRoleRequest) returns (google.protobuf.Empty);
  rpc Remove(AssignRoleRequest) returns (google.protobuf.Empty);
  rpc ListUserRoles(AssignRoleRequest) returns (PageRole); // use user_id, ignore role_name
  rpc ListUsersByRole(RoleName) returns (PageUser);
  rpc ListAll(PageRequest) returns (PageRole);
}

syntax = "proto3";
package core.v1;
option java_multiple_files = true;
option java_package = "com.common.grpc";
option java_outer_classname = "UserProto";
import "google/protobuf/empty.proto";

message ToggleActiveRequest {
  string user_id = 1;
  bool active = 2;
}

message MeResponse {
  string id = 1;
  string username = 2;
  string email = 3;
  string full_name = 4;
  string phone_number = 5;
  bool is_active = 6;
  bool is_verified = 7;
}
message UpdateProfileRequest {
  string full_name = 1;
  string phone_number = 2;
}

service UserService {
  rpc ToggleActive(ToggleActiveRequest) returns (google.protobuf.Empty);
  rpc GetMe(google.protobuf.Empty) returns (MeResponse);
  rpc UpdateProfile(UpdateProfileRequest) returns (google.protobuf.Empty);
}

package org.common.constant;

import lombok.NoArgsConstructor;
import org.springframework.http.HttpStatus;

@NoArgsConstructor
public final class ErrorCodeConstant {
    public static final String INTERNAL_SERVER_STATUS = HttpStatus.INTERNAL_SERVER_ERROR.toString();
    public static final String BAD_REQUEST_STATUS    = HttpStatus.BAD_REQUEST.toString();
    public static final String UNAUTHORIZED_STATUS   = HttpStatus.UNAUTHORIZED.toString();
    public static final String FORBIDDEN_STATUS      = HttpStatus.FORBIDDEN.toString();
    public static final String NOT_FOUND_STATUS      = HttpStatus.NOT_FOUND.toString();
    public static final String CONFLICT_STATUS       = HttpStatus.CONFLICT.toString();
}

package org.common.constant;

public final class SecurityConstants {
    // Headers
    public static final String AUTHORIZATION_HEADER = "Authorization";
    public static final String CONTENT_TYPE_HEADER  = "Content-Type";
    public static final String ACCEPT_HEADER        = "Accept";

    // CORS mặc định
    public static final String FRONTEND_ENDPOINT = "http://localhost:4200";

    // Public endpoints chuẩn
    public static final String[] PUBLIC_ENDPOINTS = {
            "/health", "/actuator/**", "/auth/**", "/h2-console/**"
    };

    // Methods
    public static final String GET="GET", POST="POST", PUT="PUT", DELETE="DELETE", PATCH="PATCH", OPTIONS="OPTIONS";

    // Path
    public static final String URL_PATTERN_ALL = "/**";

    private SecurityConstants(){}
}

package org.common.exception;


import lombok.Getter;

@Getter
public class AppException extends RuntimeException {
    private final ErrorCode errorCode;
    public AppException(ErrorCode errorCode) {
        super(errorCode.getMessage());
        this.errorCode = errorCode;
    }
}

package org.common.exception;

import lombok.Getter;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;

import static org.common.constant.ErrorCodeConstant.BAD_REQUEST_STATUS;
import static org.common.constant.ErrorCodeConstant.CONFLICT_STATUS;
import static org.common.constant.ErrorCodeConstant.FORBIDDEN_STATUS;
import static org.common.constant.ErrorCodeConstant.INTERNAL_SERVER_STATUS;
import static org.common.constant.ErrorCodeConstant.NOT_FOUND_STATUS;
import static org.common.constant.ErrorCodeConstant.UNAUTHORIZED_STATUS;
import static org.springframework.http.HttpStatus.BAD_REQUEST;

@Getter
public enum ErrorCode {
    // 500
    UNCATEGORIZED_EXCEPTION(999, INTERNAL_SERVER_STATUS, "Lỗi chưa phân loại", HttpStatus.INTERNAL_SERVER_ERROR),

    // 400
    VALIDATION_FAILED(400, BAD_REQUEST_STATUS, "Dữ liệu không hợp lệ!", org.springframework.http.HttpStatus.BAD_REQUEST),
    INVALID_OTP(400, BAD_REQUEST_STATUS, "OTP không hợp lệ!", BAD_REQUEST),
    OTP_EXPIRED(400, BAD_REQUEST_STATUS, "OTP đã hết hạn!", BAD_REQUEST),
    EMAIL_SEND_FAILED(4008003, BAD_REQUEST_STATUS, "Gửi email thất bại!", BAD_REQUEST),

    // 401
    UNAUTHENTICATED(401, UNAUTHORIZED_STATUS, "Chưa xác thực!", HttpStatus.UNAUTHORIZED),
    INVALID_CREDENTIALS(401, UNAUTHORIZED_STATUS, "Thông tin đăng nhập không hợp lệ!", HttpStatus.UNAUTHORIZED),
    INVALID_TOKEN(401, UNAUTHORIZED_STATUS, "Token không hợp lệ!", HttpStatus.UNAUTHORIZED),
    TOKEN_REVOKED(401, UNAUTHORIZED_STATUS, "Token đã bị thu hồi!", HttpStatus.UNAUTHORIZED),

    // 403
    UNAUTHORIZED(403, FORBIDDEN_STATUS, "Bạn không có quyền truy cập!", HttpStatus.FORBIDDEN),

    // 404
    USER_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy user", HttpStatus.NOT_FOUND),
    ROLE_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy vai trò", HttpStatus.NOT_FOUND),
    ADDRESS_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy địa chỉ", HttpStatus.NOT_FOUND),
    EMAIL_NOT_FOUND(404, NOT_FOUND_STATUS, "Không tìm thấy email", HttpStatus.NOT_FOUND),
    // 409
    USER_ALREADY_EXISTS(409, CONFLICT_STATUS, "Người dùng đã tồn tại!", HttpStatus.CONFLICT),
    EMAIL_ALREADY_EXISTS(409, CONFLICT_STATUS, "Email đã tồn tại!", HttpStatus.CONFLICT),
    PASSWORD_ALREADY_EXISTS(409, CONFLICT_STATUS, "Mật khẩu đã tồn tại!", HttpStatus.CONFLICT),
    ROLE_ALREADY_EXISTS(409, CONFLICT_STATUS, "Vai trò đã tồn tại!", HttpStatus.CONFLICT),

    // 500
    FAILED_GENERATE_TOKEN(500, INTERNAL_SERVER_STATUS, "Lỗi tạo JWT token!", HttpStatus.INTERNAL_SERVER_ERROR),
    FAILED_VALIDATE_TOKEN(500, INTERNAL_SERVER_STATUS, "Lỗi xác thực token!", HttpStatus.INTERNAL_SERVER_ERROR),
    MAIL_DELIVERY_FAILED(500, INTERNAL_SERVER_STATUS, "Gửi email thất bại!", HttpStatus.INTERNAL_SERVER_ERROR);

    private final int code;
    private final String status;
    private final String message;
    private final HttpStatusCode statusCode;

    ErrorCode(int code, String status, String message, HttpStatusCode statusCode) {
        this.code = code;
        this.status = status;
        this.message = message;
        this.statusCode = statusCode;
    }

    public int http() { return statusCode.value(); }
}


package org.common.exception;

import io.grpc.Status;
import io.grpc.StatusRuntimeException;
import jakarta.validation.ConstraintViolationException;
import lombok.extern.slf4j.Slf4j;
import net.devh.boot.grpc.server.advice.GrpcAdvice;
import net.devh.boot.grpc.server.advice.GrpcExceptionHandler;
import org.springframework.security.access.AccessDeniedException;

@Slf4j
@GrpcAdvice
public class GrpcServerExceptionAdvice {

    @GrpcExceptionHandler(AppException.class)
    public StatusRuntimeException handleAppException(AppException appException) {
        return GrpcStatusMapper.ex(appException.getErrorCode());
    }

    @GrpcExceptionHandler(AccessDeniedException.class)
    public StatusRuntimeException handleDeniedException(
            AccessDeniedException accessDeniedException) {
        return GrpcStatusMapper.ex(ErrorCode.UNAUTHORIZED);
    }

    @GrpcExceptionHandler(ConstraintViolationException.class)
    public StatusRuntimeException handleBadException(
            ConstraintViolationException constraintViolationException) {
        return GrpcStatusMapper.ex(ErrorCode.VALIDATION_FAILED);
    }

    @GrpcExceptionHandler(Throwable.class)
    public StatusRuntimeException handleAnyException(
            Throwable throwable) {
        return Status.INTERNAL.withDescription(ErrorCode.UNCATEGORIZED_EXCEPTION.name())
                .asRuntimeException();
    }
}

package org.common.exception;

import com.google.protobuf.Empty;
import io.grpc.Status;
import io.grpc.StatusRuntimeException;
import io.grpc.stub.StreamObserver;
import lombok.experimental.UtilityClass;

@UtilityClass
public class GrpcStatusMapper {

    public Status statusFor(
            ErrorCode errorCode) {
        return switch (errorCode) {
            case UNAUTHENTICATED, INVALID_CREDENTIALS, INVALID_TOKEN,
                 TOKEN_REVOKED -> Status.UNAUTHENTICATED;
            case UNAUTHORIZED -> Status.PERMISSION_DENIED;
            case USER_NOT_FOUND, EMAIL_NOT_FOUND -> Status.NOT_FOUND;
            case USER_ALREADY_EXISTS, EMAIL_ALREADY_EXISTS,
                 PASSWORD_ALREADY_EXISTS -> Status.ALREADY_EXISTS;
            case FAILED_VALIDATE_TOKEN, INVALID_OTP, VALIDATION_FAILED,
                 OTP_EXPIRED, EMAIL_SEND_FAILED -> Status.INVALID_ARGUMENT;
            default -> Status.INTERNAL;
        };
    }

    public StatusRuntimeException ex(
            ErrorCode errorCode) {
        return statusFor(errorCode).withDescription(errorCode.name())
                .asRuntimeException();
    }

    public <T> void fail(
            StreamObserver<T> streamObserver,
            ErrorCode errorCode) {
        streamObserver.onError(ex(errorCode));
    }

    public void ok(
            StreamObserver<Empty> streamObserver) {
        streamObserver.onNext(Empty.getDefaultInstance());
        streamObserver.onCompleted();
    }

    public static <T> void ok(StreamObserver<? super T> streamObserver, T payload) {
        streamObserver.onNext(payload);
        streamObserver.onCompleted();
    }
}


package org.common.http;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;

import java.time.Instant;
import java.util.List;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = lombok.AccessLevel.PRIVATE)
public class Envelope<T> {

    @Builder.Default
    int status = 200;

    String error;

    @Builder.Default
    String msg = "OK";

    @Builder.Default
    Instant currentTime = Instant.now();

    T data;

    /* Helpers */
    public static <T> Envelope<T> ok(T data){
        return Envelope.<T>builder()
                .status(200)
                .error(null)
                .msg("OK")
                .currentTime(Instant.now())
                .data(data)
                .build();
    }
    public static <T> Envelope<T> err(
            int status,
            String code,
            String message,
            T data){
        return Envelope.<T>builder()
                .status(status)
                .error(code)
                .msg(message)
                .currentTime(Instant.now())
                .data(data)
                .build();
    }

    public static <TDoc> Envelope<Page<TDoc>> okPage(
            int page, int size,
            long total, int totalPages,
            List<TDoc> docs){
        return Envelope.ok(Page.<TDoc>builder()
                .page(page)
                .size(size)
                .total(total)
                .totalPages(totalPages)
                .docs(docs)
                .build()
        );
    }

    @Getter @Setter @Builder
    @NoArgsConstructor @AllArgsConstructor
    @FieldDefaults(level = lombok.AccessLevel.PRIVATE)
    public static class Page<TDoc>{
        int page;
        int size;
        long total;
        int totalPages;

        @Builder.Default
        List<TDoc> docs = List.of();
    }
}


package org.common.http;

import lombok.AccessLevel;
import lombok.Builder;
import lombok.Data;
import lombok.experimental.FieldDefaults;

import java.util.Collections;
import java.util.List;

@Data
@Builder(toBuilder = true)
@FieldDefaults(level = AccessLevel.PRIVATE)
public class PagePayload<T> {
    int page;
    int size;
    long total;
    int totalPages;

    @Builder.Default
    List<T> data = Collections.emptyList();
}

auth.proto
syntax = "proto3";
package core.v1;

option java_multiple_files = true;
option java_package = "com.common.grpc";
option java_outer_classname = "AuthProto";

// Register
message RegisterRequest {
  string username = 1;
  string email = 2;
  string password = 3;
}

message RegisterResponse {}

// Login
message LoginRequest {
  string username = 1;
  string email = 2;
  string password = 3;
}

message LoginResponse {
  string access_token = 1;
  string refresh_token = 2;
  string access_expiry = 3;
  string refresh_expiry = 4;
}

// Introspect
message IntrospectRequest {
  string token = 1;
}

message IntrospectResponse {
  bool valid = 1;
  string user_id = 2;
}

// Refresh
message RefreshRequest {
  string token = 1;
}

message RefreshResponse {
  string access_token = 1;
  string refresh_token = 2;
  string access_expiry = 3;
  string refresh_expiry = 4;
}

// Logout
message LogoutRequest {
  string token = 1;
}

message LogoutResponse {}

service AuthService {
  rpc Register(RegisterRequest) returns (RegisterResponse);
  rpc Login(LoginRequest) returns (LoginResponse);
  rpc Refresh(RefreshRequest) returns (RefreshResponse);
  rpc Introspect(IntrospectRequest) returns (IntrospectResponse);
  rpc Logout(LogoutRequest) returns (LogoutResponse);
}

otp.proto
syntax = "proto3";
package core.v1;

option java_multiple_files = true;
option java_package = "com.common.grpc";
option java_outer_classname = "OtpProto";

import "google/protobuf/empty.proto";

message UserOtpRequest {
  string email = 1;
}

message OtpResponse {
  string email = 1;
  string message = 2;
}

message OtpVerificationRequest {
  string email = 1;
  string otpCode = 2;
}

message ResetPasswordRequest {
  string email = 1;
  string otp = 2;
  string newPassword = 3;
}

service OtpService {
  // OTP
  rpc SendOtp(UserOtpRequest) returns (OtpResponse);
  rpc VerifyOtp(OtpVerificationRequest) returns (google.protobuf.Empty);

  // Password
  rpc RequestResetPassword(UserOtpRequest) returns (OtpResponse);
  rpc VerifyOtpPassword(OtpVerificationRequest) returns (google.protobuf.Empty);
  rpc ResetPassword(ResetPasswordRequest) returns (google.protobuf.Empty);
}

core-service
package com.core.controller;

import com.common.grpc.AddressCreateRequest;
import com.common.grpc.AddressServiceGrpc;
import com.common.grpc.AddressUpdateRequest;
import com.common.grpc.AddressView;
import com.common.grpc.IdRequest;
import com.common.grpc.PageAddress;
import com.common.grpc.UserIdRequest;
import com.core.dto.request.user.AddressCreateRequestDto;
import com.core.dto.request.user.AddressUpdateRequestDto;
import com.core.dto.response.user.AddressResponseDto;
import com.core.service.IAddressService;
import com.google.protobuf.Empty;
import io.grpc.stub.StreamObserver;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.extern.slf4j.Slf4j;
import net.devh.boot.grpc.server.service.GrpcService;
import org.common.exception.GrpcStatusMapper;
import org.common.http.Envelope;

@GrpcService
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@Slf4j
public class AddressGrpcServer extends AddressServiceGrpc.AddressServiceImplBase {
    private final IAddressService addressService;

    @Override
    public void create(
            AddressCreateRequest r,
            StreamObserver<Empty> responseObserver){
        AddressCreateRequestDto dto = AddressCreateRequestDto.builder()
                .contactName(r.getContactName())
                .contactPhone(r.getContactPhone())
                .addressLine1(r.getAddressLine1())
                .addressLine2(r.getAddressLine2())
                .district(r.getDistrict())
                .city(r.getCity())
                .country(r.getCountry())
                .postalCode(r.getPostalCode())
                .build();
        addressService.create(dto);

        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void update(
            AddressUpdateRequest r,
            StreamObserver<Empty> responseObserver){
        AddressUpdateRequestDto dto = AddressUpdateRequestDto.builder()
                .contactName(r.getContactName())
                .contactPhone(r.getContactPhone())
                .addressLine1(r.getAddressLine1())
                .addressLine2(r.getAddressLine2())
                .district(r.getDistrict())
                .city(r.getCity())
                .country(r.getCountry())
                .postalCode(r.getPostalCode())
                .build();
        addressService.update(r.getId(), dto);
        GrpcStatusMapper.ok(responseObserver);
    }


    @Override
    public void softDelete(
            IdRequest r, StreamObserver<Empty> responseObserver){
        addressService.softDelete(r.getId());
        GrpcStatusMapper.ok(responseObserver);
    }
    @Override
    public void setDefaultShipping(
            IdRequest r,
            StreamObserver<Empty> responseObserver){
        addressService.setDefaultShipping(r.getId());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void setDefaultBilling(
            IdRequest r,
            StreamObserver<Empty> responseObserver){
        addressService.setDefaultBilling(r.getId());
        GrpcStatusMapper.ok(responseObserver);
    }
    @Override
    public void listByUser(
            UserIdRequest r,
            StreamObserver<PageAddress> responseObserver){
        Envelope.Page<AddressResponseDto> page = addressService.listByUser(
                r.getUserId(),
                r.getPage(),
                r.getSize()
        );

        PageAddress.Builder b = PageAddress.newBuilder()
                .setPage(page.getPage())
                .setSize(page.getSize())
                .setTotal(page.getTotal())
                .setTotalPages(page.getTotalPages());

        page.getDocs().forEach(v -> b.addDocs(AddressView.newBuilder()
                .setId(v.getId())
                .setContactName(v.getContactName())
                .setContactPhone(v.getContactPhone())
                .setAddressLine1(v.getAddressLine1())
                .setAddressLine2(v.getAddressLine2() == null
                        ? ""
                        : v.getAddressLine2())
                .setDistrict(v.getDistrict())
                .setCity(v.getCity()).setCountry(v.getCountry() == null
                        ? ""
                        : v.getCountry())
                .setPostalCode(v.getPostalCode()==null
                        ? ""
                        : v.getPostalCode())
                .setIsDefaultShipping(Boolean.TRUE.equals(v.getIsDefaultShipping()))
                .setIsDefaultBilling(Boolean.TRUE.equals(v.getIsDefaultBilling()))
                .build()));

        GrpcStatusMapper.ok(responseObserver, b.build());
    }
}

package com.core.controller;

import com.common.grpc.AssignRoleRequest;
import com.common.grpc.CreateRoleRequest;
import com.common.grpc.MeLite;
import com.common.grpc.PageRequest;
import com.common.grpc.PageRole;
import com.common.grpc.PageUser;
import com.common.grpc.RoleName;
import com.common.grpc.RoleResponse;
import com.common.grpc.RoleServiceGrpc;
import com.core.dto.request.user.AssignRoleRequestDto;
import com.core.dto.request.user.CreateRoleRequestDto;
import com.core.dto.response.user.MeResponseDto;
import com.core.dto.response.user.RoleResponseDto;
import com.core.service.IRoleService;
import com.google.protobuf.Empty;
import io.grpc.stub.StreamObserver;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.extern.slf4j.Slf4j;
import net.devh.boot.grpc.server.service.GrpcService;
import org.common.exception.GrpcStatusMapper;
import org.common.http.Envelope;

@GrpcService
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@Slf4j
public class RoleGrpcServer extends RoleServiceGrpc.RoleServiceImplBase {
    private final IRoleService roleService;

    @Override
    public void create(
            CreateRoleRequest r,
            StreamObserver<Empty> responseObserver){
        roleService.create(CreateRoleRequestDto.builder()
                .name(r.getName())
                .build());
        GrpcStatusMapper.ok(responseObserver);
    }
    @Override
    public void softDelete(
            RoleName r,
            StreamObserver<Empty> responseObserver){
        roleService.softDelete(r.getName());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override public void restore(
            RoleName r,
            StreamObserver<Empty> responseObserver){
        roleService.restore(r.getName());
        GrpcStatusMapper.ok(responseObserver);
    }
    @Override
    public void assign(
            AssignRoleRequest r,
            StreamObserver<Empty> responseObserver){
        AssignRoleRequestDto dto = AssignRoleRequestDto.builder()
                .userId(r.getUserId())
                .roleName(r.getRoleName())
                .build();
        roleService.assign(dto);
        GrpcStatusMapper.ok(responseObserver);
    }
    @Override
    public void remove(
            AssignRoleRequest r,
            StreamObserver<Empty> responseObserver){
        AssignRoleRequestDto dto = AssignRoleRequestDto.builder()
                .userId(r.getUserId())
                .roleName(r.getRoleName())
                .build();
        roleService.remove(dto);
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void listUserRoles(
            AssignRoleRequest r,
            StreamObserver<PageRole> responseObserver) {
        Envelope.Page<RoleResponseDto> page = roleService.listUserRoles(
                r.getUserId(), 0, Integer.MAX_VALUE);
        PageRole.Builder builder = PageRole.newBuilder()
                .setPage(page.getPage())
                .setSize(page.getSize())
                .setTotal(page.getTotal())
                .setTotalPages(page.getTotalPages());

        page.getDocs().forEach(rr -> builder.addDocs(
                RoleResponse.newBuilder()
                        .setName(rr.getName())
                        .build()));

        GrpcStatusMapper.ok(responseObserver, builder.build());
    }

    @Override
    public void listUsersByRole(
            RoleName r,
            StreamObserver<PageUser> responseObserver) {
        Envelope.Page<MeResponseDto> page = roleService.listUsersByRole(
                r.getName(),0, Integer.MAX_VALUE);
        PageUser.Builder b = PageUser.newBuilder()
                .setPage(page.getPage())
                .setSize(page.getSize())
                .setTotal(page.getTotal())
                .setTotalPages(page.getTotalPages());
        page.getDocs().forEach(m -> b.addDocs(
                MeLite.newBuilder().setId(m.getId())
                        .setUsername(m.getUsername())
                        .setEmail(m.getEmail())
                        .setFullName(m.getFullName() == null
                                ? ""
                                : m.getFullName())
                        .build()));

        GrpcStatusMapper.ok(responseObserver, b.build());
    }

    @Override
    public void listAll(
            PageRequest r,
            StreamObserver<PageRole> responseObserver) {
        Envelope.Page<RoleResponseDto> page = roleService.listAllRoles(
                r.getPage(), r.getSize());
        PageRole.Builder b = PageRole.newBuilder()
                .setPage(page.getPage())
                .setSize(page.getSize())
                .setTotal(page.getTotal())
                .setTotalPages(page.getTotalPages());
        page.getDocs().forEach(rr -> b.addDocs(RoleResponse.newBuilder()
                .setName(rr.getName())
                .build()));

        GrpcStatusMapper.ok(responseObserver, b.build());
    }
}

package com.core.controller;

import com.common.grpc.MeResponse;
import com.common.grpc.ToggleActiveRequest;
import com.common.grpc.UpdateProfileRequest;
import com.common.grpc.UserServiceGrpc;
import com.core.dto.request.user.UpdateProfileRequestDto;
import com.core.dto.response.user.MeResponseDto;
import com.core.service.IUserService;
import com.google.protobuf.Empty;
import io.grpc.stub.StreamObserver;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.extern.slf4j.Slf4j;
import net.devh.boot.grpc.server.service.GrpcService;
import org.common.exception.GrpcStatusMapper;

@GrpcService
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@Slf4j
public class UserGrpcServer extends UserServiceGrpc.UserServiceImplBase {
    private final IUserService userService;

    @Override
    public void toggleActive(
            ToggleActiveRequest request,
            StreamObserver<Empty> responseObserver) {
        userService.toggleActive(
                request.getUserId(),
                request.getActive());

        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void getMe(
            Empty request,
            StreamObserver<MeResponse> responseObserver) {
        MeResponseDto me = userService.getMe();
        GrpcStatusMapper.ok(responseObserver, MeResponse.newBuilder()
                .setId(me.getId())
                .setUsername(me.getUsername())
                .setEmail(me.getEmail())
                .setFullName(me.getFullName() == null
                        ? ""
                        : me.getFullName())
                .setPhoneNumber(me.getPhoneNumber() == null
                        ? ""
                        : me.getPhoneNumber())
                .setIsActive(Boolean.TRUE.equals(me.getIsActive()))
                .setIsVerified(Boolean.TRUE.equals(me.getIsVerified()))
                .build());
    }

    @Override
    public void updateProfile(
            UpdateProfileRequest request,
            StreamObserver<Empty> responseObserver) {
        userService.updateProfile(UpdateProfileRequestDto.builder()
                .fullName(request.getFullName())
                .phoneNumber(request.getPhoneNumber())
                .build());
        GrpcStatusMapper.ok(responseObserver);
    }
}


package com.core.entity;

import com.core.entity.audit.AuditMetadata;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;
import org.hibernate.annotations.SQLDelete;
import org.hibernate.annotations.Where;


@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(
        name = "addresses",
        indexes = {
                @Index(name = "idx_addresses_user", columnList = "user_id"),
                @Index(name = "idx_addresses_def_ship", columnList = "is_default_shipping"),
                @Index(name = "idx_addresses_def_bill", columnList = "is_default_billing")
        })
@SQLDelete(sql = "UPDATE addresses SET deleted_by = ?, deleted_at = now() WHERE id = ?")
@Where(clause = "deleted_at IS NULL")
public class Address extends AuditMetadata {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(length = 36)
    String id;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "user_id", nullable = false)
    User user;

    @Column(name = "contact_name", length = 100, nullable = false)
    String contactName;

    @Column(name = "contact_phone", length = 15, nullable = false)
    String contactPhone;

    @Column(name = "address_line1", length = 255, nullable = false)
    String addressLine1;

    @Column(name = "address_line2", length = 255)
    String addressLine2;

    @Column(length = 100, nullable = false)
    String district;

    @Column(length = 100, nullable = false)
    String city;

    @Column(length = 50, nullable = false)
    String country = "Vietnam";

    @Column(name = "postal_code", length = 10)
    String postalCode;

    @Column(name = "is_default_shipping", nullable = false)
    Boolean isDefaultShipping = false;

    @Column(name = "is_default_billing", nullable = false)
    Boolean isDefaultBilling = false;
}

package com.core.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;

import java.time.Instant;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(name = "tokens")
public class InvalidatedToken {

    @Id
    String id;

    Instant expiryTime;
}

package com.core.entity;

import com.core.entity.audit.AuditMetadata;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;
import org.hibernate.annotations.SQLDelete;
import org.hibernate.annotations.Where;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(name = "roles")
@SQLDelete(sql = "UPDATE roles SET deleted_by = ?, deleted_at = now() WHERE name = ?")
@Where(clause = "deleted_at IS NULL")
public class Role extends AuditMetadata {

    @Id
    @Column(name = "name", length = 50)
    String name;
}

package com.core.entity;

import com.core.entity.audit.AuditMetadata;
import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;
import org.hibernate.annotations.SQLDelete;
import org.hibernate.annotations.Where;

import java.util.HashSet;
import java.util.Set;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(
        name = "users",
        indexes = {
                @Index(name = "idx_users_username", columnList = "user_name"),
                @Index(name = "idx_users_email", columnList = "email"),
                @Index(name = "idx_users_phone", columnList = "phone_number")
        })
@SQLDelete(sql = "UPDATE users SET deleted_by = ?, deleted_at = now() WHERE id = ?")
@Where(clause = "deleted_at IS NULL")
public class User extends AuditMetadata {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(length = 36)
    String id;

    @Column(name = "user_name", length = 100, nullable = false, unique = true)
    String username;

    @Column(length = 150, nullable = false, unique = true)
    String email;

    @Column(name = "phone_number", length = 15, unique = true)
    String phoneNumber;

    @Column(name = "password_hash", nullable = false, length = 255)
    String passwordHash;

    @Column(name = "full_name", length = 100)
    String fullName;

    @Column(name = "is_active", nullable = false)
    Boolean isActive = true;

    @Column(name = "is_verified", nullable = false)
    Boolean isVerified = false;

    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
            name = "user_roles",
            joinColumns = @JoinColumn(name = "user_id", referencedColumnName = "id"),
            inverseJoinColumns = @JoinColumn(name = "role_name", referencedColumnName = "name")
    )
    Set<Role> roles = new HashSet<>();

    @OneToMany(
            mappedBy = "user",
            cascade = CascadeType.ALL,
            orphanRemoval = true
    )
    Set<Address> addresses = new HashSet<>();
}

package com.core.entity.otp;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;

import java.time.Instant;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(name = "otp_verification")
public class OtpVerification {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    String id;

    @Column(nullable = false, unique = true)
    String email;

    @Column(nullable = false)
    String otpCode;

    @Column(nullable = false)
    Instant expiryTime;

    @Column(nullable = false)
    boolean verified;
}

package com.core.entity.otp;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.FieldDefaults;

import java.time.Instant;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Entity
@Table(name = "password_reset_tokens")
public class PasswordResetToken {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    String id;

    @Column(nullable = false, unique = true)
    String email;

    @Column(nullable = false)
    String otpCode;

    @Column(nullable = false)
    Instant expiryTime;

    @Column(nullable = false)
    boolean consumed;
}

package com.core.entity.audit;

public interface SoftDeletable {
    void markDeleted(String by);

    boolean isDeleted();

    String getDeletedBy();
}

package com.core.entity.audit;

import jakarta.persistence.Column;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;
import lombok.experimental.FieldDefaults;
import org.springframework.data.annotation.CreatedBy;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedBy;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;

@Getter
@Setter
@ToString
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
@FieldDefaults(level = AccessLevel.PROTECTED)
public class AuditMetadata implements SoftDeletable {
    /* ---- create ---- */
    @CreatedBy
    @Column(name = "created_by")
    String createdBy;

    @CreatedDate
    @Column(name = "created_at")
    Instant createdAt;

    /* ---- update ---- */
    @LastModifiedBy
    @Column(name = "updated_by")
    String updatedBy;

    @LastModifiedDate
    @Column(name = "updated_at")
    Instant updatedAt;

    /* ---- soft-delete ---- */
    @Column(name = "deleted_by")
    String deletedBy;

    @Column(name = "deleted_at")
    Instant deletedAt;

    @Override
    public void markDeleted(String by) {
        this.deletedBy = by;
        this.deletedAt = Instant.now();
    }

    @Override
    public boolean isDeleted() {
        return deletedAt != null;
    }
}

package com.core.dto.request.authentication;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.FieldDefaults;

@Data
@NoArgsConstructor
@AllArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Builder
public class AuthenticationRequestDto {

    @Size(min = 4, message = "username không hợp lệ, phải > 4 ký tự")
    String username;

    @Email(message = "email không hợp lệ")
    String email;

    @NotBlank(message = "password bắt buộc")
    @Size(min = 8, message = "password >= 8")
    String password;
}


package com.core.dto.request.authentication;

import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.FieldDefaults;

@Data
@NoArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@Builder
@AllArgsConstructor
public class IntrospectRequestDto {

    String token;
}


package com.core.dto.request.authentication;

import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.FieldDefaults;

@Data
@NoArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@AllArgsConstructor
@Builder
public class RefreshRequestDto {

    String token;
}


package com.core.dto.request.authentication;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.FieldDefaults;

@Schema(name = "UserCreationRequest",
        description = "Schema user information"
)
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@FieldDefaults(level = AccessLevel.PRIVATE)
public class UserCreationRequestDto {

    @NotBlank
    @Size(min = 4, message = "username không hợp lệ, phải > 4 ký tự")
    String username;

    @Email(message = "email không hợp lệ")
    String email;

    @NotBlank(message = "password bắt buộc")
    @Size(min = 8, message = "password >= 8")
    String password;
}

package com.core.dto.request.otp;

import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.FieldDefaults;

@Data
@NoArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@AllArgsConstructor
@Builder
public class OtpSendRequestDto {
    String email;
    String otpCode;
}

package com.core.dto.request.otp;

import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.FieldDefaults;

@Data
@NoArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@AllArgsConstructor
@Builder
public class OtpVerificationRequestDto {
    String email;
    String otpCode;
}

package com.core.dto.request.otp;

import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.FieldDefaults;

@Data
@NoArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@AllArgsConstructor
@Builder
public class ResetPasswordRequestDto {
    String email;
    String otp;
    String newPassword;
}


package com.core.dto.request.otp;

import jakarta.validation.constraints.Email;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.FieldDefaults;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@FieldDefaults(level = AccessLevel.PRIVATE)
public class UserOtpRequestDto {

    @Email(message = "email không hợp lệ")
    String email;
}




package com.core.dto.request.otp;

import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.FieldDefaults;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@FieldDefaults(level = AccessLevel.PRIVATE)
public class VerifyPasswordResetRequestDto {
    String email;
    String otp;
}

package com.core.dto.response.authentication;

import lombok.AccessLevel;
import lombok.Builder;
import lombok.Data;
import lombok.experimental.FieldDefaults;

import java.time.Instant;

@Data
@Builder
@FieldDefaults(level = AccessLevel.PRIVATE)
public class AuthenticationResponseDto {

    String accessToken;
    String refreshToken;
    Instant accessExpiry;
    Instant refreshExpiry;
}


package com.core.dto.response.authentication;

import lombok.AccessLevel;
import lombok.Builder;
import lombok.Data;
import lombok.experimental.FieldDefaults;

@Data
@Builder
@FieldDefaults(level = AccessLevel.PRIVATE)
public class IntrospectResponseDto {

    boolean valid;
    String userId;
}


package com.core.dto.response.otp;

import lombok.AccessLevel;
import lombok.Builder;
import lombok.Data;
import lombok.experimental.FieldDefaults;

@Data
@Builder
@FieldDefaults(level = AccessLevel.PRIVATE)
public class OtpResponseDto {
    String email;
    String message;
}

package com.core.mapper.user;

import com.core.dto.request.authentication.UserCreationRequestDto;
import com.core.entity.User;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.NullValuePropertyMappingStrategy;
import org.mapstruct.ReportingPolicy;

@Mapper(
        componentModel = "spring",
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE
)
public interface UserMapper {

    @Mapping(source = "password", target = "passwordHash")
    User toUserFromUserCreationRequestDto(
            UserCreationRequestDto userCreationRequestDto);
}



package com.core.repository.otp;

import com.core.entity.otp.OtpVerification;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface OtpVerificationRepository
        extends JpaRepository<OtpVerification, String> {

    Optional<OtpVerification> findByEmail(String email);
}

package com.core.repository.otp;

import com.core.entity.otp.PasswordResetToken;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface PasswordResetTokenRepository
        extends JpaRepository<PasswordResetToken, String> {

    Optional<PasswordResetToken> findByEmail(String email);
}

package com.core.repository.user;

import com.core.entity.Address;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface AddressRepository extends JpaRepository<Address, String> {
    @Query("""
            select a from Address a
            where a.user.id = :userId and a.deletedAt is null
            order by a.createdAt desc""")
    List<Address> findByUserId(@Param("userId") String userId);

    @Modifying
    @Query("""
            update Address a
            set a.isDefaultShipping = false
            where a.user.id = :userId and a.deletedAt is null""")
    void resetDefaultShipping(@Param("userId") String userId);

    @Modifying
    @Query("""
            update Address a
            set a.isDefaultBilling = false
            where a.user.id = :userId and a.deletedAt is null""")
    void resetDefaultBilling(@Param("userId") String userId);
}

package com.core.repository;

import com.core.entity.InvalidatedToken;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface InvalidatedTokenRepository extends
        JpaRepository<InvalidatedToken, String> {
}

package com.core.repository.user;

import com.core.entity.Role;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface RoleRepository
        extends JpaRepository<Role, String> {
}
package com.core.repository;

import com.core.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository
        extends JpaRepository<User, String> {

    @Query("""
        select u from User u
        left join fetch u.roles r
        where u.username = :username or u.email = :email
    """)
    Optional<User> findByUsernameOrEmail(
            @Param("username") String username,
            @Param("email") String email);

    boolean existsByEmail(String email);

    boolean existsByUsername(String username);

    Optional<User> findByUsername(String username);
    Optional<User> findByEmail(String email);
}

package com.core.service.impl;


import com.core.dto.request.user.AddressCreateRequestDto;
import com.core.dto.request.user.AddressUpdateRequestDto;
import com.core.dto.response.user.AddressResponseDto;
import com.core.entity.Address;
import com.core.entity.User;
import com.core.helper.AuthenticationHelper;
import com.core.helper.UserHelper;
import com.core.mapper.user.AddressMapper;
import com.core.repository.user.AddressRepository;
import com.core.service.IAddressService;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.extern.slf4j.Slf4j;
import org.common.exception.AppException;
import org.common.exception.ErrorCode;
import org.common.http.Envelope;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@Slf4j
public class AddressServiceImpl implements IAddressService {
    AddressRepository addressRepository;
    AddressMapper addressMapper;
    UserHelper userhelper;

    @Override
    @Transactional
    public void create(
            AddressCreateRequestDto request) {
        String me = AuthenticationHelper.getMyUserId();
        User u = userhelper.getUserById(me);
        Address a = addressMapper.toAddressFromAddressCreateRequestDto(request);
        a.setUser(u);
        addressRepository.save(a);
    }

    @Override @Transactional
    public void update(
            String addressId,
            AddressUpdateRequestDto request) {
        Address a = addressRepository.findById(addressId)
                .orElseThrow(() -> new AppException(ErrorCode.ADDRESS_NOT_FOUND));
        mustOwn(a);
        addressMapper.patchAddressFromAddressUpdateRequestDto(a, request);
        addressRepository.save(a);
    }

    @Override
    @Transactional
    public void softDelete(String addressId) {
        Address a = addressRepository.findById(addressId)
                .orElseThrow(() -> new AppException(ErrorCode.ADDRESS_NOT_FOUND));
        mustOwn(a);
        a.markDeleted(AuthenticationHelper.getMyUserId());
        addressRepository.save(a);
    }

    @Override
    @Transactional
    public void setDefaultShipping(String addressId) {
        Address a = addressRepository.findById(addressId)
                .orElseThrow(() -> new AppException(ErrorCode.ADDRESS_NOT_FOUND));
        mustOwn(a);
        addressRepository.resetDefaultShipping(a.getUser().getId());
        a.setIsDefaultShipping(true);
        addressRepository.save(a);
    }

    @Override
    @Transactional
    public void setDefaultBilling(String addressId) {
        Address a = addressRepository.findById(addressId)
                .orElseThrow(() -> new AppException(ErrorCode.ADDRESS_NOT_FOUND));
        mustOwn(a);
        addressRepository.resetDefaultBilling(a.getUser().getId());
        a.setIsDefaultBilling(true);
        addressRepository.save(a);
    }

    @Override
    @Transactional(readOnly = true)
    public Envelope.Page<AddressResponseDto> listByUser(
            String userId,
            int page, int size) {
        String me = AuthenticationHelper.getMyUserId();
        if (!me.equals(userId)) AuthenticationHelper.requireAdmin();

        List<AddressResponseDto> docs = addressRepository.findByUserId(userId)
                .stream()
                .map(addressMapper::toAddressResponseDtoFromAddress)
                .toList();
        int total = docs.size();
        int from = Math.min(page*size, total);
        int to = Math.min(from+size, total);
        List<AddressResponseDto> slice = docs.subList(from, to);
        int totalPages = (int) Math.max(1, Math.ceil(total/(double)size));

        return Envelope.Page.<AddressResponseDto>builder()
                .page(page)
                .size(size)
                .total(total)
                .totalPages(totalPages)
                .docs(slice)
                .build();
    }

    private void mustOwn(Address a){
        String me = AuthenticationHelper.getMyUserId();
        if (a.getUser()==null || !a.getUser().getId().equals(me)) {
            throw new AppException(ErrorCode.UNAUTHORIZED);
        }
    }
}

package com.core.service.impl;

import com.core.dto.request.user.AssignRoleRequestDto;
import com.core.dto.request.user.CreateRoleRequestDto;
import com.core.dto.response.user.MeResponseDto;
import com.core.dto.response.user.RoleResponseDto;
import com.core.entity.Role;
import com.core.entity.User;
import com.core.helper.AuthenticationHelper;
import com.core.helper.UserHelper;
import com.core.mapper.user.UserProfileMapper;
import com.core.repository.UserRepository;
import com.core.repository.user.RoleRepository;
import com.core.service.IRoleService;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.extern.slf4j.Slf4j;
import org.common.exception.AppException;
import org.common.exception.ErrorCode;
import org.common.http.Envelope;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@Slf4j
public class RoleServiceImpl implements IRoleService {
    RoleRepository roleRepository;
    UserRepository userRepository;
    UserHelper userHelper;
    UserProfileMapper userProfileMapper;

    @Override
    @Transactional
    public void create(CreateRoleRequestDto request) {
        AuthenticationHelper.requireAdmin();
        if (roleRepository.existsById(request.getName())){
            throw new AppException(ErrorCode.ROLE_ALREADY_EXISTS);
        }
        Role r = Role.builder()
                .name(request.getName())
                .build();
        roleRepository.save(r);
    }

    @Override
    @Transactional
    public void softDelete(
            String roleName) {
        AuthenticationHelper.requireAdmin();
        Role r = roleRepository.findById(roleName)
                .orElseThrow(() -> new AppException(ErrorCode.ROLE_NOT_FOUND));
        r.markDeleted(AuthenticationHelper.getMyUserId());
        roleRepository.save(r);
    }

    @Override
    @Transactional
    public void restore(String roleName) {
        AuthenticationHelper.requireAdmin();
        Role r = roleRepository.findById(roleName)
                .orElseThrow(() -> new AppException(ErrorCode.ROLE_NOT_FOUND));
        r.setDeletedAt(null);
        r.setDeletedBy(null);
        roleRepository.save(r);
    }

    @Override @Transactional
    public void assign(AssignRoleRequestDto request) {
        AuthenticationHelper.requireAdmin();
        User u = userHelper.getUserById(request.getUserId());
        Role r = roleRepository.findById(request.getRoleName())
                .orElseThrow(() -> new AppException(ErrorCode.ROLE_NOT_FOUND));
        u.getRoles().add(r);
        userRepository.save(u);
    }

    @Override
    @Transactional
    public void remove(AssignRoleRequestDto request) {
        AuthenticationHelper.requireAdmin();
        User u = userHelper.getUserById(request.getUserId());
        u.getRoles().removeIf(role -> role.getName()
                .equals(request.getRoleName()));
        userRepository.save(u);
    }

    @Override
    @Transactional(readOnly = true)
    public Envelope.Page<RoleResponseDto> listUserRoles(
            String userId,
            int page, int size) {
        User u = userHelper.getUserById(userId);
        List<RoleResponseDto> docs = u.getRoles().stream()
                .map(r -> RoleResponseDto.builder()
                        .name(r.getName())
                        .build())
                .toList();
        return Envelope.Page.<RoleResponseDto>builder()
                .page(page)
                .size(size)
                .total(docs.size())
                .totalPages(1)
                .docs(docs)
                .build();
    }

    @Override
    @Transactional(readOnly = true)
    public Envelope.Page<MeResponseDto> listUsersByRole(
            String roleName,
            int page, int size) {
        Pageable pageable = PageRequest.of(
                page,
                size,
                Sort.by("createdAt").descending()
        );
        Page<User> p = userRepository.findAll(pageable)
                .map(u -> u.getRoles()
                        .stream()
                        .anyMatch(r -> r.getName().equals(roleName))
                        ? u
                        : null);
        List<MeResponseDto> docs = p.getContent()
                .stream()
                .filter(u -> u != null)
                .map(userProfileMapper::toMeResponseDtoFromUser)
                .toList();
        return Envelope.Page.<MeResponseDto>builder()
                .page(page)
                .size(size)
                .total(docs.size())
                .totalPages(p.getTotalPages() == 0
                        ? 1
                        : p.getTotalPages())
                .docs(docs)
                .build();
    }

    @Override
    @Transactional(readOnly = true)
    public Envelope.Page<RoleResponseDto> listAllRoles(
            int page, int size) {
        Pageable pageable = PageRequest.of(page, size);
        Page<Role> p = roleRepository.findAll(pageable);
        List<RoleResponseDto> docs = p.stream()
                .map(r -> RoleResponseDto.builder()
                        .name(r.getName())
                        .build())
                .toList();
        return Envelope.Page.<RoleResponseDto>builder()
                .page(page)
                .size(size)
                .total(p.getTotalElements())
                .totalPages(p.getTotalPages())
                .docs(docs)
                .build();
    }
}

package com.core.service.impl;

import com.core.dto.request.user.UpdateProfileRequestDto;
import com.core.dto.response.user.MeResponseDto;
import com.core.entity.User;
import com.core.helper.AuthenticationHelper;
import com.core.helper.UserHelper;
import com.core.mapper.user.UserProfileMapper;
import com.core.repository.UserRepository;
import com.core.service.IUserService;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.extern.slf4j.Slf4j;
import org.common.exception.AppException;
import org.common.exception.ErrorCode;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@Slf4j
public class UserServiceImpl implements IUserService {
    UserRepository userRepository;
    UserHelper userHelper;
    UserProfileMapper userProfileMapper;

    @Override
    @Transactional
    public void toggleActive(
            String userId,
            boolean active) {
        AuthenticationHelper.requireAdmin();
        User u = userHelper.getUserById(userId);
        u.setIsActive(active);
        userRepository.save(u);
    }

    @Override
    @Transactional(readOnly = true)
    public MeResponseDto getMe() {
        String me = AuthenticationHelper.getMyUserId();
        return userRepository.findById(me)
                .map(userProfileMapper::toMeResponseDtoFromUser)
                .orElseThrow(
                        () -> new AppException(ErrorCode.USER_NOT_FOUND)
                );
    }

    @Override
    @Transactional
    public void updateProfile(
            UpdateProfileRequestDto request) {
        String me = AuthenticationHelper.getMyUserId();
        User u = userHelper.getUserById(me);
        userProfileMapper.patchUserFromUpdateProfileRequestDto(u, request);
        userRepository.save(u);
    }
}

package com.core.service;

import com.core.dto.request.authentication.AuthenticationRequestDto;
import com.core.dto.request.authentication.IntrospectRequestDto;
import com.core.dto.request.authentication.RefreshRequestDto;
import com.core.dto.request.authentication.UserCreationRequestDto;
import com.core.dto.response.authentication.AuthenticationResponseDto;
import com.core.dto.response.authentication.IntrospectResponseDto;
import com.nimbusds.jose.JOSEException;

import java.text.ParseException;

public interface IAuthenticationService {

    /**
     * Đăng ký người dùng mới chưa kích hoạt và gửi mã OTP.
     *
     * @param request thông tin user để đăng ký
     */
    void register(UserCreationRequestDto request);

    /**
     * Đăng nhập bằng username hoặc email, kiểm tra mật khẩu và sinh JWT.
     *
     * @param request thông tin đăng nhập
     * @return AuthenticationResponse chứa accessToken và thông tin user
     * @throws ParseException khi lỗi parse JWT
     */
    AuthenticationResponseDto login(AuthenticationRequestDto request)
            throws ParseException;

    /**
     * Đăng xuất, invalid token bằng cách lưu vào repository.
     *
     * @param token chứa token cần logout
     * @throws ParseException khi lỗi parse JWT
     * @throws JOSEException  khi lỗi verify JWT
     */
    void logout(String token)
            throws ParseException, JOSEException;

    /**
     * Kiểm tra tính hợp lệ của token mà không ném exception.
     *
     * @param request đối tượng chứa token cần kiểm tra
     * @return IntrospectResponse với flag valid
     * @throws JOSEException  khi lỗi ký JWT
     * @throws ParseException khi lỗi parse JWT
     */
    IntrospectResponseDto introspect(IntrospectRequestDto request)
            throws JOSEException, ParseException;

    /**
     * Làm mới access token từ refresh token.
     *
     * @param request chứa token cũ
     * @return AuthenticationResponse chứa token mới và expiryTime
     * @throws ParseException khi lỗi parse JWT
     * @throws JOSEException  khi lỗi verify JWT
     */
    AuthenticationResponseDto refreshToken(RefreshRequestDto request)
            throws ParseException, JOSEException;
}


package com.core.service;

import com.core.dto.request.otp.OtpVerificationRequestDto;
import com.core.dto.request.otp.UserOtpRequestDto;
import com.core.dto.response.otp.OtpResponseDto;

public interface IOtpService {

    OtpResponseDto sendOtp(UserOtpRequestDto userOtpRequestDto);

    void verifyOtp(OtpVerificationRequestDto otpVerificationRequestDto);
}


package com.core.service;

import com.core.dto.request.otp.OtpVerificationRequestDto;
import com.core.dto.request.otp.ResetPasswordRequestDto;
import com.core.dto.request.otp.UserOtpRequestDto;
import com.core.dto.response.otp.OtpResponseDto;

public interface IPasswordResetService {

    OtpResponseDto requestResetPassword(
            UserOtpRequestDto userOtpRequestDto);

    void verifyOtpPassword(
            OtpVerificationRequestDto otpVerificationRequestDto);

    void resetPassword(
            ResetPasswordRequestDto resetPasswordRequestDto);
}

package com.core.service;


import com.core.dto.request.user.UpdateProfileRequestDto;
import com.core.dto.response.user.MeResponseDto;

public interface IUserService {
    void toggleActive(String userId, boolean active);

    MeResponseDto getMe();

    void updateProfile(UpdateProfileRequestDto req);
}

package com.core.service.impl;

import com.core.dto.request.authentication.AuthenticationRequestDto;
import com.core.dto.request.authentication.IntrospectRequestDto;
import com.core.dto.request.authentication.RefreshRequestDto;
import com.core.dto.request.authentication.UserCreationRequestDto;
import com.core.dto.response.authentication.AuthenticationResponseDto;
import com.core.dto.response.authentication.IntrospectResponseDto;
import com.core.entity.InvalidatedToken;
import com.core.entity.Role;
import com.core.entity.User;
import com.core.mapper.user.UserMapper;
import com.core.repository.InvalidatedTokenRepository;
import com.core.repository.UserRepository;
import com.core.repository.user.RoleRepository;
import com.core.service.IAuthenticationService;
import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.JOSEObjectType;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.JWSHeader;
import com.nimbusds.jose.JWSSigner;
import com.nimbusds.jose.crypto.MACSigner;
import com.nimbusds.jose.crypto.MACVerifier;
import com.nimbusds.jwt.JWTClaimsSet;
import com.nimbusds.jwt.SignedJWT;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.experimental.NonFinal;
import lombok.extern.slf4j.Slf4j;
import org.common.exception.AppException;
import org.common.exception.ErrorCode;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.nio.charset.StandardCharsets;
import java.text.ParseException;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Date;
import java.util.HashSet;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@Slf4j
public class AuthenticationServiceImpl
        implements IAuthenticationService {

    UserRepository userRepository;
    RoleRepository roleRepository;
    InvalidatedTokenRepository invalidatedTokenRepository;

    UserMapper userMapper;

    PasswordEncoder passwordEncoder;

    @NonFinal
    @Value("${app.jwt.signerKey}")
    protected String SIGNER_KEY;

    @NonFinal
    @Value("${app.jwt.valid-duration}")
    protected long VALID_DURATION;

    @NonFinal
    @Value("${app.jwt.refreshable-duration}")
    protected long REFRESH_DURATION;

    /**
     * Đăng ký người dùng mới chưa kích hoạt và gửi mã OTP.
     *
     * @param request thông tin user để đăng ký
     */
    @Transactional
    @Override
    public void register(
            UserCreationRequestDto request) {
        if (userRepository.existsByUsername(request.getUsername())) {
            throw new AppException(ErrorCode.USER_ALREADY_EXISTS);
        }

        if (userRepository.existsByEmail(request.getEmail())) {
            throw new AppException(ErrorCode.EMAIL_ALREADY_EXISTS);
        }

        User user = userMapper.toUserFromUserCreationRequestDto(request);
        user.setPasswordHash(passwordEncoder.encode(user.getPasswordHash()));
        user.setRoles(new HashSet<>());
        roleRepository.findById("USER")
                .ifPresent(r -> user.getRoles().add(r));

        user.setIsActive(true);
        user.setIsVerified(false);
        userRepository.save(user);
    }

    /**
     * Đăng nhập bằng username hoặc email, kiểm tra mật khẩu và sinh JWT.
     *
     * @param request thông tin đăng nhập
     * @return AuthenticationResponse chứa accessToken và thông tin user
     * @throws ParseException khi lỗi parse JWT
     */
    @Override
    public AuthenticationResponseDto login(
            AuthenticationRequestDto request)
            throws ParseException {
        PasswordEncoder passwordEncoder = new BCryptPasswordEncoder(10);

        User user = userRepository
                .findByUsernameOrEmail(request.getUsername(),
                        request.getEmail())
                .orElseThrow(() -> new AppException(ErrorCode.USER_NOT_FOUND));

        boolean authenticated = passwordEncoder.matches(
                request.getPassword(),
                user.getPasswordHash()
        );

        if (!authenticated) {
            throw new AppException(ErrorCode.INVALID_CREDENTIALS);
        }

        return generateTokenAndReturnAuthenticationResponse(user);
    }

    /**
     * Đăng xuất, invalid token bằng cách lưu vào repository.
     *
     * @param token chứa token cần logout
     * @throws ParseException khi lỗi parse JWT
     * @throws JOSEException  khi lỗi verify JWT
     */
    @Override
    public void logout(String token)
            throws ParseException, JOSEException {
        try {
            SignedJWT signToken = verifyToken(token, true);

            invalidateToken(signToken);
        } catch (AppException e) {
            log.info("Token already expired");
        }
    }

    /**
     * Kiểm tra tính hợp lệ của token mà không ném exception.
     *
     * @param request đối tượng chứa token cần kiểm tra
     * @return IntrospectResponse với flag valid
     * @throws JOSEException  khi lỗi ký JWT
     * @throws ParseException khi lỗi parse JWT
     */
    @Override
    public IntrospectResponseDto introspect(
            IntrospectRequestDto request)
            throws JOSEException, ParseException {
        String token = request.getToken();
        boolean isValid = true;
        String userId = null;

        try {
            SignedJWT signedJWT = verifyToken(token, false);

            userId = signedJWT.getJWTClaimsSet().getStringClaim("userId");
        } catch (AppException e) {
            isValid = false;
        }

        return IntrospectResponseDto.builder()
                .valid(isValid)
                .userId(userId)
                .build();
    }

    /**
     * Làm mới access token từ refresh token.
     *
     * @param request chứa token cũ
     * @return AuthenticationResponse chứa token mới và expiryTime
     * @throws ParseException khi lỗi parse JWT
     * @throws JOSEException  khi lỗi verify JWT
     */
    @Override
    public AuthenticationResponseDto refreshToken(RefreshRequestDto request)
            throws ParseException, JOSEException {
        SignedJWT signedJWT = verifyToken(request.getToken(), true);

        invalidateToken(signedJWT);

        User user = userRepository
                .findById(signedJWT.getJWTClaimsSet().getSubject())
                .orElseThrow(() -> new AppException(ErrorCode.USER_NOT_FOUND));

        return generateTokenAndReturnAuthenticationResponse(user);
    }

    private SignedJWT generateToken(
            User user,
            long duration,
            String type) {
        JWSHeader header = new JWSHeader
                .Builder(JWSAlgorithm.HS512)
                .type(JOSEObjectType.JWT)
                .build();

        JWTClaimsSet jwtClaimsSet = buildJwtClaimsSet(user, duration, type);

        SignedJWT signedJWT = new SignedJWT(header, jwtClaimsSet);

        try {
            JWSSigner signer =
                    new MACSigner(SIGNER_KEY.getBytes(StandardCharsets.UTF_8));
            signedJWT.sign(signer);

            return signedJWT;
        } catch (JOSEException e) {
            log.error("Cannot create token", e);
            throw new AppException(ErrorCode.FAILED_GENERATE_TOKEN);
        }
    }

    private JWTClaimsSet buildJwtClaimsSet(
            User user,
            long duration,
            String type) {
        Instant expiryInstant = Instant.now()
                .plus(duration, ChronoUnit.SECONDS);

        JWTClaimsSet.Builder builder = new JWTClaimsSet.Builder()
                .subject(user.getId())
                .issuer("Code Campus")
                .issueTime(new Date())
                .expirationTime(Date.from(expiryInstant))
                .jwtID(UUID.randomUUID().toString())
                .claim("userId", user.getId())
                .claim("roles", user.getRoles()
                        .stream()
                        .map(Role::getName)
                        .toList()
                )
                .claim("token_type", type);

        return builder.build();
    }

    private SignedJWT verifyToken(
            String token,
            boolean isRefresh)
            throws JOSEException, ParseException {
        SignedJWT signedJWT = SignedJWT.parse(token);

        Date expiryTime = isRefresh
                ? Date.from(signedJWT.getJWTClaimsSet()
                .getIssueTime()       // thời điểm phát hành
                .toInstant()
                .plus(REFRESH_DURATION, ChronoUnit.SECONDS))
                : signedJWT.getJWTClaimsSet().getExpirationTime();

        boolean verified = signedJWT.verify(
                new MACVerifier(SIGNER_KEY.getBytes(StandardCharsets.UTF_8)));

        if (!(verified && expiryTime.after(new Date()))) {
            throw new AppException(ErrorCode.UNAUTHENTICATED);
        }

        if (invalidatedTokenRepository.existsById(
                signedJWT.getJWTClaimsSet().getJWTID())) {
            throw new AppException(ErrorCode.TOKEN_REVOKED);
        }

        return signedJWT;
    }

    private void invalidateToken(SignedJWT signedJWT)
            throws ParseException {
        String jit = signedJWT.getJWTClaimsSet().getJWTID();
        Date expiryTime = signedJWT.getJWTClaimsSet().getExpirationTime();

        InvalidatedToken invalidatedToken = InvalidatedToken.builder()
                .id(jit)
                .expiryTime(expiryTime.toInstant())
                .build();

        invalidatedTokenRepository.save(invalidatedToken);
    }

    private AuthenticationResponseDto generateTokenAndReturnAuthenticationResponse(
            User user)
            throws ParseException {
        SignedJWT accessToken =
                generateToken(user, VALID_DURATION, "access_token");
        SignedJWT refreshToken =
                generateToken(user, REFRESH_DURATION, "refresh_token");

        return AuthenticationResponseDto.builder()
                .accessToken(accessToken.serialize())
                .refreshToken(refreshToken.serialize())
                .accessExpiry(accessToken.getJWTClaimsSet().getExpirationTime()
                        .toInstant())
                .refreshExpiry(
                        refreshToken.getJWTClaimsSet().getExpirationTime()
                                .toInstant())
                .build();
    }
}

package com.core.service;

import com.core.dto.request.user.AddressCreateRequestDto;
import com.core.dto.request.user.AddressUpdateRequestDto;
import com.core.dto.response.user.AddressResponseDto;
import org.common.http.Envelope;

public interface IAddressService {
    void create(AddressCreateRequestDto req);

    void update(
            String addressId,
            AddressUpdateRequestDto req);

    void softDelete(String addressId);

    void setDefaultShipping(String addressId);

    void setDefaultBilling(String addressId);

    Envelope.Page<AddressResponseDto> listByUser(
            String userId,
            int page, int size);
}

package com.core.service;


import com.core.dto.request.user.AssignRoleRequestDto;
import com.core.dto.request.user.CreateRoleRequestDto;
import com.core.dto.response.user.MeResponseDto;
import com.core.dto.response.user.RoleResponseDto;
import org.common.http.Envelope;

public interface IRoleService {
    void create(CreateRoleRequestDto req);

    void softDelete(String roleName);

    void restore(String roleName);

    void assign(AssignRoleRequestDto req);

    void remove(AssignRoleRequestDto req);

    Envelope.Page<RoleResponseDto> listUserRoles(
            String userId,
            int page, int size);

    Envelope.Page<MeResponseDto> listUsersByRole(
            String roleName,
            int page, int size);

    Envelope.Page<RoleResponseDto> listAllRoles(
            int page, int size);
}

package com.core.service.impl;

import com.core.dto.request.otp.OtpSendRequestDto;
import com.core.dto.request.otp.OtpVerificationRequestDto;
import com.core.dto.request.otp.UserOtpRequestDto;
import com.core.dto.response.otp.OtpResponseDto;
import com.core.entity.otp.OtpVerification;
import com.core.entity.User;
import com.core.repository.otp.OtpVerificationRepository;
import com.core.repository.UserRepository;
import com.core.service.IOtpService;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.experimental.NonFinal;
import lombok.extern.slf4j.Slf4j;
import org.common.exception.AppException;
import org.common.exception.ErrorCode;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Random;

@Service
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@Slf4j
public class OtpServiceImpl implements IOtpService {

    JavaMailSender mailSender;
    OtpVerificationRepository otpVerificationRepository;
    UserRepository userRepository;

    @Value("${app.otp.expiry-minutes}")
    @NonFinal
    protected int OTP_VERIFY_MINUTES;

    @Value("${spring.mail.username}")
    @NonFinal
    protected String EMAIL;

    @Override
    public OtpResponseDto sendOtp(
            UserOtpRequestDto request) {
        String otpCode = generateOtp();
        Instant expiryTime = Instant.now()
                .plus(OTP_VERIFY_MINUTES, ChronoUnit.MINUTES);

        OtpVerification otp = otpVerificationRepository
                .findByEmail(request.getEmail())
                .map(existing -> {
                    existing.setOtpCode(otpCode);
                    existing.setExpiryTime(expiryTime);
                    existing.setVerified(false);
                    return existing;
                })
                .orElseGet(() -> OtpVerification.builder()
                        .email(request.getEmail())
                        .otpCode(otpCode)
                        .expiryTime(expiryTime)
                        .verified(false)
                        .build());
        otpVerificationRepository.save(otp);

        OtpSendRequestDto otpSendRequestDto = OtpSendRequestDto.builder()
                .email(request.getEmail())
                .otpCode(otpCode)
                .build();
        sendEmail(otpSendRequestDto);

        return OtpResponseDto.builder()
                .email(request.getEmail())
                .message("OTP sent successfully")
                .build();
    }

    void sendEmail(OtpSendRequestDto request) {
        try {
            SimpleMailMessage message = new SimpleMailMessage();
            message.setFrom(EMAIL);
            message.setFrom(EMAIL);
            message.setTo(request.getEmail());
            message.setSubject("Xác minh tài khoản");
            message.setText("Mã OTP của bạn là: " + request.getOtpCode()
                    + "\nMã có hiệu lực trong " + OTP_VERIFY_MINUTES + " phút");
            mailSender.send(message);
            log.info("OTP sent to: {}", request.getEmail());
        } catch (Exception e) {
            log.error("Failed to send OTP email", e);
            throw new AppException(ErrorCode.EMAIL_SEND_FAILED);
        }
    }

    @Override
    public void verifyOtp(OtpVerificationRequestDto request) {
        OtpVerification otp = otpVerificationRepository
                .findByEmail(request.getEmail())
                .orElseThrow(
                        () -> new AppException(ErrorCode.EMAIL_NOT_FOUND)
                );

        if (!otp.getOtpCode().equals(request.getOtpCode())) {
            throw new AppException(ErrorCode.INVALID_OTP);
        }

        if (Instant.now().isAfter(otp.getExpiryTime())) {
            throw new AppException(ErrorCode.OTP_EXPIRED);
        }

        User user = userRepository.findByEmail(request.getEmail())
                .orElseThrow(() -> new AppException(ErrorCode.USER_NOT_FOUND));

        user.setIsVerified(true);
        userRepository.save(user);

        otp.setVerified(true);
        otpVerificationRepository.save(otp);

    }

    String generateOtp() {
        Random random = new Random();
        return String.format("%06d", random.nextInt(999999));
    }

}

package com.core.service.impl;

import com.core.dto.request.otp.OtpSendRequestDto;
import com.core.dto.request.otp.OtpVerificationRequestDto;
import com.core.dto.request.otp.ResetPasswordRequestDto;
import com.core.dto.request.otp.UserOtpRequestDto;
import com.core.dto.response.otp.OtpResponseDto;
import com.core.entity.User;
import com.core.entity.otp.PasswordResetToken;
import com.core.repository.UserRepository;
import com.core.repository.otp.PasswordResetTokenRepository;
import com.core.service.IPasswordResetService;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.experimental.NonFinal;
import lombok.extern.slf4j.Slf4j;
import org.common.exception.AppException;
import org.common.exception.ErrorCode;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Random;

@Service
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@Slf4j
public class PasswordResetServiceImpl
        implements IPasswordResetService {

    JavaMailSender mailSender;
    UserRepository userRepository;
    PasswordResetTokenRepository tokenRepository;
    PasswordEncoder passwordEncoder;

    @Value("${spring.mail.username}")
    @NonFinal
    String EMAIL;

    @Value("${app.password-reset.expiry-minutes:15}")
    @NonFinal
    int PASSWORD_EXPIRY_MINUTES;

    @Override
    public OtpResponseDto requestResetPassword(
            UserOtpRequestDto request) {
        User user = userRepository.findByEmail(request.getEmail())
                .orElseThrow(() -> new AppException(ErrorCode.EMAIL_NOT_FOUND));

        String otp = genOtp();
        Instant expiry = Instant.now()
                .plus(PASSWORD_EXPIRY_MINUTES, ChronoUnit.MINUTES);

        PasswordResetToken token = tokenRepository.findByEmail(user.getEmail())
                .map(t -> {
                    t.setOtpCode(otp);
                    t.setExpiryTime(expiry);
                    t.setConsumed(false);
                    return t;
                })
                .orElse(PasswordResetToken.builder()
                        .email(user.getEmail())
                        .otpCode(otp)
                        .expiryTime(expiry)
                        .consumed(false)
                        .build());

        tokenRepository.save(token);

        OtpSendRequestDto otpSendRequestDto = OtpSendRequestDto.builder()
                .email(user.getEmail())
                .otpCode(otp)
                .build();
        sendEmail(otpSendRequestDto);

        return OtpResponseDto.builder()
                .email(user.getEmail())
                .message("Password reset OTP sent successfully!")
                .build();
    }

    @Override
    public void verifyOtpPassword(
            OtpVerificationRequestDto request) {
        PasswordResetToken token =
                tokenRepository.findByEmail(request.getEmail())
                        .orElseThrow(() -> new AppException(
                                ErrorCode.EMAIL_NOT_FOUND));

        if (token.isConsumed()) {
            throw new AppException(ErrorCode.INVALID_OTP);
        }
        if (!token.getOtpCode().equals(request.getOtpCode())) {
            throw new AppException(ErrorCode.INVALID_OTP);
        }
        if (Instant.now().isAfter(token.getExpiryTime())) {
            throw new AppException(ErrorCode.OTP_EXPIRED);
        }
    }

    @Override
    public void resetPassword(ResetPasswordRequestDto request) {
        PasswordResetToken token =
                tokenRepository.findByEmail(request.getEmail())
                        .orElseThrow(() -> new AppException(
                                ErrorCode.EMAIL_NOT_FOUND));

        if (token.isConsumed()) {
            throw new AppException(ErrorCode.INVALID_OTP);
        }
        if (!token.getOtpCode().equals(request.getOtp())) {
            throw new AppException(ErrorCode.INVALID_OTP);
        }
        if (Instant.now().isAfter(token.getExpiryTime())) {
            throw new AppException(ErrorCode.OTP_EXPIRED);
        }

        User user = userRepository.findByEmail(request.getEmail())
                .orElseThrow(() -> new AppException(ErrorCode.USER_NOT_FOUND));

        user.setPasswordHash(passwordEncoder.encode(request.getNewPassword()));
        userRepository.save(user);

        token.setConsumed(true);
        tokenRepository.save(token);
    }

    void sendEmail(OtpSendRequestDto request) {
        try {
            SimpleMailMessage message = new SimpleMailMessage();
            message.setFrom(EMAIL);
            message.setTo(request.getEmail());
            message.setSubject("Đặt lại mật khẩu");
            message.setText("Mã OTP đặt lại mật khẩu của bạn là: " +
                    request.getOtpCode()
                    + "\nMã có hiệu lực trong " + PASSWORD_EXPIRY_MINUTES +
                    " phút");
            mailSender.send(message);
        } catch (Exception e) {
            throw new AppException(ErrorCode.EMAIL_SEND_FAILED);
        }
    }

    String genOtp() {
        return String.format("%06d", new Random().nextInt(999999));
    }
}

package com.core.controller;

import com.common.grpc.AuthServiceGrpc;
import com.common.grpc.IntrospectRequest;
import com.common.grpc.IntrospectResponse;
import com.common.grpc.LoginRequest;
import com.common.grpc.LoginResponse;
import com.common.grpc.LogoutRequest;
import com.common.grpc.LogoutResponse;
import com.common.grpc.RefreshRequest;
import com.common.grpc.RefreshResponse;
import com.common.grpc.RegisterRequest;
import com.common.grpc.RegisterResponse;
import com.core.dto.request.authentication.AuthenticationRequestDto;
import com.core.dto.request.authentication.IntrospectRequestDto;
import com.core.dto.request.authentication.RefreshRequestDto;
import com.core.dto.request.authentication.UserCreationRequestDto;
import com.core.dto.response.authentication.AuthenticationResponseDto;
import com.core.dto.response.authentication.IntrospectResponseDto;
import com.core.service.IAuthenticationService;
import com.nimbusds.jose.JOSEException;
import io.grpc.stub.StreamObserver;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.extern.slf4j.Slf4j;
import net.devh.boot.grpc.server.service.GrpcService;
import org.common.exception.ErrorCode;
import org.common.exception.GrpcStatusMapper;

import java.text.ParseException;

@GrpcService
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@Slf4j
public class AuthenticationGrpcServer
        extends AuthServiceGrpc.AuthServiceImplBase {

    IAuthenticationService authenticationService;

    @Override
    public void register(
            RegisterRequest registerRequest,
            StreamObserver<RegisterResponse> streamObserver) {
        authenticationService.register(UserCreationRequestDto.builder()
                .username(registerRequest.getUsername())
                .email(registerRequest.getEmail())
                .password(registerRequest.getPassword())
                .build());

        GrpcStatusMapper.ok(streamObserver, RegisterResponse.newBuilder().build());
    }

    @Override
    public void login(
            LoginRequest loginRequest,
            StreamObserver<LoginResponse> streamObserver) {
        try {
            AuthenticationResponseDto authenticationResponseDto =
                    authenticationService.login(
                            AuthenticationRequestDto.builder()
                                    .username(loginRequest.getUsername())
                                    .email(loginRequest.getEmail())
                                    .password(loginRequest.getPassword())
                                    .build());

            GrpcStatusMapper.ok(streamObserver, LoginResponse.newBuilder()
                    .setAccessToken(authenticationResponseDto.getAccessToken())
                    .setRefreshToken(
                            authenticationResponseDto.getRefreshToken())
                    .setAccessExpiry(
                            authenticationResponseDto.getAccessExpiry()
                                    .toString())
                    .setRefreshExpiry(
                            authenticationResponseDto.getRefreshExpiry()
                                    .toString())
                    .build());
        } catch (ParseException exception) {
            GrpcStatusMapper.fail(streamObserver,
                    ErrorCode.FAILED_VALIDATE_TOKEN);
        }
    }

    @Override
    public void refresh(
            RefreshRequest refreshRequest,
            StreamObserver<RefreshResponse> streamObserver) {
        try {
            AuthenticationResponseDto authenticationResponseDto =
                    authenticationService
                            .refreshToken(RefreshRequestDto.builder()
                                    .token(refreshRequest.getToken())
                                    .build());

            GrpcStatusMapper.ok(streamObserver, RefreshResponse.newBuilder()
                    .setAccessToken(authenticationResponseDto.getAccessToken())
                    .setRefreshToken(
                            authenticationResponseDto.getRefreshToken())
                    .setAccessExpiry(String.valueOf(
                            authenticationResponseDto.getAccessExpiry()))
                    .setRefreshExpiry(String.valueOf(
                            authenticationResponseDto.getRefreshExpiry()))
                    .build());
        } catch (ParseException | JOSEException exception) {
            GrpcStatusMapper.fail(streamObserver,
                    ErrorCode.FAILED_VALIDATE_TOKEN);
        }
    }

    @Override
    public void introspect(
            IntrospectRequest introspectRequest,
            StreamObserver<IntrospectResponse> responseObserver) {
        try {
            IntrospectResponseDto introspectResponseDto = authenticationService
                    .introspect(IntrospectRequestDto.builder()
                            .token(introspectRequest.getToken())
                            .build());

            GrpcStatusMapper.ok(responseObserver, IntrospectResponse.newBuilder()
                    .setValid(introspectResponseDto.isValid())
                    .setUserId(introspectResponseDto.getUserId() == null
                            ? ""
                            : introspectResponseDto.getUserId())
                    .build());
        } catch (ParseException | JOSEException exception) {
            GrpcStatusMapper.fail(responseObserver,
                    ErrorCode.FAILED_VALIDATE_TOKEN);
        }
    }

    @Override
    public void logout(
            LogoutRequest logoutRequest,
            StreamObserver<LogoutResponse> responseObserver) {
        try {
            authenticationService.logout(logoutRequest.getToken());
            GrpcStatusMapper.ok(responseObserver, LogoutResponse.newBuilder().build());
        } catch (ParseException | JOSEException exception) {
            GrpcStatusMapper.fail(responseObserver,
                    ErrorCode.FAILED_VALIDATE_TOKEN);
        }
    }
}


package com.core.controller;

import com.common.grpc.OtpResponse;
import com.common.grpc.OtpServiceGrpc;
import com.common.grpc.OtpVerificationRequest;
import com.common.grpc.ResetPasswordRequest;
import com.common.grpc.UserOtpRequest;
import com.core.dto.request.otp.OtpVerificationRequestDto;
import com.core.dto.request.otp.ResetPasswordRequestDto;
import com.core.dto.request.otp.UserOtpRequestDto;
import com.core.dto.response.otp.OtpResponseDto;
import com.core.service.IOtpService;
import com.core.service.IPasswordResetService;
import com.google.protobuf.Empty;
import io.grpc.stub.StreamObserver;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.extern.slf4j.Slf4j;
import net.devh.boot.grpc.server.service.GrpcService;
import org.common.exception.GrpcStatusMapper;

@GrpcService
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@Slf4j
public class OtpGrpcServer
        extends OtpServiceGrpc.OtpServiceImplBase {

    IOtpService otpService;
    IPasswordResetService passwordResetService;


    @Override
    public void sendOtp(
            UserOtpRequest request,
            StreamObserver<OtpResponse> responseObserver) {
        OtpResponseDto otpResponseDto =
                otpService.sendOtp(UserOtpRequestDto.builder()
                        .email(request.getEmail())
                        .build());

        GrpcStatusMapper.ok(responseObserver, OtpResponse.newBuilder()
                .setEmail(otpResponseDto.getEmail())
                .setMessage(otpResponseDto.getMessage())
                .build());
    }

    @Override
    public void verifyOtp(
            OtpVerificationRequest request,
            StreamObserver<Empty> responseObserver) {
        otpService.verifyOtp(OtpVerificationRequestDto.builder()
                .email(request.getEmail())
                .otpCode(request.getOtpCode())
                .build());

        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void requestResetPassword(
            UserOtpRequest request,
            StreamObserver<OtpResponse> responseObserver) {
        OtpResponseDto otpResponseDto = passwordResetService
                .requestResetPassword(UserOtpRequestDto.builder()
                        .email(request.getEmail())
                        .build());

        GrpcStatusMapper.ok(responseObserver, OtpResponse.newBuilder()
                .setEmail(otpResponseDto.getEmail())
                .setMessage(otpResponseDto.getMessage())
                .build());
    }

    @Override
    public void verifyOtpPassword(
            OtpVerificationRequest request,
            StreamObserver<Empty> responseObserver) {
        passwordResetService.verifyOtpPassword(
                OtpVerificationRequestDto.builder()
                        .email(request.getEmail())
                        .otpCode(request.getOtpCode())
                        .build());

        GrpcStatusMapper.ok(responseObserver);
    }


    @Override
    public void resetPassword(
            ResetPasswordRequest request,
            StreamObserver<Empty> responseObserver) {
        passwordResetService.resetPassword(ResetPasswordRequestDto.builder()
                .email(request.getEmail())
                .otp(request.getOtp())
                .newPassword(request.getNewPassword())
                .build());

        GrpcStatusMapper.ok(responseObserver);
    }
}

package com.core.controller;

import com.common.grpc.AssignRoleRequest;
import com.common.grpc.CreateRoleRequest;
import com.common.grpc.MeLite;
import com.common.grpc.PageRequest;
import com.common.grpc.PageRole;
import com.common.grpc.PageUser;
import com.common.grpc.RoleName;
import com.common.grpc.RoleResponse;
import com.common.grpc.RoleServiceGrpc;
import com.core.dto.request.user.AssignRoleRequestDto;
import com.core.dto.request.user.CreateRoleRequestDto;
import com.core.dto.response.user.MeResponseDto;
import com.core.dto.response.user.RoleResponseDto;
import com.core.service.IRoleService;
import com.google.protobuf.Empty;
import io.grpc.stub.StreamObserver;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.extern.slf4j.Slf4j;
import net.devh.boot.grpc.server.service.GrpcService;
import org.common.exception.GrpcStatusMapper;
import org.common.http.Envelope;

@GrpcService
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@Slf4j
public class RoleGrpcServer extends RoleServiceGrpc.RoleServiceImplBase {
    private final IRoleService roleService;

    @Override
    public void create(
            CreateRoleRequest r,
            StreamObserver<Empty> responseObserver){
        roleService.create(CreateRoleRequestDto.builder()
                .name(r.getName())
                .build());
        GrpcStatusMapper.ok(responseObserver);
    }
    @Override
    public void softDelete(
            RoleName r,
            StreamObserver<Empty> responseObserver){
        roleService.softDelete(r.getName());
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override public void restore(
            RoleName r,
            StreamObserver<Empty> responseObserver){
        roleService.restore(r.getName());
        GrpcStatusMapper.ok(responseObserver);
    }
    @Override
    public void assign(
            AssignRoleRequest r,
            StreamObserver<Empty> responseObserver){
        AssignRoleRequestDto dto = AssignRoleRequestDto.builder()
                .userId(r.getUserId())
                .roleName(r.getRoleName())
                .build();
        roleService.assign(dto);
        GrpcStatusMapper.ok(responseObserver);
    }
    @Override
    public void remove(
            AssignRoleRequest r,
            StreamObserver<Empty> responseObserver){
        AssignRoleRequestDto dto = AssignRoleRequestDto.builder()
                .userId(r.getUserId())
                .roleName(r.getRoleName())
                .build();
        roleService.remove(dto);
        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void listUserRoles(
            AssignRoleRequest r,
            StreamObserver<PageRole> responseObserver) {
        Envelope.Page<RoleResponseDto> page = roleService.listUserRoles(
                r.getUserId(), 0, Integer.MAX_VALUE);
        PageRole.Builder builder = PageRole.newBuilder()
                .setPage(page.getPage())
                .setSize(page.getSize())
                .setTotal(page.getTotal())
                .setTotalPages(page.getTotalPages());

        page.getDocs().forEach(rr -> builder.addDocs(
                RoleResponse.newBuilder()
                        .setName(rr.getName())
                        .build()));

        GrpcStatusMapper.ok(responseObserver, builder.build());
    }

    @Override
    public void listUsersByRole(
            RoleName r,
            StreamObserver<PageUser> responseObserver) {
        Envelope.Page<MeResponseDto> page = roleService.listUsersByRole(
                r.getName(),0, Integer.MAX_VALUE);
        PageUser.Builder b = PageUser.newBuilder()
                .setPage(page.getPage())
                .setSize(page.getSize())
                .setTotal(page.getTotal())
                .setTotalPages(page.getTotalPages());
        page.getDocs().forEach(m -> b.addDocs(
                MeLite.newBuilder().setId(m.getId())
                        .setUsername(m.getUsername())
                        .setEmail(m.getEmail())
                        .setFullName(m.getFullName() == null
                                ? ""
                                : m.getFullName())
                        .build()));

        GrpcStatusMapper.ok(responseObserver, b.build());
    }

    @Override
    public void listAll(
            PageRequest r,
            StreamObserver<PageRole> responseObserver) {
        Envelope.Page<RoleResponseDto> page = roleService.listAllRoles(
                r.getPage(), r.getSize());
        PageRole.Builder b = PageRole.newBuilder()
                .setPage(page.getPage())
                .setSize(page.getSize())
                .setTotal(page.getTotal())
                .setTotalPages(page.getTotalPages());
        page.getDocs().forEach(rr -> b.addDocs(RoleResponse.newBuilder()
                .setName(rr.getName())
                .build()));

        GrpcStatusMapper.ok(responseObserver, b.build());
    }
}

package com.core.controller;

import com.common.grpc.MeResponse;
import com.common.grpc.ToggleActiveRequest;
import com.common.grpc.UpdateProfileRequest;
import com.common.grpc.UserServiceGrpc;
import com.core.dto.request.user.UpdateProfileRequestDto;
import com.core.dto.response.user.MeResponseDto;
import com.core.service.IUserService;
import com.google.protobuf.Empty;
import io.grpc.stub.StreamObserver;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.extern.slf4j.Slf4j;
import net.devh.boot.grpc.server.service.GrpcService;
import org.common.exception.GrpcStatusMapper;

@GrpcService
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@Slf4j
public class UserGrpcServer extends UserServiceGrpc.UserServiceImplBase {
    private final IUserService userService;

    @Override
    public void toggleActive(
            ToggleActiveRequest request,
            StreamObserver<Empty> responseObserver) {
        userService.toggleActive(
                request.getUserId(),
                request.getActive());

        GrpcStatusMapper.ok(responseObserver);
    }

    @Override
    public void getMe(
            Empty request,
            StreamObserver<MeResponse> responseObserver) {
        MeResponseDto me = userService.getMe();
        GrpcStatusMapper.ok(responseObserver, MeResponse.newBuilder()
                .setId(me.getId())
                .setUsername(me.getUsername())
                .setEmail(me.getEmail())
                .setFullName(me.getFullName() == null
                        ? ""
                        : me.getFullName())
                .setPhoneNumber(me.getPhoneNumber() == null
                        ? ""
                        : me.getPhoneNumber())
                .setIsActive(Boolean.TRUE.equals(me.getIsActive()))
                .setIsVerified(Boolean.TRUE.equals(me.getIsVerified()))
                .build());
    }

    @Override
    public void updateProfile(
            UpdateProfileRequest request,
            StreamObserver<Empty> responseObserver) {
        userService.updateProfile(UpdateProfileRequestDto.builder()
                .fullName(request.getFullName())
                .phoneNumber(request.getPhoneNumber())
                .build());
        GrpcStatusMapper.ok(responseObserver);
    }
}

package com.core.dto.request.user;


import jakarta.validation.constraints.NotBlank;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.FieldDefaults;

@Data
@NoArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@AllArgsConstructor
@Builder
public class AddressCreateRequestDto {
    @NotBlank
    String contactName;

    @NotBlank
    String contactPhone;

    @NotBlank
    String addressLine1;
    String addressLine2;

    @NotBlank
    String district;

    @NotBlank
    String city;

    String country;
    String postalCode;
}

package com.core.dto.request.user;

import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.FieldDefaults;

@Data
@NoArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@AllArgsConstructor
@Builder
public class AddressUpdateRequestDto {
    String contactName;
    String contactPhone;
    String addressLine1;
    String addressLine2;
    String district;
    String city;
    String country;
    String postalCode;
}

package com.core.dto.request.user;

import jakarta.validation.constraints.NotBlank;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.FieldDefaults;

@Data
@NoArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@AllArgsConstructor
@Builder
public class AssignRoleRequestDto {
    @NotBlank
    String userId;

    @NotBlank
    String roleName;
}

package com.core.dto.request.user;

import jakarta.validation.constraints.NotBlank;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.FieldDefaults;

@Data
@NoArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@AllArgsConstructor
@Builder
public class CreateRoleRequestDto {
    @NotBlank
    String name;
}

package com.core.dto.request.user;

import jakarta.validation.constraints.Size;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.FieldDefaults;

@Data
@NoArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@AllArgsConstructor
@Builder
public class UpdateProfileRequestDto {
    @Size(min = 1, max = 100)
    String fullName;

    @Size(min = 9, max = 15)
    String phoneNumber;
}

package com.core.dto.response.user;


import lombok.AccessLevel;
import lombok.Builder;
import lombok.Data;
import lombok.experimental.FieldDefaults;

@Data
@Builder
@FieldDefaults(level = AccessLevel.PRIVATE)
public class AddressResponseDto {
    String id;
    String contactName;
    String contactPhone;
    String addressLine1;
    String addressLine2;
    String district;
    String city;
    String country;
    String postalCode;
    Boolean isDefaultShipping;
    Boolean isDefaultBilling;
}
package com.core.dto.response.user;


import lombok.AccessLevel;
import lombok.Builder;
import lombok.Data;
import lombok.experimental.FieldDefaults;

@Data
@Builder
@FieldDefaults(level = AccessLevel.PRIVATE)
public class MeResponseDto {
    String id;
    String username;
    String email;
    String fullName;
    String phoneNumber;
    Boolean isActive;
    Boolean isVerified;
}
package com.core.dto.response.user;

import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.FieldDefaults;

@Data
@NoArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE)
@AllArgsConstructor
@Builder
public class RoleResponseDto {
    String name;
}

package com.core.helper;

import lombok.experimental.UtilityClass;
import org.common.exception.AppException;
import org.common.exception.ErrorCode;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;

import java.util.Set;
import java.util.stream.Collectors;

@UtilityClass
public class AuthenticationHelper {
    public String getMyUserId() {
        Authentication a = SecurityContextHolder.getContext().getAuthentication();
        if (a == null || a.getName() == null) throw new AppException(ErrorCode.UNAUTHENTICATED);
        return a.getName();
    }

    public Set<String> getMyRoles() {
        Authentication a = SecurityContextHolder.getContext().getAuthentication();
        if (a == null) throw new AppException(ErrorCode.UNAUTHENTICATED);
        return a.getAuthorities()
                .stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.toSet());
    }

    public void requireAdmin() {
        if (!getMyRoles().contains("ROLE_ADMIN") && !getMyRoles().contains("ADMIN")) {
            throw new AppException(ErrorCode.UNAUTHORIZED);
        }
    }
}

package com.core.helper;

import com.core.entity.User;
import com.core.repository.UserRepository;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.extern.slf4j.Slf4j;
import org.common.exception.AppException;
import org.common.exception.ErrorCode;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
@Slf4j
public class UserHelper {
    UserRepository users;

    public User getUserById(String id){
        return users.findById(id)
                .orElseThrow(() -> new AppException(ErrorCode.USER_NOT_FOUND));
    }
    public User getUserByEmail(String email){
        return users.findByEmail(email)
                .orElseThrow(() -> new AppException(ErrorCode.EMAIL_NOT_FOUND));
    }
}

package com.core.mapper.user;

import com.core.dto.request.user.AddressCreateRequestDto;
import com.core.dto.request.user.AddressUpdateRequestDto;
import com.core.dto.response.user.AddressResponseDto;
import com.core.entity.Address;
import org.mapstruct.Mapper;
import org.mapstruct.MappingTarget;
import org.mapstruct.NullValuePropertyMappingStrategy;
import org.mapstruct.ReportingPolicy;

@Mapper(componentModel = "spring",
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public interface AddressMapper {

    Address toAddressFromAddressCreateRequestDto(
            AddressCreateRequestDto addressCreateRequestDto);

    void patchAddressFromAddressUpdateRequestDto(
            @MappingTarget Address address,
            AddressUpdateRequestDto addressUpdateRequestDto
    );

    AddressResponseDto toAddressResponseDtoFromAddress(
            Address address);
}

package com.core.mapper.user;

import com.core.dto.request.user.UpdateProfileRequestDto;
import com.core.dto.response.user.MeResponseDto;
import com.core.entity.User;
import org.mapstruct.Mapper;
import org.mapstruct.MappingTarget;
import org.mapstruct.NullValuePropertyMappingStrategy;
import org.mapstruct.ReportingPolicy;

@Mapper(componentModel = "spring",
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public interface UserProfileMapper {

    MeResponseDto toMeResponseDtoFromUser(
            User user);

    void patchUserFromUpdateProfileRequestDto(
            @MappingTarget User user,
            UpdateProfileRequestDto updateProfileRequestDto);
}


package com.core.configuration.audit;

import org.hibernate.Interceptor;
import org.springframework.boot.autoconfigure.orm.jpa.HibernatePropertiesCustomizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class HibernateInterceptorConfig {
    @Bean
    public Interceptor softDeleteInterceptor() {
        return new SoftDeleteInterceptor();
    }

    @Bean
    public HibernatePropertiesCustomizer interceptorCustomizer(
            Interceptor softDeleteInterceptor) {

        return props -> props.put(
                "hibernate.session_factory.interceptor",
                softDeleteInterceptor);
    }
}

package com.core.configuration.audit;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.domain.AuditorAware;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;

import java.util.Optional;

@Configuration
@EnableJpaAuditing(auditorAwareRef = "auditorProvider")
public class JpaAuditConfiguration {
    /**
     * Trả về username hiện tại (hoặc “System” nếu chưa đăng nhập).
     * Spring Data sẽ dùng giá trị này để gán vào @CreatedBy / @LastModifiedBy.
     */
    @Bean
    public AuditorAware<String> auditorProvider() {
        return () -> {
            Authentication auth = SecurityContextHolder
                    .getContext()
                    .getAuthentication();

            return Optional.ofNullable(auth)
                    .map(Authentication::getName)
                    .or(() -> Optional.of("System"));
        };
    }
}


package com.core.configuration.audit;

import com.core.entity.audit.SoftDeletable;
import lombok.extern.slf4j.Slf4j;
import org.hibernate.EmptyInterceptor;
import org.hibernate.type.Type;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;

import java.time.Instant;
import java.util.Optional;

@Slf4j
public class SoftDeleteInterceptor extends EmptyInterceptor {
    @Override
    public void onDelete(
            Object entity,
            Object id,
            Object[] state,
            String[] propertyNames,
            Type[] types) {

        if (!(entity instanceof SoftDeletable soft)) {
            super.onDelete(
                    entity,
                    id,
                    state,
                    propertyNames,
                    types
            );
            return;
        }

        // Chặn DELETE -> UPDATE
        String by = Optional.ofNullable(SecurityContextHolder
                        .getContext()
                        .getAuthentication())
                .map(Authentication::getName)
                .orElse("System");

        soft.markDeleted(by);

        // Đẩy giá trị vào state[] để Hibernate cập nhật DB
        Instant now = Instant.now();
        for (int i = 0; i < propertyNames.length; i++) {
            switch (propertyNames[i]) {
                case "deletedBy" -> state[i] = by;
                case "deletedAt" -> state[i] = now;
            }
        }

    }
}

package com.core.configuration.exception;

import io.grpc.StatusRuntimeException;
import jakarta.validation.ConstraintViolationException;
import lombok.extern.slf4j.Slf4j;
import net.devh.boot.grpc.server.advice.GrpcExceptionHandler;
import org.common.exception.AppException;
import org.common.exception.ErrorCode;
import org.common.exception.GrpcStatusMapper;
import org.common.http.Envelope;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

@Slf4j
@ControllerAdvice
@ConditionalOnProperty(
        name = "core.http.error.enabled",
        havingValue = "true",
        matchIfMissing = false
)
public class GlobalExceptionHandler {

    @ExceptionHandler(AppException.class)
    public ResponseEntity<Envelope<Void>> handleAppException(
            AppException appException){
        ErrorCode errorCode = appException.getErrorCode();
        return ResponseEntity.status(errorCode.getStatusCode())
                .body(Envelope.err(
                        errorCode.http(),
                        errorCode.name(),
                        errorCode.getMessage(),
                        null)
                );
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Envelope<Void>> handleAnyException(
            Exception exception){
        ErrorCode errorCode = ErrorCode.UNCATEGORIZED_EXCEPTION;
        return ResponseEntity.status(errorCode.getStatusCode())
                .body(Envelope.err(
                        errorCode.http(),
                        errorCode.name(),
                        errorCode.getMessage(),
                        null)
                );
    }
}

package com.core.configuration.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.ProviderManager;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationProvider;

@Configuration
public class GrpcJwtAuthManagerConfig {

    @Bean
    public JwtAuthenticationConverter grpcJwtAuthenticationConverter() {
        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
        return jwtAuthenticationConverter;
    }

    @Bean
    public AuthenticationManager grpcAuthenticationManager(
            JwtDecoder jwtDecoder,
            JwtAuthenticationConverter grpcJwtAuthenticationConverter) {

        JwtAuthenticationProvider provider = new JwtAuthenticationProvider(jwtDecoder);
        provider.setJwtAuthenticationConverter(grpcJwtAuthenticationConverter);
        return new ProviderManager(provider);
    }
}

package com.core.configuration.security;

import com.core.dto.request.authentication.IntrospectRequestDto;
import com.core.dto.response.authentication.IntrospectResponseDto;
import com.core.service.IAuthenticationService;
import com.nimbusds.jose.JOSEException;
import org.common.exception.AppException;
import org.common.exception.ErrorCode;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.oauth2.jose.jws.MacAlgorithm;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.stereotype.Component;

import javax.crypto.spec.SecretKeySpec;
import java.text.ParseException;
import java.util.Objects;


@Component
public class CustomJwtDecoder implements JwtDecoder {

    @Value("${app.jwt.signerKey}")
    private String signerKey;

    @Autowired
    private IAuthenticationService authenticationService;

    private NimbusJwtDecoder nimbusJwtDecoder = null;

    @Override
    public Jwt decode(String token) throws JwtException {
        try {
            IntrospectResponseDto response = authenticationService.introspect(
                    IntrospectRequestDto.builder()
                            .token(token)
                            .build());

            if (!response.isValid()) {
                throw new AppException(ErrorCode.INVALID_TOKEN);
            }
        } catch (JOSEException | ParseException e) {
            throw new AppException(ErrorCode.INVALID_TOKEN);
        }

        if (Objects.isNull(nimbusJwtDecoder)) {
            SecretKeySpec secretKeySpec =
                    new SecretKeySpec(signerKey.getBytes(), "HS512");

            nimbusJwtDecoder = NimbusJwtDecoder.withSecretKey(secretKeySpec)
                    .macAlgorithm(MacAlgorithm.HS512)
                    .build();
        }

        return nimbusJwtDecoder.decode(token);
    }
}

package com.core.configuration.security;

import net.devh.boot.grpc.server.security.authentication.BearerAuthenticationReader;
import net.devh.boot.grpc.server.security.authentication.GrpcAuthenticationReader;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.oauth2.server.resource.authentication.BearerTokenAuthenticationToken;

@Configuration
public class GrpcServerSecurityConfig {
    @Bean
    public GrpcAuthenticationReader grpcAuthenticationReader() {
        return new BearerAuthenticationReader(token ->
                new BearerTokenAuthenticationToken(token));
    }
}

package com.core.configuration.security;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.common.exception.ErrorCode;
import org.common.http.Envelope;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;

import java.io.IOException;

public class JwtAuthenticationEntryPoint
        implements AuthenticationEntryPoint {
    @Override
    public void commence(
            HttpServletRequest request,
            HttpServletResponse response,
            AuthenticationException authException)
            throws IOException {
        ErrorCode errorCode = ErrorCode.UNAUTHENTICATED;
        Envelope<Void> envelope = Envelope.err(
                        errorCode.http(),
                        errorCode.name(),
                        errorCode.getMessage(),
                        null);

        response.setStatus(errorCode.http());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        new ObjectMapper().writeValue(response.getWriter(), envelope);
        response.flushBuffer();
    }
}

package com.core.configuration.security;

import lombok.NoArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.access.hierarchicalroles.RoleHierarchy;
import org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
@NoArgsConstructor
public class SecurityBeanConfig {


    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }


    @Bean
    public RoleHierarchy roleHierarchy() {
        return RoleHierarchyImpl.fromHierarchy("ROLE_ADMIN > ROLE_USER");
    }
}


package com.core.configuration.security;

import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.List;

import static org.common.constant.SecurityConstants.ACCEPT_HEADER;
import static org.common.constant.SecurityConstants.AUTHORIZATION_HEADER;
import static org.common.constant.SecurityConstants.CONTENT_TYPE_HEADER;
import static org.common.constant.SecurityConstants.FRONTEND_ENDPOINT;
import static org.common.constant.SecurityConstants.PUBLIC_ENDPOINTS;
import static org.common.constant.SecurityConstants.URL_PATTERN_ALL;
import static org.springdoc.core.utils.Constants.DELETE_METHOD;
import static org.springdoc.core.utils.Constants.GET_METHOD;
import static org.springdoc.core.utils.Constants.OPTIONS_METHOD;
import static org.springdoc.core.utils.Constants.PATCH_METHOD;
import static org.springdoc.core.utils.Constants.POST_METHOD;
import static org.springdoc.core.utils.Constants.PUT_METHOD;


@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfiguration {

    @Autowired
    private CustomJwtDecoder customJwtDecoder;


    @Bean
    public SecurityFilterChain securityFilterChain(
            HttpSecurity httpSecurity) throws Exception {
        httpSecurity
                .headers(headers -> headers.frameOptions(
                        frame -> frame.sameOrigin()))
                .authorizeHttpRequests(request -> request
                        .requestMatchers(PUBLIC_ENDPOINTS)
                        .permitAll()
                        .anyRequest()
                        .authenticated());

        httpSecurity.oauth2ResourceServer(
                oauth2 -> oauth2.jwt(jwtConfigurer -> jwtConfigurer
                                .decoder(customJwtDecoder)
                                .jwtAuthenticationConverter(
                                        jwtAuthenticationConverter()))
                        .authenticationEntryPoint(
                                new JwtAuthenticationEntryPoint()));
        httpSecurity.csrf(AbstractHttpConfigurer::disable);

        return httpSecurity.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();

        configuration.setAllowedOriginPatterns(List.of(
                FRONTEND_ENDPOINT
        ));

        configuration.setAllowedMethods(
                List.of(GET_METHOD, POST_METHOD, PUT_METHOD, DELETE_METHOD,
                        PATCH_METHOD, OPTIONS_METHOD));

        configuration.setAllowedHeaders(
                List.of(AUTHORIZATION_HEADER, CONTENT_TYPE_HEADER,
                        ACCEPT_HEADER));

        // Cho phép gửi credentials (cookie, header, v.v.)
        configuration.setAllowCredentials(true);

        // Expose header "Authorization"
        configuration.setExposedHeaders(List.of(AUTHORIZATION_HEADER));

        // Thời gian cache preflight request
        configuration.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source =
                new UrlBasedCorsConfigurationSource();

        // Áp dụng cấu hình cho tất cả các endpoint
        source.registerCorsConfiguration(URL_PATTERN_ALL, configuration);
        return source;
    }


    @Bean
    JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter authConverter =
                new JwtGrantedAuthoritiesConverter();
        authConverter.setAuthorityPrefix("");

        JwtAuthenticationConverter converter = new JwtAuthenticationConverter();
        converter.setJwtGrantedAuthoritiesConverter(authConverter);

        converter.setPrincipalClaimName("userId");

        return converter;
    }
}


server:
  port: 8093

grpc:
  server:
    port: 50051
    security:
      enabled: false
    negotiationType: plaintext

spring:
  application:
    name: "core-ms"
  profiles:
    active: "dev"
  datasource:
    url: jdbc:h2:mem:testdb
    driverClassName: org.h2.Driver
    username: sa
    password: ''
  #    url: jdbc:postgresql://localhost:5431/identity_db
  #    username: postgres_identity
  #    password: dinhanst2832004
  #    driver-class-name: org.postgresql.Driver
  h2:
    console:
      enabled: true
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: update
    show-sql: true
  config:
    import: "optional:configserver:http://localhost:8091/"
  cloud:
    openfeign:
      circuitbreaker:
        enabled: true
  mail:
    host: smtp.gmail.com
    port: 587
    username: yunomix2834@gmail.com
    password: mfym xcpi cstr ckfd
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true

app:
  jwt:
    signerKey: "1TjXchw5FloESb63Kc+DFhTARvpWL4jUGCwfGWxuG5SIf/1y/LgJxHnMqaF6A/ij"
    valid-duration: 7200  # in second ~~ 2 ti?ng
    refreshable-duration: 1209600 # ~~ 2 tu?n
  otp:
    expiry-minutes: 5
  password-reset:
    expiry-minutes: 15

core:
  http:
    error:
      enabled: true

management:
  endpoints:
    web:
      exposure:
        include: "*"
  health:
    readiness-state:
      enabled: true
    liveness-state:
      enabled: true
  endpoint:
    shutdown:
      access: unrestricted
    health:
      probes:
        enabled: true
  info:
    env:
      enabled: true

eureka:
  instance:
    preferIpAddress: true
  client:
    fetchRegistry: true
    registerWithEureka: true
    serviceUrl:
      defaultZone: http://localhost:8090/eureka/

info:
  app:
    name: "core-ms"
    description: "Yunomi Xavia Core Project"
    version: "1.0.0"

logging:
  level:
    com:
      demo: DEBUG

resilience4j.circuitbreaker:
  configs:
    default:
      slidingWindowSize: 10
      permittedNumberOfCallsInHalfOpenState: 2
      failureRateThreshold: 50
      waitDurationInOpenState: 10000

resilience4j.retry:
  configs:
    default:
      maxAttempts: 3
      waitDuration: 500
      enableExponentialBackoff: true
      exponentialBackoffMultiplier: 2
      ignoreExceptions:
        - java.lang.NullPointerException
      retryExceptions:
        - java.util.concurrent.TimeoutException

resilience4j.ratelimiter:
  configs:
    default:
      timeoutDuration: 1000
      limitRefreshPeriod: 5000
      limitForPeriod: 1


gateway-server

package com.gatewayserver.controller;

import com.common.grpc.AddressCreateRequest;
import com.common.grpc.AddressServiceGrpc;
import com.common.grpc.AddressUpdateRequest;
import com.common.grpc.IdRequest;
import com.common.grpc.UserIdRequest;
import com.gatewayserver.dto.request.user.AddressCreateRequestBody;
import com.gatewayserver.dto.request.user.AddressUpdateRequestBody;
import com.gatewayserver.dto.response.user.AddressResponseView;
import com.gatewayserver.helper.GrpcHelper;
import lombok.RequiredArgsConstructor;
import net.devh.boot.grpc.client.inject.GrpcClient;
import org.common.http.Envelope;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("/addresses")
@RequiredArgsConstructor
public class AddressController {

    @GrpcClient("core")
    private AddressServiceGrpc.AddressServiceBlockingStub stub;

    private static String normalize(String s){
        return s == null ? "" : s;
    }

    private static String z(String s){
        return (s == null || s.isBlank()) ? null : s;
    }

    @PostMapping
    public Mono<ResponseEntity<Envelope<Void>>> create(
            @RequestBody AddressCreateRequestBody body){
        return GrpcHelper.callGrpcVoid(() ->
                stub.create(AddressCreateRequest.newBuilder()
                        .setContactName(body.contactName())
                        .setContactPhone(body.contactName())
                        .setAddressLine1(body.addressLine1())
                        .setAddressLine2(body.addressLine2() == null
                                ? ""
                                : body.addressLine2())
                        .setDistrict(body.district())
                        .setCity(body.city())
                        .setCountry(body.country()==null
                                ? ""
                                : body.country())
                        .setPostalCode(body.postalCode()==null
                                ? ""
                                : body.postalCode())
                        .build()));
    }

    @PatchMapping("/{id}")
    public Mono<ResponseEntity<Envelope<Void>>> update(
            @PathVariable String id,
            @RequestBody AddressUpdateRequestBody body){
        return GrpcHelper.callGrpcVoid(() ->
                stub.update(AddressUpdateRequest.newBuilder()
                        .setId(id)
                        .setContactName(normalize(body.contactName()))
                        .setContactPhone(normalize(body.contactPhone()))
                        .setAddressLine1(normalize(body.addressLine1()))
                        .setAddressLine2(normalize(body.addressLine2()))
                        .setDistrict(normalize(body.district()))
                        .setCity(normalize(body.city()))
                        .setCountry(normalize(body.country()))
                        .setPostalCode(normalize(body.postalCode()))
                        .build()));
    }

    @DeleteMapping("/{id}")
    public Mono<ResponseEntity<Envelope<Void>>> softDelete(
            @PathVariable String id){
        return GrpcHelper.callGrpcVoid(() -> stub.softDelete(IdRequest.newBuilder()
                .setId(id)
                .build()));
    }

    @PostMapping("/{id}/default-shipping")
    public Mono<ResponseEntity<Envelope<Void>>> setDefaultShipping(
            @PathVariable String id){
        return GrpcHelper.callGrpcVoid(() -> stub.setDefaultShipping(IdRequest.newBuilder()
                .setId(id)
                .build()));
    }

    @PostMapping("/{id}/default-billing")
    public Mono<ResponseEntity<Envelope<Void>>> setDefaultBilling(@PathVariable String id){
        return GrpcHelper.callGrpcVoid(() -> stub.setDefaultBilling(IdRequest.newBuilder()
                .setId(id)
                .build()));
    }

    @GetMapping("/user/{userId}")
    public Mono<ResponseEntity<Envelope<Envelope.Page<AddressResponseView>>>> listByUser(
            @PathVariable String userId,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size){
        return GrpcHelper.callGrpc(
                () -> stub.listByUser(
                        UserIdRequest.newBuilder()
                                .setUserId(userId)
                                .setPage(page)
                                .setSize(size)
                                .build()),
                p -> Envelope.Page.<AddressResponseView>builder()
                        .page(p.getPage())
                        .size(p.getSize())
                        .total(p.getTotal())
                        .totalPages(p.getTotalPages())
                        .docs(p.getDocsList()
                                .stream()
                                .map(d -> new AddressResponseView(
                                        d.getId(),
                                        d.getContactName(),
                                        d.getContactPhone(),
                                        d.getAddressLine1(),
                                        z(d.getAddressLine2()),
                                        d.getDistrict(),
                                        d.getCity(),
                                        z(d.getCountry()),
                                        z(d.getPostalCode()),
                                        d.getIsDefaultShipping(),
                                        d.getIsDefaultBilling())
                                )
                                .toList())
                        .build());
    }
}
package com.gatewayserver.controller;

import com.common.grpc.AssignRoleRequest;
import com.common.grpc.CreateRoleRequest;
import com.common.grpc.PageRequest;
import com.common.grpc.RoleName;
import com.common.grpc.RoleServiceGrpc;
import com.gatewayserver.dto.request.user.AssignRoleRequestBody;
import com.gatewayserver.dto.request.user.CreateRoleRequestBody;
import com.gatewayserver.dto.response.user.RoleResponseView;
import com.gatewayserver.helper.GrpcHelper;
import lombok.RequiredArgsConstructor;
import net.devh.boot.grpc.client.inject.GrpcClient;
import org.common.http.Envelope;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("/roles")
@RequiredArgsConstructor
public class RoleController {

    @GrpcClient("core")
    private RoleServiceGrpc.RoleServiceBlockingStub stub;

    @PostMapping
    public Mono<ResponseEntity<Envelope<Void>>> create(
            @RequestBody CreateRoleRequestBody body){
        return GrpcHelper.callGrpcVoid(() -> stub.create(CreateRoleRequest.newBuilder()
                .setName(body.name())
                .build()));
    }

    @DeleteMapping("/{name}")
    public Mono<ResponseEntity<Envelope<Void>>> softDelete(
            @PathVariable String name){
        return GrpcHelper.callGrpcVoid(() ->
                stub.softDelete(RoleName.newBuilder()
                        .setName(name)
                        .build()));
    }

    @PostMapping("/{name}/restore")
    public Mono<ResponseEntity<Envelope<Void>>> restore(
            @PathVariable String name){
        return GrpcHelper.callGrpcVoid(() ->
                stub.restore(RoleName.newBuilder()
                        .setName(name)
                        .build()));
    }

    @PostMapping("/assign")
    public Mono<ResponseEntity<Envelope<Void>>> assign(
            @RequestBody AssignRoleRequestBody body){
        return GrpcHelper.callGrpcVoid(() ->
                stub.assign(AssignRoleRequest.newBuilder()
                        .setUserId(body.userId())
                        .setRoleName(body.roleName())
                        .build()));
    }

    @PostMapping("/remove")
    public Mono<ResponseEntity<Envelope<Void>>> remove(
            @RequestBody AssignRoleRequestBody body){
        return GrpcHelper.callGrpcVoid(() ->
                stub.remove(AssignRoleRequest.newBuilder()
                        .setUserId(body.userId())
                        .setRoleName(body.roleName()).
                        build()));
    }

    @GetMapping("/user/{userId}")
    public Mono<ResponseEntity<Envelope<Envelope.Page<RoleResponseView>>>> listUserRoles(
            @PathVariable String userId){
        return GrpcHelper.callGrpc(
                () -> stub.listUserRoles(AssignRoleRequest.newBuilder()
                        .setUserId(userId)
                        .build()),
                p -> Envelope.Page.<RoleResponseView>builder()
                        .page(p.getPage())
                        .size(p.getSize())
                        .total(p.getTotal())
                        .totalPages(p.getTotalPages())
                        .docs(p.getDocsList()
                                .stream()
                                .map(d -> new RoleResponseView(d.getName()))
                                .toList()
                        )
                        .build()
        );
    }

    @GetMapping
    public Mono<ResponseEntity<Envelope<Envelope.Page<RoleResponseView>>>> listAll(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size){
        return GrpcHelper.callGrpc(
                () -> stub.listAll(
                        PageRequest.newBuilder()
                                .setPage(page)
                                .setSize(size)
                                .build()),
                p -> Envelope.Page.<RoleResponseView>builder()
                        .page(p.getPage())
                        .size(p.getSize())
                        .total(p.getTotal())
                        .totalPages(p.getTotalPages())
                        .docs(p.getDocsList()
                                .stream()
                                .map(d -> new RoleResponseView(d.getName()))
                                .toList()
                        )
                        .build()
        );
    }
}

package com.gatewayserver.controller;

import com.common.grpc.ToggleActiveRequest;
import com.common.grpc.UpdateProfileRequest;
import com.common.grpc.UserServiceGrpc;
import com.gatewayserver.dto.request.user.UpdateProfileRequestBody;
import com.gatewayserver.dto.response.user.MeResponseView;
import com.gatewayserver.helper.GrpcHelper;
import com.google.protobuf.Empty;
import lombok.RequiredArgsConstructor;
import net.devh.boot.grpc.client.inject.GrpcClient;
import org.common.http.Envelope;
import org.springdoc.core.service.GenericResponseService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("/users")
@RequiredArgsConstructor
public class UserController {
    private final GenericResponseService responseBuilder;
    @GrpcClient("core")
    private UserServiceGrpc.UserServiceBlockingStub stub;

    @PostMapping("/toggle-active")
    public Mono<ResponseEntity<Envelope<Void>>> toggleActive(
            @RequestParam String userId,
            @RequestParam boolean active){
        return GrpcHelper.callGrpcVoid(() -> stub.toggleActive(
                ToggleActiveRequest.newBuilder()
                        .setUserId(userId)
                        .setActive(active)
                        .build()));
    }

    @GetMapping("/me")
    public Mono<ResponseEntity<Envelope<MeResponseView>>> me(){
        return GrpcHelper.callGrpc(
                () -> stub.getMe(Empty.getDefaultInstance()),
                response -> new MeResponseView(
                        response.getId(),
                        response.getUsername(),
                        response.getEmail(),
                        response.getFullName(),
                        response.getPhoneNumber(),
                        response.getIsActive(),
                        response.getIsVerified()
                )
        );
    }

    @PatchMapping("/me")
    public Mono<ResponseEntity<Envelope<Void>>> update(
            @RequestBody UpdateProfileRequestBody body){
        return GrpcHelper.callGrpcVoid(() ->
                stub.updateProfile(UpdateProfileRequest.newBuilder()
                        .setFullName(body.fullName() == null
                                ? ""
                                : body.fullName())
                        .setPhoneNumber(body.phoneNumber()==null
                                ? ""
                                : body.phoneNumber())
                        .build()));
    }
}

package com.gatewayserver.dto.request.user;


public record AddressCreateRequestBody (
    String contactName,
    String contactPhone,
    String addressLine1,
    String addressLine2,
    String district,
    String city,
    String country,
    String postalCode)
{}

package com.gatewayserver.dto.request.user;

public record AddressUpdateRequestBody (
    String contactName,
    String contactPhone,
    String addressLine1,
    String addressLine2,
    String district,
    String city,
    String country,
    String postalCode){
}

package com.gatewayserver.dto.request.user;

public record AssignRoleRequestBody (
    String userId,
    String roleName){
}

package com.gatewayserver.dto.request.user;

public record CreateRoleRequestBody (
    String name){
}

package com.gatewayserver.dto.request.user;

public record UpdateProfileRequestBody (
    String fullName,
    String phoneNumber){
}
package com.gatewayserver.dto.response.user;


public record AddressResponseView (
    String id,
    String contactName,
    String contactPhone,
    String addressLine1,
    String addressLine2,
    String district,
    String city,
    String country,
    String postalCode,
    Boolean isDefaultShipping,
    Boolean isDefaultBilling){
}

package com.gatewayserver.dto.response.user;


public record MeResponseView (
    String id,
    String username,
    String email,
    String fullName,
    String phoneNumber,
    Boolean isActive,
    Boolean isVerified){
}

package com.gatewayserver.dto.response.user;

public record RoleResponseView (
    String name){
}

package com.gatewayserver.dto.request.authentication;

public record IntrospectRequestBody(String token) {
}

package com.gatewayserver.dto.request.authentication;

public record LoginRequestBody(
        String username,
        String email,
        String password) {
}


package com.gatewayserver.dto.request.authentication;

public record LogoutRequestBody(String token) {
}


package com.gatewayserver.dto.request.authentication;

public record RefreshRequestBody(String token) {
}


package com.gatewayserver.dto.request.authentication;

public record RegisterRequestBody(
        String username,
        String email,
        String password) {
}


package com.gatewayserver.dto.request.otp;

public record OtpVerificationRequestBody(
        String email,
        String otpCode) {
}


package com.gatewayserver.dto.request.otp;

public record ResetPasswordRequestBody(
        String email,
        String otp,
        String newPassword) {
}


package com.gatewayserver.dto.request.otp;

public record UserOtpRequestBody(String email) {
}

package com.gatewayserver.dto.response.authentication;

public record IntrospectView(
        boolean valid,
        String userId) {
}

package com.gatewayserver.dto.response.authentication;

public record LoginView(
        String accessToken,
        String refreshToken,
        String accessExpiry,
        String refreshExpiry) {
}

package com.gatewayserver.dto.response.authentication;

public record RefreshView(
        String accessToken,
        String refreshToken,
        String accessExpiry,
        String refreshExpiry) {
}

package com.gatewayserver.dto.response.otp;

public record OtpResponseView(
        String email,
        String message
) {
}

package com.gatewayserver.exception;

import io.grpc.StatusRuntimeException;
import org.common.http.Envelope;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
public class GlobalErrorHandler {

    @ExceptionHandler(StatusRuntimeException.class)
    public ResponseEntity<Envelope<Void>> handleGrpcException(
            StatusRuntimeException statusRuntimeException){
        Envelope<Void> envelope = GrpcErrorMapper.toEnvelope(statusRuntimeException);
        return ResponseEntity.status(envelope.getStatus())
                .body(envelope);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Envelope<Void>> handleAnyException(
            Exception exception){
        Envelope<Void> envelope = Envelope.err(
                500,
                "UNCATEGORIZED_EXCEPTION",
                exception.getMessage(),
                null
        );
        return ResponseEntity.status(500)
                .body(envelope);
    }
}

package com.gatewayserver.exception;

import io.grpc.Status;
import io.grpc.StatusRuntimeException;
import lombok.NoArgsConstructor;
import org.common.exception.ErrorCode;
import org.common.http.Envelope;

import java.util.EnumMap;
import java.util.Map;
import java.util.Optional;

@NoArgsConstructor
public final class GrpcErrorMapper {
    private static final Map<Status.Code, ErrorCode> FALLBACK_BY_GRPC =
            new EnumMap<>(Status.Code.class);
    static {
        FALLBACK_BY_GRPC.put(Status.Code.UNAUTHENTICATED, ErrorCode.UNAUTHENTICATED);
        FALLBACK_BY_GRPC.put(Status.Code.PERMISSION_DENIED, ErrorCode.UNAUTHORIZED);
        FALLBACK_BY_GRPC.put(Status.Code.NOT_FOUND, ErrorCode.USER_NOT_FOUND);
        FALLBACK_BY_GRPC.put(Status.Code.ALREADY_EXISTS, ErrorCode.USER_ALREADY_EXISTS);
        FALLBACK_BY_GRPC.put(Status.Code.INVALID_ARGUMENT, ErrorCode.FAILED_VALIDATE_TOKEN);
        FALLBACK_BY_GRPC.put(Status.Code.FAILED_PRECONDITION, ErrorCode.FAILED_VALIDATE_TOKEN);
    }

    private static Optional<ErrorCode> fromName(
            String name){
        if (name == null || name.isBlank()) {
            return Optional.empty();
        }
        try {
            return Optional.of(ErrorCode.valueOf(name));
        } catch (IllegalArgumentException ex) {
            return Optional.empty();
        }
    }

    public static <T> Envelope<T> toEnvelope(
            StatusRuntimeException exception){
        String description = exception.getStatus().getDescription();
        Status.Code grpc = exception.getStatus().getCode();

        ErrorCode errorCode = fromName(description)
                .orElse(FALLBACK_BY_GRPC.getOrDefault(grpc, ErrorCode.UNCATEGORIZED_EXCEPTION));

        return Envelope.err(
                errorCode.http(),
                errorCode.name(),
                errorCode.getMessage(),
                null
        );
    }
}

package com.gatewayserver.helper;

import com.gatewayserver.exception.GrpcErrorMapper;
import io.grpc.StatusRuntimeException;
import lombok.experimental.UtilityClass;
import org.common.http.Envelope;
import org.springframework.http.ResponseEntity;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

import java.util.function.Function;
import java.util.function.Supplier;

@UtilityClass
public class GrpcHelper {

    // ===== Helper chung cho tất cả endpoint =====
    public <R, V> Mono<ResponseEntity<Envelope<V>>> callGrpc(
            Supplier<R> supplier,
            Function<R, V> mapper) {
        return Mono.fromCallable(supplier::get)
                .map(mapper)
                .map(Envelope::ok)
                .map(ResponseEntity::ok)
                .onErrorResume(StatusRuntimeException.class, ex ->
                        Mono.just(GrpcErrorMapper.<V>toEnvelope(ex))
                                .map(env -> ResponseEntity
                                        .status(env.getStatus())
                                        .body(env)))
                .subscribeOn(Schedulers.boundedElastic());
    }

    public Mono<ResponseEntity<Envelope<Void>>> callGrpcVoid(
            Runnable runnable) {
        return Mono.fromRunnable(runnable)
                .thenReturn(Envelope.<Void>ok(null))
                .map(ResponseEntity::ok)
                .onErrorResume(io.grpc.StatusRuntimeException.class, ex ->
                        Mono.just(GrpcErrorMapper.<Void>toEnvelope(ex))
                                .map(env -> ResponseEntity
                                        .status(env.getStatus())
                                        .body(env)))
                .subscribeOn(Schedulers.boundedElastic());
    }

}

package com.gatewayserver.controller;

import com.common.grpc.AuthServiceGrpc;
import com.common.grpc.IntrospectRequest;
import com.common.grpc.LoginRequest;
import com.common.grpc.LogoutRequest;
import com.common.grpc.RefreshRequest;
import com.common.grpc.RegisterRequest;
import com.gatewayserver.dto.request.authentication.IntrospectRequestBody;
import com.gatewayserver.dto.request.authentication.LoginRequestBody;
import com.gatewayserver.dto.request.authentication.LogoutRequestBody;
import com.gatewayserver.dto.request.authentication.RefreshRequestBody;
import com.gatewayserver.dto.request.authentication.RegisterRequestBody;
import com.gatewayserver.dto.response.authentication.IntrospectView;
import com.gatewayserver.dto.response.authentication.LoginView;
import com.gatewayserver.dto.response.authentication.RefreshView;
import com.gatewayserver.helper.GrpcHelper;
import lombok.RequiredArgsConstructor;
import net.devh.boot.grpc.client.inject.GrpcClient;
import org.common.http.Envelope;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("/auth")
@RequiredArgsConstructor
public class AuthController {


    @GrpcClient("core")
    private AuthServiceGrpc.AuthServiceBlockingStub auth;

    @PostMapping(
            value = "/register",
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> register(
            @RequestBody RegisterRequestBody body) {
        return GrpcHelper.callGrpcVoid(
                () -> auth.register(RegisterRequest.newBuilder()
                        .setUsername(body.username())
                        .setEmail(body.email())
                        .setPassword(body.password())
                        .build()));
    }

    @PostMapping(
            value = "/login",
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<LoginView>>> login(
            @RequestBody LoginRequestBody body) {
        return GrpcHelper.callGrpc(() -> auth.login(LoginRequest.newBuilder()
                        .setUsername(body.username())
                        .setEmail(body.email())
                        .setPassword(body.password())
                        .build()),
                response -> new LoginView(
                        response.getAccessToken(),
                        response.getRefreshToken(),
                        response.getAccessExpiry(),
                        response.getRefreshExpiry()
                )
        );
    }

    @PostMapping(
            value = "/refresh",
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<RefreshView>>> refresh(
            @RequestBody RefreshRequestBody body) {
        return GrpcHelper.callGrpc(
                () -> auth.refresh(
                        RefreshRequest.newBuilder().setToken(body.token())
                                .build()),
                resp -> new RefreshView(
                        resp.getAccessToken(),
                        resp.getRefreshToken(),
                        resp.getAccessExpiry(),
                        resp.getRefreshExpiry()
                )
        );
    }

    @PostMapping(
            value = "/introspect",
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<IntrospectView>>> introspect(
            @RequestBody IntrospectRequestBody body) {
        return GrpcHelper.callGrpc(
                () -> auth.introspect(
                        IntrospectRequest.newBuilder().setToken(body.token())
                                .build()),
                resp -> new IntrospectView(resp.getValid(), resp.getUserId())
        );
    }

    @PostMapping(
            value = "/logout",
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> logout(
            @RequestBody LogoutRequestBody body) {
        return GrpcHelper.callGrpcVoid(
                () -> auth.logout(LogoutRequest.newBuilder()
                        .setToken(body.token())
                        .build()));
    }
}

package com.gatewayserver.controller;

import com.common.grpc.OtpServiceGrpc;
import com.common.grpc.OtpVerificationRequest;
import com.common.grpc.ResetPasswordRequest;
import com.common.grpc.UserOtpRequest;
import com.gatewayserver.dto.request.otp.OtpVerificationRequestBody;
import com.gatewayserver.dto.request.otp.ResetPasswordRequestBody;
import com.gatewayserver.dto.request.otp.UserOtpRequestBody;
import com.gatewayserver.dto.response.otp.OtpResponseView;
import com.gatewayserver.helper.GrpcHelper;
import lombok.RequiredArgsConstructor;
import net.devh.boot.grpc.client.inject.GrpcClient;
import org.common.http.Envelope;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("/auth")
@RequiredArgsConstructor
public class OtpController {

    @GrpcClient("core")
    private OtpServiceGrpc.OtpServiceBlockingStub otp;

    //OTP
    @PostMapping(
            value = "/otp",
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<OtpResponseView>>> sendOtp(
            @RequestBody UserOtpRequestBody body) {
        return GrpcHelper.callGrpc(() -> otp.sendOtp(UserOtpRequest.newBuilder()
                        .setEmail(body.email())
                        .build()),
                response -> new OtpResponseView(
                        response.getEmail(),
                        response.getMessage()
                )
        );
    }

    @PostMapping(
            value = "/otp/verify",
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> verifyOtp(
            OtpVerificationRequestBody body) {
        return GrpcHelper.callGrpcVoid(() -> otp.verifyOtp(
                OtpVerificationRequest.newBuilder()
                        .setEmail(body.email())
                        .setOtpCode(body.otpCode())
                        .build()));
    }

    //Password
    @PostMapping(
            value = "/password-reset",
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<OtpResponseView>>> requestResetPassword(
            @RequestBody UserOtpRequestBody body) {
        return GrpcHelper.callGrpc(() -> otp.requestResetPassword(
                        UserOtpRequest.newBuilder().setEmail(body.email()).build()),
                response -> new OtpResponseView(
                        response.getEmail(),
                        response.getMessage()
                )
        );
    }

    @PostMapping(
            value = "/password-reset/verify",
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> verifyOtpPassword(
            OtpVerificationRequestBody body) {
        return GrpcHelper.callGrpcVoid(() -> otp.verifyOtpPassword(
                OtpVerificationRequest.newBuilder()
                        .setEmail(body.email())
                        .setOtpCode(body.otpCode())
                        .build()));
    }

    @PostMapping(
            value = "/password-reset/reset",
            consumes = MediaType.APPLICATION_JSON_VALUE,
            produces = MediaType.APPLICATION_JSON_VALUE
    )
    public Mono<ResponseEntity<Envelope<Void>>> resetPassword(
            ResetPasswordRequestBody body) {
        return GrpcHelper.callGrpcVoid(() -> otp.resetPassword(
                ResetPasswordRequest.newBuilder()
                        .setEmail(body.email())
                        .setOtp(body.otp())
                        .setNewPassword(body.newPassword())
                        .build()));
    }
}



package com.gatewayserver.configuration.grpc;

import io.grpc.CallOptions;
import io.grpc.Channel;
import io.grpc.ClientCall;
import io.grpc.ClientInterceptor;
import io.grpc.ClientInterceptors;
import io.grpc.ForwardingClientCall;
import io.grpc.Metadata;
import io.grpc.MethodDescriptor;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class ClientBearerInterceptor
        implements ClientInterceptor {

    private final String token;
    public static final Metadata.Key<String> AUTH =
            Metadata.Key.of("Authorization", Metadata.ASCII_STRING_MARSHALLER);

    @Override
    public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(
            MethodDescriptor<ReqT, RespT> methodDescriptor,
            CallOptions callOptions,
            Channel channel) {

        return new ForwardingClientCall.SimpleForwardingClientCall<ReqT, RespT>(channel.newCall(methodDescriptor, callOptions)) {
            @Override
            public void start(Listener<RespT> responseListener,
                              Metadata headers) {
                headers.put(AUTH, "Bearer " + token);
                super.start(responseListener, headers);
            }
        };
    }

    public static Channel withToken(
            Channel channel,
            String token) {
        return ClientInterceptors.intercept(channel, new ClientBearerInterceptor(token));
    }
}

package com.gatewayserver.configuration.routes;

import org.springframework.cloud.gateway.route.RouteLocator;
import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class GatewayRoutes {

    @Bean
    public RouteLocator routes(RouteLocatorBuilder builder){
        return builder.routes()
                // /core/** -> lb://core/**
                .route("core",
                        r -> r.path("/core/**")
                                .filters(f -> f.rewritePath("^/core(?<segment>/.*)$", "${segment}"))
                                .uri("lb://core"))
                // /business/** -> lb://business/**
                .route("business",
                        r -> r.path("/business/**")
                                .filters(f -> f.rewritePath("^/business(?<segment>/.*)$", "${segment}"))
                                .uri("lb://business"))
                .build();
    }
}

package com.gatewayserver.configuration.security;

import com.common.grpc.AuthServiceGrpc;
import com.common.grpc.IntrospectRequest;
import com.common.grpc.IntrospectResponse;
import com.nimbusds.jwt.SignedJWT;
import lombok.RequiredArgsConstructor;
import net.devh.boot.grpc.client.inject.GrpcClient;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.security.oauth2.jwt.ReactiveJwtDecoder;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

import java.text.ParseException;
import java.time.Instant;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

@Component
@RequiredArgsConstructor
public class GrpcReactiveJwtDecoder implements ReactiveJwtDecoder {

    @GrpcClient("core")
    private AuthServiceGrpc.AuthServiceBlockingStub authServiceBlockingStub;

    @Override
    public Mono<Jwt> decode(String token) throws JwtException {
        return Mono.fromCallable(() -> {
                    IntrospectResponse introspectResponse = authServiceBlockingStub
                            .introspect(IntrospectRequest.newBuilder()
                                        .setToken(token)
                                        .build());

                    if (!introspectResponse.getValid()) {
                        throw new JwtException("INVALID_TOKEN");
                    }

                    SignedJWT signedJWT;
                    try {
                        signedJWT = SignedJWT.parse(token);
                    } catch (ParseException e) {
                        throw new JwtException("JWT_PARSE_ERROR", e);
                    }

                    Map<String, Object> headers =
                            new HashMap<>(signedJWT.getHeader().toJSONObject());

                    Map<String, Object> claims =
                            new HashMap<>(signedJWT.getJWTClaimsSet().getClaims());

                    Date iat = signedJWT.getJWTClaimsSet().getIssueTime();
                    Date exp = signedJWT.getJWTClaimsSet().getExpirationTime();

                    Instant issuedAt = (iat == null) ? null : iat.toInstant();
                    Instant expiresAt = (exp == null) ? null : exp.toInstant();

                    return new Jwt(token, issuedAt, expiresAt, headers, claims);
                })
                .onErrorMap(e -> (e instanceof JwtException)
                        ? e
                        : new JwtException("AUTH_INTROSPECT_UNAVAILABLE", e));
    }
}

package com.gatewayserver.configuration.security;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.common.exception.ErrorCode;
import org.common.http.Envelope;
import org.springframework.http.MediaType;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.server.ServerAuthenticationEntryPoint;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

@Component
public class ReactiveJwtEntryPoint implements ServerAuthenticationEntryPoint {

    private final ObjectMapper mapper = new ObjectMapper();

    @Override
    public Mono<Void> commence(
            ServerWebExchange exchange,
            AuthenticationException authenticationException) {
        ErrorCode code = ErrorCode.UNAUTHENTICATED;
        Envelope<Void> envelope = Envelope.err(
                code.http(),
                code.name(),
                code.getMessage(),
                null
        );

        ServerHttpResponse response = exchange.getResponse();
        response.setStatusCode(org.springframework.http.HttpStatus.valueOf(code.http()));
        response.getHeaders().setContentType(MediaType.APPLICATION_JSON);
        return response.writeWith(Mono.fromSupplier(() -> {
            try {
                byte[] bytes = mapper.writeValueAsBytes(envelope);
                return response.bufferFactory().wrap(bytes);
            } catch (Exception e) {
                return response.bufferFactory().wrap(new byte[0]);
            }
        }));
    }
}

package com.gatewayserver.configuration.security;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.security.web.server.SecurityWebFilterChain;

import static org.common.constant.SecurityConstants.PUBLIC_ENDPOINTS;

@Configuration
@RequiredArgsConstructor
public class SecurityConfig {

    private final GrpcReactiveJwtDecoder jwtDecoder;
    private final ReactiveJwtEntryPoint entryPoint;

    @Bean
    public SecurityWebFilterChain springSecurityFilterChain(
            ServerHttpSecurity http) {
        return http.csrf(ServerHttpSecurity.CsrfSpec::disable)
                .authorizeExchange(ex -> ex
                        .pathMatchers(PUBLIC_ENDPOINTS).permitAll()
                        .anyExchange().authenticated())
                .oauth2ResourceServer(oauth -> oauth.jwt(j -> j
                                .jwtDecoder(jwtDecoder))
                        .authenticationEntryPoint(entryPoint))
                .build();
    }
}

server:
  port: 8092

spring:
  application:
    name: "gatewayserver"
  config:
    import: "optional:configserver:http://localhost:8091/"
  cloud:
    gateway:
      server:
        webflux:
          discovery:
            locator:
              enabled: true
              lower-case-service-id: true
          httpclient:
            connect-timeout: 1000
            response-timeout: 10s
          default-filters: []
          filter:
            json-to-grpc:
              enabled:
                false

eureka:
  instance:
    preferIpAddress: true
  client:
    registerWithEureka: true
    fetchRegistry: true
    serviceUrl:
      defaultZone: "http://localhost:8090/eureka/"

  main:
    web-application-type: reactive
  data:
    redis:
      connect-timeout: 2s
      host: localhost
      port: 6379
      timeout: 1s

grpc:
  client:
    core:
      address: 'static://localhost:50051'
      enableKeepAlive: true
      keepAliveWithoutCalls: true
      negotiationType: plaintext
    business:
      address: 'static://localhost:50052'
      negotiationType: PLAINTEXT

management:
  endpoints:
    web:
      exposure:
        include: "*"
  endpoint:
    gateway:
      access: unrestricted
  info:
    env:
      enabled: true

info:
  app:
    name: "gatewayserver"
    description: "Yunomi Xavia Gateway Server Application"
    version: "1.0.0"

logging:
  level:
    com:
      eazybytes:
        gatewayserver: DEBUG

resilience4j.circuitbreaker:
  configs:
    default:
      slidingWindowSize: 10
      permittedNumberOfCallsInHalfOpenState: 2
      failureRateThreshold: 50
      waitDurationInOpenState: 10000
